This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Inform Designer's Manual
************************

   This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J. Madsen
<ac608@yfn.ysu.edu>.  This is revision 4 of the Info version, last updated
on 8 June 1997.

* Menu:

* Introduction::                About Inform and the Inform Designer's Manual
* Programming Language::        The Inform language tutorial and reference
* Using the Compiler::          Compiler options, include files, & libraries
* Fundamentals::                Inform revolves around objects and actions
* The Model World::             How Inform models the virtual world
* Describing and Parsing::      How Inform converses with the player
* Testing and Hacking::         Debugging and special effects
* Appendix::                    Tables and summaries
* Answers::                     Answers to all the exercises
* Index::                       Attributes, properties, objects, & routines
* Concept Index::               Index of authors and ideas
* Secondary Index::             Other references to indexed properties

 -- The Detailed Node Listing --

The Inform programming language

* Routines::                    Constants, expressions, and functions
* Data Structures::             Directives, global variables, & arrays
* Objects::                     Objects, properties, attributes, & messages

Using the Compiler

* The Language of Inform::      The language of Inform
* Compiler Options::            Compiler options and memory settings
* Error Messages::              All the Inform error messages

Fundamentals

* Getting Started::             Introducing `Ruins', our example game
* Messages and Classes::        Introducing messages and classes
* Actions and Reactions::       Actions are generated by the user's requests

The Model World

* Places::                      Places, scenery, directions and the map
* Containers::                  Containers, supporters and sub-objects
* Doors::                       Doors, bridges, and ladders
* Switchable Objects::          Things you can turn on and off
* Things to Enter::             Things to enter, travel in and push around
* Reading Matter::              Reading matter and consultation
* Living Creatures::            Living creatures and conversation
* Light and Dark::              The light and the dark
* Daemons::                     Daemons and the passing of time
* Player::                      Starting, moving, changing & killing the player
* Constants and Scoring::       Miscellaneous constants and scoring
* Extending the Library::       Extending and redefining the Library

Describing and Parsing

* Describing Objects::          Describing objects and rooms
* Listing Objects::             Listing and grouping objects
* Parsing Nouns::               How nouns are parsed
* Plural Names::                Plural names for duplicated objects
* Parsing Verbs::               How verbs are parsed
* Grammar Tokens::              Tokens of grammar
* Scope::                       Scope and what you can see
* Helping the Parser::          Helping the parser out of trouble

Testing and Hacking

* Debugging::                   Debugging verbs and tracing
* Run-Time Limitations::        Limitations on the run-time format
* Boxes::                       Boxes, menus and drawings
* Assembly Language::           Descending into assembly language

Tables and summaries

* Operators::                   Table of operators and their precedence
* Statements::                  Table of all Inform statements
* Directives::                  Table of all Inform directives
* Grammar::                     Summary of the `Verb' and `Extend' directives
* Attributes::                  The attributes defined by the library
* Properties::                  The properties defined by the library
* Objects and Routines::        Library-defined objects and routines
* Actions and Fake Actions::    The actions and fakes
* Library Messages::            All the library messages and their numbers
* Entry Points::                Entry points and meaningful constants
* Program Order::               What order the program should be in
* Lexicon::                     A short Inform lexicon

Answers to all the exercises

* Answer 1::                    mushroom picking
* Answer 2::                    opening medicine bottle
* Answer 3::                    before on second noun
* Answer 4::                    action validation
* Answer 5::                    orange cloud surrounding player
* Answer 6::                    Mayan directions
* Answer 7::                    reflecting the map east-west
* Answer 8::                    exchanging "east"/"west"
* Answer 9::                    acquisitive bag
* Answer 10::                   television set
* Answer 11::                   glass and steel boxes
* Answer 12::                   macrame bag
* Answer 13::                   plank bridge
* Answer 14::                   cage to open and enter
* Answer 15::                   car that won't go east
* Answer 16::                   pushing pumice ball uphill
* Answer 17::                   Tyndale's Bible
* Answer 18::                   bearded psychiatrist
* Answer 19::                   removing conversation actions
* Answer 20::                   computer (voice-activated)
* Answer 21::                   Charlotte playing Simon Says
* Answer 22::                   Charlotte's clapping game
* Answer 23::                   Dyslexic Dan
* Answer 24::                   extensions for one actor only
* Answer 25::                   alarm clock
* Answer 26::                   tricorder
* Answer 27::                   replicator
* Answer 28::                   communications badge
* Answer 29::                   Zen flight computer
* Answer 30::                   Picard and Maharg
* Answer 31::                   Martha the telepath
* Answer 32::                   troll afraid of the dark
* Answer 33::                   pet moth escapes in the dark
* Answer 34::                   thief who wanders
* Answer 35::                   weight--watching daemon
* Answer 36::                   scuttling claws
* Answer 37::                   Answer to Exercise 37
* Answer 38::                   midnight
* Answer 39::                   nightfall and daybreak
* Answer 40::                   mid-air location
* Answer 41::                   long time-scale game
* Answer 42::                   player reacting before
* Answer 43::                   silencing player
* Answer 44::                   the player's wayhel
* Answer 45::                   Giant with conscience
* Answer 46::                   chessboard of rooms
* Answer 47::                   varying the prompt
* Answer 48::                   Answer to Exercise 48
* Answer 49::                   printing pronouns
* Answer 50::                   ornate box (inventory inside)
* Answer 51::                   very verbose mode
* Answer 52::                   double inventory
* Answer 53::                   Scrabble pieces
* Answer 54::                   three denominations of coin
* Answer 55::                   I Ching coins
* Answer 56::                   tomato in red or green
* Answer 57::                   the artiste formerly known as Princess
* Answer 58::                   drinks machine
* Answer 59::                   parsing adjectives
* Answer 60::                   referring to objects by number
* Answer 61::                   wild-card for a single object
* Answer 62::                   wild-card for multiple objects
* Answer 63::                   "fly in amber"
* Answer 64::                   cherubim plural
* Answer 65::                   Answer to Exercise 65
* Answer 66::                   moving to a room by typing its name
* Answer 67::                   genie muddling black and white
* Answer 68::                   footnotes
* Answer 69::                   low numbers in French
* Answer 70::                   floating-point numbers
* Answer 71::                   phone numbers
* Answer 72::                   parsing times of day
* Answer 73::                   spaceship control panel
* Answer 74::                   implementing parser primitives
* Answer 75::                   parsing any quoted text
* Answer 76::                   tokens which never match
* Answer 77::                   Answer to Exercise 77
* Answer 78::                   third noun for parser
* Answer 79::                   "scope" verb
* Answer 80::                   "megalook" verb
* Answer 81::                   putting everything in scope
* Answer 82::                   room divided by glass window
* Answer 83::                   dwarf breathing in dark
* Answer 84::                   nose attached to player
* Answer 85::                   sterilising machine
* Answer 86::                   red sticky label
* Answer 87::                   "lock" and "unlock" inferring keys
* Answer 88::                   quotations in boxes
* Answer 89::                   Invisiclues hints
* Answer 90::                   saving the character
* Answer 91::                   title page
* Answer 92::                   status line invisible
* Answer 93::                   status line showing treasure
* Answer 94::                   status line with compass rose
* Answer 95::                   status line with centred room
* Answer 96::                   printf routine


File: inform,  Node: Introduction,  Next: Programming Language,  Prev: Top,  Up: Top

Introduction
************

     I will build myself a copper tower
     With four ways out and no way in
     But mine the glory, mine the power...
     
     -- Louis MacNeice (1907-1963), Flight of the Heart

Inform is a system for creating adventure games, and this is the book to
read about it.

   Infocom format `story files' (adventure games, that is) can be
played on almost any computer, from personal organisers to mainframes,
with the aid of `interpreter' programs.  The task of the Inform
`compiler' is to translate a textual description of a game into a story
file.  The result will play identically on any machine of any model.

   Inform is a suite of software, called the `library', as well as a
compiler.  Without the library, it would be a major undertaking to
write a description of even the smallest game.  The library has two
ingredients: the parser, a program for translating written English
inputs into a form games can more easily understand, and the "world
model", a complex web of rules common to all adventure games.  Given
these, the designer only needs to describe things and give any
exceptional rules that apply.  ("There is a bird here, which is a
normal item except that you can't pick it up.")

   The library is rich in detail.  The parser recognises over 80
distinct verbs and a vocabulary of about 300 words even before any
rooms or objects are created, and is programmable and highly flexible.
It can handle ambiguities, clarify its input by asking questions
("Which key do you mean...?") and can cope properly with plurals,
vagueness, conversation, pronouns and the player becoming someone else
in mid-game.  It can be configured to languages other than English.
The world-model includes rooms, items, vehicles, duplicates,
containers, doors, things on top of other things, light and darkness,
switching things on and off, opening, closing and locking things,
looking up information in books, entering things, scoring and so forth.

   Just as Inform has two strands -- compiler and library -- so this
manual has two parts: Programming and Designing.  In Book One, small
computer programs are written to perform simple calculations, never
using the library.  Subsections listed in slanted text on the detailed
contents page become technical but the rest is pitched at newcomers and
can be skim-read by anyone with prior experience of a programming
language such as C or Pascal.  Book Two is entirely about making games.

   Newcomers are invited to work through *Note Routines:: and *Note
Getting Started::, the "getting started" sections in Books One and Two,
before reading much more of either.

   In trying to be both a tutorial and reference work, this book aims
itself in style halfway between the two extremes of manual, Tedium and
Gnawfinger's Elements of Batch Processing in COBOL-66, third edition,
and Mr Blobby's Blobby Book of Computer Fun.  (This makes some sections
both leaden and patronising.)  Passages which divert the main story,
usually to tell an unexpurgated truth which may confuse or bore a
newcomer, are marked with warning exclamation points `!!'.  Examples of
program are set in typewriter font.  Mundane or irrelevant passages in
longer examples are sometimes replaced with a line reading just "..."

   To keep Book Two from clogging up with examples, many are set as
"exercises", with "answers" given in full at the back of the book.
Harder exercises are marked with exclamation points and some are very
hard indeed.  I emphasize that the exercises are often intended as a
way of presenting answers to deliberately difficult questions, to
assist experts: the curse of Adventure design-languages is the feature
which is ideal for the simple but too inflexible to cope with the
complicated.  For a list of exercises with page references to question
and answer, see under "exercises" in the Index.

   A better tutorial than attempting the exercises, then, is probably
to make a simple game, as demonstrated in Chapter III, and then add an
example of each new feature as you work through Chapters IV and V.

   Many sections end with a `References' paragraph referring to yet
more examples which can be found in Inform's demonstration games.  All
of these have publically available source code (see the Inform home
page): those most frequently referred to are `Advent' (a full version
of the original mainframe `Adventure', which contains a good deal of
"everyday Inform"), `Adventureland' (a version of Scott Adams's
primitive classic), `Alice Through The Looking-Glass' (a heavily
annotated game, developed in the course of Gareth Rees's WWW tutorial
for Inform), `Balances' (a short story consisting of puzzles which
stretch the parser's abilities) and `Toyshop' (hardly a game: more an
incoherent collection of unusual objects).  In addition, the little
game `Ruins' is developed in the course of Chapters III and IV of this
manual.

   Finally, the "game" called `Museum of Inform' simulates a museum
whose exhibits are solutions to the exercises in this manual.

   Copyright on Inform, the program and its source code, its example
games and documentation (including this book) is retained by Graham
Nelson, who asserts the moral right to be identified as the author
under the Copyrights, Designs and Patents Act 1988.  Having said this,
I am happy for it to be freely distributed to anybody who wants a copy,
provided that: (a) distributed copies are not substantially different
from those archived by the author, (b) this and other copyright
messages are always retained in full, and (c) no profit is involved.
(Exceptions to these rules must be negotiated directly with the
author.)  However, a story file produced with the Inform compiler (and
libraries) then belongs to its author, and may be sold for profit if
desired, provided that its game banner contains the information that it
was compiled by Inform, and the Inform version number.

   The Internet source for Inform material (executables of the compiler
for different machines, source code, the library files and example
games) is the German National Research Centre for Computer Science,
where Volker Blasius maintains an archive at the anonymous FTP site
ftp.gmd.de.  Inform can be found at:

ftp://ftp.gmd.de/if-archive/infocom/compilers/inform6

Another useful resource is the Inform 6 home page on the `World Wide
Web', which includes Gareth Rees's `Alice' tutorial, located at:

http://www.gnelson.demon.co.uk/inform.html

This manual describes Inform release 6.13 (or later), using library
release 6/5 (or later).  Earlier Inform 6 compilers and libraries are
very similar but Inform 5.5 and 5/12 are very different.

   This manual has evolved from seven earlier publications, once rather
makeshift and sometimes defensive ("Inform is an easel, not a
painting").  There were specifications of the run-time code format and
literary critiques of games gone by: like an oven manual padded out
with both a cookery book and a detailed plan of the gas mains.  This
book contains just the instructions for the oven.

   So there are four `companion volumes'.  The Craft of Adventure is an
essay on the design of adventure games;  The Z-Machine Standards
Document minutely covers the run-time format and Inform assembly
language, its lowest level; and The Inform Technical Manual documents
Inform's internal working in great detail, and includes a formal
context-free grammar for the Inform language.  The Inform Translator's
Manual describes how to write a language definition file for games
which speak languages other than English.

   Some of the ideas of Inform came from an incremental multi-player
game called Tera, on the Cambridge University mainframe, written by
Dilip Sequeira and the author in 1990 (whose compiler was called
Teraform); in turn, this stole a little from David Seal and Jonathan
Thackray's game assembler; which dates back to the close of the 1970s
and was written for `Acheton', perhaps the first worthwhile game
written outside America.  Still, much of the Inform kernel derives
ultimately from the IEEE Computer article `Zork: A Computerized Fantasy
Simulation Game' by P. David Lebling, Marc S. Blank and Timothy A.
Anderson; and more was suggested by Richard Tucker and Gareth Rees,
among others.

   The list of those who have helped the project along is legion: I
should like to thank them all, porters, users and critics alike, but
especially Volker Blasius, Paul David Doherty, Mark Howell, the ever
avuncular Bob Newell, Robert Pelak, Gareth Rees, Jorund Rian, Dilip
Sequeira, Richard Tucker, Christopher Wichura and John Wood.

   One final word.  I should like to dedicate this book, impertinently
perhaps, to our illustrious predecessors: Will Crowther, Don Woods and
the authors of Infocom, Inc.

                                                   Graham Nelson
                                                   Oxford
                                                   May 1997

     And if no piece of chronicle we prove,
     We'll build in sonnets pretty rooms;
     As well a well wrought urn becomes
     The greatest ashes, as half-acre tombs.
     
     -- John Donne (1571?-1631), The Canonization


File: inform,  Node: Programming Language,  Next: Using the Compiler,  Prev: Introduction,  Up: Top

The Inform programming language
*******************************

     Language is a cracked kettle on which we beat out tunes for bears
     to dance to, while all the time we long to move the stars to pity.

     -- Gustave Flaubert (1821-1880)

* Menu:

* Routines::                    Constants, expressions, and functions
* Data Structures::             Directives, global variables, & arrays
* Objects::                     Objects, properties, attributes, & messages


File: inform,  Node: Routines,  Next: Data Structures,  Prev: Programming Language,  Up: Programming Language

The language of routines
========================

* Menu:

* First Principles::            About the Inform programming language
* Example 1::                   "Hello World", the simplest Inform program
* Example 2::                   "Elsinore", introducing subroutines
* Numbers and Variables::       Using numbers and variables in Inform
* Arithmetic Expressions::      Inform's arithmetic operators
* Arguments and Return Values:: Calling and returning from routines
* Example 3::                   "Cubes", a simple subroutine example
* Conditions::                  Conditions are either true or false
* Example 4::                   "Factorials", using the `if' statement
* Code Blocks::                 Grouping statements; Using `else' and `switch'
* Loops::                       while, do...until, for, break, & continue
* Example 5::                   "RunPuzzle", using a simple `while' loop
* Jumping Around::              `quit', `jump', and the program state
* Printing Output::             String constants and printing output
* Example 6::                   Printing numbers in hexadecimal
* Random and Indirect::         Two built-in functions: `random' and `indirect'
* Accepting Input::             Reading input from the keyboard


File: inform,  Node: First Principles,  Next: Example 1,  Prev: Routines,  Up: Routines

First principles
----------------

   This chapter aims to introduce beginners to Inform as though it were
a general-purpose programming language (rather than a tool for designing
adventure games).  The examples given will be short programs performing
simple calculations (rather than games).  To begin with, the Inform
language is:

  1. *Compiled.*

     That is, the Inform compiler translates text written by the author
     (called the "source code") into a program (called the "object code"
     since it is the object of the exercise).  This translation is only
     done once, but the resulting program can be run many times.

  2. *Procedural.*

     That is, a program is divided into a number of "routines" (also
     called "functions" or "procedures"), each being a list of orders
     to be obeyed (though these orders are traditionally called
     "statements").  When the program is run, only one thing happens at
     a time: at any given moment, a single routine is being obeyed.

  3. *Object-oriented.*

     That is, the fabric of a typical Inform program will be woven
     around "objects" being dealt with, which are regarded as being
     self-contained.  For example, a program to simulate a warehouse
     might have objects representing lorries and containers; each
     object would have a position and contents at any given time.  The
     program would have general rules describing "lorry" and
     "container" as well as actual examples of each.  A lorry would
     have the ability to receive a message telling it to do something,
     such as "load up with a container and leave the warehouse".

  4. *Portable.*

     That is, once Inform has compiled the source code (having found no
     mistakes), the resulting program can be run on almost any model of
     computer.  It will exhibit exactly the same behaviour on each of
     them.  It cannot depend on the "environment": it cannot suddenly
     run out of memory and crash, for instance.

The computer runs an Inform program (which need not be a game) with the
aid of an "interpreter".  There are at least 40 different interpreters
available for this format (called the "Z-machine" or "Infocom format")
and there may be a choice available for your model of computer: it is a
good idea to get the most modern and accurate possible.  Look to see if
they support the Z-Machine Standard, and if so, up to what revision
number.


File: inform,  Node: Example 1,  Next: Example 2,  Prev: First Principles,  Up: Routines

Example 1: Hello World
----------------------

   Traditionally, all programming language tutorials begin by giving a
program which does nothing but print "Hello world" and stop.  Here is
such a program in Inform:

    !  "Hello world" example program

    [ Main;
      print "Hello world^";
    ];

   The text after the exclamation mark is a "comment", that is, it is
text written in the margin by the author to remind himself of what is
going on here.  Such text means nothing to Inform, which ignores
anything on the same line and to the right of an exclamation mark.

   Once commentary has been stripped out, Inform regards the source
code as a list of things to look at, divided by semicolons ;.  It
treats line breaks, tab characters and spaces all as so-called "white
space": that is, a gap between two things whose size is unimportant.
Thus, exactly the same program would be produced by the source code

       [
          Main   ;
    print
             "Hello world^"          ;
        ]
      ;

or, at the other extreme, by

    [ Main;print"Hello world^";];

Laying out programs legibly is a matter of forming good habits.

!!  The exception to the rule about ignoring white space is inside
quoted text, where

     "Hello    world^" and "Hello world^"

are genuinely different pieces of text and are treated as such.  Inform
treats text inside quotation marks with much more care than its ordinary
program material: for instance, an exclamation mark inside quotation
marks will not cause the rest of its line to be thrown away as a
comment.

   Every program must contain a routine called Main, and in this
example it is the only routine.  When a program is set running, the
first instruction obeyed is the first one in Main, and it carries on
line by line from there.  This process is called "execution".  When the
Main routine is finished, the program stops.

   The routine has only one statement:

    print "Hello world^"

Printing is the process of writing text onto the computer screen.  This
statement prints the two words "Hello world" and then skips the rest of
the line (or "prints a new-line"): the ^ character, in quoted text,
means "new-line".  For example, the statement

    print "Blue^Red^Green^"

prints up:

         Blue
         Red
         Green

print is one of 28 statements in the Inform language.  The full list is
as follows:

box        break      continue   do       font      for         give
if         inversion  jump       move     new_line  objectloop  print
print_ret  quit       read       remove   restore   return      rfalse
rtrue      save       spaces     string   style     switch      while

(Only about 20 of these are commonly used.)  *Note Routines:: covers
all those not concerned with objects, which are left until *Note
Objects::.


File: inform,  Node: Example 2,  Next: Numbers and Variables,  Prev: Example 1,  Up: Routines

Example 2: Elsinore
-------------------

   The following source code has three routines, Main, Rosencrantz and
Hamlet:

    [ Main;
      print "Hello from Elsinore.^";
      Rosencrantz();
    ];
    [ Rosencrantz;
      print "Greetings from Rosencrantz.^";
    ];
    [ Hamlet;
      print "The rest is silence.^";
    ];

The resulting program prints up

         Hello from Elsinore.
         Greetings from Rosencrantz.

but the text "The rest is silence." is never printed.  Execution begins
at Main, and "Hello from Elsinore" is printed; next, the statement
Rosencrantz() causes the Rosencrantz routine to be executed.  That
continues until it ends with the close-routine marker ], whereupon
execution goes back to Main just after the point where it left off:
since there is nothing more to do in Main, the program finishes.  Thus,
Rosencrantz is executed but Hamlet is not.

   In fact, when the above program is compiled, Inform notices that
Hamlet is never needed and prints out a warning to that effect.  The
exact text produced by Inform varies from machine to machine, but will
be something like this:

    RISC OS Inform 6.03 (May 11th 1996)
    line 8: Warning: Routine "Hamlet" declared but not used
    Compiled with 0 errors and 1 warning

Errors are mistakes in the program which cause Inform to refuse to
compile it, but this is only a warning.  It alerts the programmer that
a mistake may have been made (because presumably the programmer has
simply forgotten to put in a statement calling Hamlet) but it doesn't
prevent the compilation from taking place.  Note that the opening line
of the routine Hamlet occurs on the 8th line of the program above.

   Usually there are mistakes in a newly-written program and one goes
through a cycle of running a first draft through Inform, receiving a
batch of error messages, correcting the draft according to these
messages, and trying again.  A typical error message would occur if, on
line 3, we had mistyped Rosncrantz() for Rosencrantz().  Inform would
then have produced:

    RISC OS Inform 6.03 (May 11th 1996)
    line 5: Warning: Routine "Rosencrantz" declared but not used
    line 8: Warning: Routine "Hamlet" declared but not used
    line 3: Error: No such constant as "Rosncrantz"
    Compiled with 1 error and 2 warnings (no output)

The error message means that on line 3 Inform ran into a name which did
not correspond to any known quantity (it isn't the name of any routine,
in particular).  Note that Inform never produces the final story file
if errors occur during compilation: this prevents it from producing
damaged story files.  Note also that Inform now thinks the routine
Rosencrantz is never used, since it didn't recognise the mistype in the
way that a human reader would have done.  Warnings are sometimes
produced by accident this way, so it is generally a good idea to worry
about fixing errors first and warnings afterward.


File: inform,  Node: Numbers and Variables,  Next: Arithmetic Expressions,  Prev: Example 2,  Up: Routines

Numbers and variables
---------------------

   Internally -- that is, whatever the outward appearance -- all
programs essentially manipulate numbers.  Inform understands "number"
to be a whole number in the range -32768 to +32767.  (Special
programming would be required to represent larger numbers or
fractions.)  There are three notations for writing numbers in Inform:
here is an example of each.

    -4205
    $3f08
    $$1000111010110

The difference is the radix, or base, in which they are expressed.  The
first is in decimal (base 10), the second hexadecimal (base 16, where
the digits after 9 are written a to f or A to F) and the third binary
(base 2).  Once Inform has read in a number, it forgets which notation
was used: for instance, if the source code is altered so that $$10110
is replaced by 22, this makes no difference to the program produced.

   A print statement can print numbers as well as text, though it always
prints them back in ordinary decimal notation.  For example, the program

    [ Main;
      print "Today's number is ", $3f08, ".^";
    ];

prints up

         Today's number is 16136.

since 16136 in base 10 is the same number as 3f08 in hexadecimal.

   Inform recognises many other notations as "constants", that is,
values which are literally described in the source code.  A full list
will appear later, but one other is that a single character between
single quotation marks, for instance

    'x'

is a constant.  A "character" is a single letter or typewriter-symbol,
and all that the programmer needs to know is that each possible
character has its own numerical value.

!! For most characters, this numerical value is the standard ASCII
value for the character: for instance, 'x' has numerical value 120.
(This is true even if Inform is being run on a model of computer which
doesn't normally use the ASCII character set.)  Exotic characters such
as '@ss' (the Inform notation for German sz) have non-standard codes:
see the Z-Machine Standards Document if you really need to know.

   Finally, in this initial batch of constant notations, Inform provides
two special constants:

true
false

which are used to describe the truth or otherwise of possible
conditions.

!! true has the numerical value 1; false has the numerical value 0.

   Inform has a concept of "variable" like that used in algebra, where
it is easy but limiting to express facts using only numbers:

       34 - 34 = 0
       11 - 11 = 0
     694 - 694 = 0

Although suggestive this fails to express the general case: that any
number subtracted from itself leaves zero.  We express this fact
symbolically in algebra by writing

     x - x = 0

where x is a variable; the implication being "whatever value x actually
is, the statement is still true".

   Likewise, in Inform what seems to be a word of text may be a
variable which represents a number: when the source code is compiled,
Inform cannot know what numerical value this text represents.  When the
program is run, it will always have a numerical value at any given
time.  If oil_left is a variable, the statement

    print "There are ", oil_left, " gallons remaining.^";

is executed as if oil_left were replaced by whatever that value
currently is.  Later on, the same statement may be executed again,
producing different text because by that time oil_left has a different
value.

   Inform can only know that text (such as oil_left) represents a
variable if the source code has "declared" that it does.  Each routine
can declare its own selection of variables on its opening line.  For
example, in the program

    [ Main alpha b;
      alpha = 2200;
      b = 201;
      print "Alpha is ", alpha, " while b is ", b, "^";
    ];

the Main routine has two variables, alpha and b.  Like most names given
in source code (called "identifiers"), variable names can be at most 32
characters long and may contain letters of the alphabet, decimal digits
or the underscore _ character (often used to imitate a space).  To
prevent them looking too much like numbers, though, they may not start
with a decimal digit.  (So a44 is legal but 44a is not.) For example:

    turns_still_to_play
    chart45
    X

are all possible variable names.  Inform ignores any difference between
upper and lower case letters in such names, for example considering
CHArt45 as the same name as chArT45.

   The = sign occurring twice in the above routine is an example of an
"operator": a notation usually made up of the symbols on the
non-alphabetic keys on a typewriter and which means something is to be
done with the items it is written next to.  In this context, = means
"set equal to".  When the statement alpha = 2200 is executed at run
time, the current value of the variable alpha becomes 2200 (and it
keeps that value until another such statement changes it).

   The variables alpha and b are called "local variables" because they
are local to Main: in effect, they are its private property.  The
program

    [ Main alpha;
      alpha = 2200;
      Rival();
    ];
    [ Rival;
      print alpha;
    ];

causes an error on the print statement in Rival, since alpha does not
exist there.  Indeed, Rival could even have defined a variable of its
own also called alpha and this would have been a separate variable with
a probably different value.


File: inform,  Node: Arithmetic Expressions,  Next: Arguments and Return Values,  Prev: Numbers and Variables,  Up: Routines

Arithmetic expressions
----------------------

   The Inform language is rich with operators, making it concise but
not always very readable.  Feeling comfortable with the operators is
the main step towards being able to follow Inform source code.
Fortunately, these operators are based on the usual rules for writing
arithmetic formulae, which gives them a headstart in familiarity.

   Indeed, the most commonly used operators are "arithmetic": they
combine one or more numbers to give one resulting number.  Whenever a
number is expected in a statement, a general "expression" can be given
instead: that is, a calculation giving a number as a result.  For
example, the statement

    seconds = 60*minutes + 3600*hours

sets the variable seconds equal to 60 times the variable minutes plus
3600 times the variable hours.  White space is not needed between
operators and "operands" (the numbers to be operated on): the spaces on
either side of the + sign are only provided for legibility.

   Ordinary arithmetic is carried out with the operators + (plus), -
(minus), * (times) and / (divided by).

   Usually dividing one integer by another leaves a remainder: for
example, 3 goes into 7 twice, with remainder 1.  In Inform notation,

         7/3 evaluates to 2
         7%3 evaluates to 1

the % operator meaning "remainder after division", usually called just
"remainder".  Dividing by zero is impossible and a program which tries
to do this will go wrong.

!!  As a brief aside, this gives an example of how Inform can and can't
help the programmer to spot mistakes.  The program

    [ Main;
      print 73/0;
    ];

produces an error when compiled:

    line 2: Error: Division of constant by zero
    >   print 73/0;

since Inform can see that it definitely involves doing something
illegal.  However, Inform fails to notice anything amiss with the
equivalent program

    [ Main x;
      x = 0;
      print 73/x;
    ];

and this program compiles correctly.  The resulting story file will
"crash" when it is run, that is, catastrophically halt.  The moral is
that just because Inform compiles a program without errors, it does not
follow that the program does what the programmer intends.

In a complicated expression the order in which the operators work may
affect the result.  As most human readers would, Inform works out both
of

    23 + 2 * 700
    2 * 700 + 23

to 1423, because the operator * has "precedence" over + and so is acted
on first.  Brackets may be used to overcome this:

    (23 + 2) * 700
    2 * (700 + 23)

evaluate to 17500 and 1446 respectively.  Each operator has such a
"precedence level".  When two operators have the same precedence level
(for example, + and - are of equal precedence) calculation is (almost
always) "left associative", that is, carried out left to right: the
notation

    a - b - c

is equivalent to

    (a - b) - c

The standard rules for writing mathematics give + and - equal
precedence, lower than that of * and / (which are also equal).  Inform
agrees and also pegs % equal to * and /.

   The final purely arithmetic operator is "unary minus".  This is
written as a minus sign - but is not the same as ordinary subtraction.
The expression:

    -credit

means the same thing as:

    0 - credit

The operator - is different from all those mentioned so far because it
operates only on one number.  It has higher precedence than any of the
five "binary" operations above.  For example,

    -credit - 5

means (-credit) - 5 and not -(credit - 5).

   One way to imagine precedence is to think of it as glue attached to
the operator.  A higher level means stronger glue.  Thus, in

    23 + 2 * 700

the glue around the * is stronger than that around the +, so that 2 and
700 belong bound to the *.

   Some operators do not simply act on values but actually change the
current values of variables: expressions containing these are called
"assignments" (because they assign values as well as working them out).
One such operator is `set equals':

    alpha = 72

sets the variable alpha equal to 72.  Just like + and the others, it
also comes up with an answer: as it happens, this value is also 72.

   The other two assignment operators are ++ and --, which will be
familiar to any C programmer.  They are unary operators, and can be used
in any of the following ways:

    variable++
    ++variable
    variable--
    --variable

The first of these means "read off the value of variable, and afterwards
increase that value by one".  In ++variable the "increment" (or
increase by 1) happens first, and then the value is read off.  -- acts
in a similar way but "decrements" (decreases by 1).  These operators
are provided as convenient shorthand forms, since their effect could
usually be achieved in other ways (just using + and -).

   For example, suppose the variable has value 12.  Then the result
would be 12, 13, 12 or 11 respectively; the value left in variable
afterwards would be 13, 13, 11 or 11.

   Note that expressions like

    500++        (4*alpha)--     34 = beta

are meaningless: the values of 500 and 34 cannot be altered, and Inform
knows no way to adjust alpha so as to make 4*alpha decrease by 1.  All
three will cause errors.

!! "Bitwise operators" are provided for manipulating binary numbers on
a digit-by-digit basis, something which is often done in programs which
are working with low-level data or data which has to be stored very
compactly.  Inform provides &, bitwise AND, |, bitwise OR and ~, bitwise
NOT.  For each digit, such an operator works out the value in the answer
from the values in the operands.  Bitwise NOT acts on a single operand
and results in the number whose i-th binary digit is the opposite of
that in the operand (a 1 for a 0, a 0 for a 1).  Bitwise AND (and OR)
acts on two numbers and sets the i-th digit to 1 if both operands have
(either operand has) i-th digit set.  So, for example,

    $$10111100 & $$01010001  ==  $$00010000

!! The remaining operators will be described as needed: the full table
is laid out in *Note Operators::.


File: inform,  Node: Arguments and Return Values,  Next: Example 3,  Prev: Arithmetic Expressions,  Up: Routines

Arguments and Return Values
---------------------------

   As has already been said, in Inform jargon the word "function" is
synonymous with "routine".  A function might be defined as a
correspondence

                  (x1 , ... , xn) --> f(x1 , ... , xn)

where a set of input numbers are fed in, and a single value comes out.
These input numbers are called "arguments".  The value coming out is the
"return value", or is said to be "returned".

   All Inform routines are like this.  A number of arguments are fed in
when the routine is "called" (that is, set running) and there is always
a single numerical result.  This result is called the "return value"
because it is returned to the rest of the program.  Some very simple
routines conceal this.  For instance, consider Sonnet:

    [ Main;
      Sonnet();
    ];
    [ Sonnet;
      print "When to the sessions of sweet silent thought^";
      print "I summon up remembrance of things past^";
    ];

Sonnet is a routine which takes as input no arguments at all (it is an
example of the n=0 case), so it is called with nothing in between the
round brackets.  Although it does return a value (as it happens, this
value is true) the statement Sonnet() simply calls the routine and
throws the return value away.  If Main were instead given by

    [ Main;
      print Sonnet();
    ];

then the output would be

         When to the sessions of sweet silent thought
         I summon up remembrance of things past
         1

because the print statement in Main has been told to print the number
resulting from a call to Sonnet.

   Thus in Inform there is no such thing as a "void function" or
"procedure": every routine returns a number even though this may
immediately be thrown away as unwanted.

   When a routine is called,

    Routine(arg1, ...)

the arguments given are substituted into the first variables declared
for Routine, and execution begins running through Routine.  Usually,
there can be any number of arguments from none up to 7, though a limit
of 3 applies if Inform has been told to compile an early-model story
file (see *Note Run-Time Limitations:: for details).

   If execution runs into the ] end-of-routine marker, so that the
routine is finished without having specified any definite return value,
then this value is true.  (This is why the printed return value of
Sonnet is 1: true has the value 1.)


File: inform,  Node: Example 3,  Next: Conditions,  Prev: Arguments and Return Values,  Up: Routines

Example 3: Cubes
----------------

   A more typical, though less aesthetic, example than Sonnet:

    [ Main;
      print Cube(1), " ";
      print Cube(2), " ";
      print Cube(3), " ";
      print Cube(4), " ";
      print Cube(5), "^";
    ];
    [ Cube x;
      return x*x*x;
    ];

which, when executed, prints

         1 8 27 64 125

The expression Cube(3) is calculated by substituting the number 3 into
the variable x when Cube is set running: the result of the expression
is the number returned by Cube.

   Any "missing arguments" in a routine call are set equal to zero, so
the call Cube() is legal and does the same as Cube(0).


File: inform,  Node: Conditions,  Next: Example 4,  Prev: Example 3,  Up: Routines

Conditions: if, true and false
------------------------------

   Such routines are too simple, so far, even to express many
mathematical functions, and more flexibility will be needed.

   A "control construct" is a kind of statement which controls whether
or not, and if so how many times or in what order, other statements are
executed.  The simplest of these is if:

         if (<condition>) <statement>

which executes the <statement> only if the <condition>, when it is
tested, turns out to be true.  For example, when the statement

    if (alpha == 3) print "Hello";

is executed, the word "Hello" is printed only if the variable alpha
currently has value 3.  It is important not to confuse the == operator
(test whether or not equal to) with the = operator (set equal to).

   Conditions are always given in (round) brackets.  The basic
conditions are as follows:
    (a == b)           Number a equals number b
    (a ~= b)           Number a doesn't equal number b
    (a >= b)           a is greater than or equal to b
    (a <= b)           a is less than or equal to b
    (a > b)            a is greater than b
    (a < b)            a is less than b
    (o1 in o2)         Object o1 possessed by o2
    (o1 notin o2)      Object o1 not possessed by o2
    (o1 has a)         Object o1 has attribute a
    (o1 hasnt a)       Object o1 hasn't attribute a
    (o1 provides m)    Object o1 provides property m
    (o1 ofclass c)     Object o1 inherits from class c

(The conditions relating to objects will be discussed later.) A useful
extension to this set is provided by the special operator or, which
gives alternative possibilities.  For example,

    if (alpha == 3 or 4) print "Scott";
    if (alpha ~= 5 or 7 or 9) print "Amundsen";

where two or more values are given with the word or between.  Scott is
printed if alpha has value either 3 or 4, and Amundsen if the value of
alpha is not 5, is not 7 and is not 9.  or can be used with any of the
conditions, and any number of alternatives can be given.  For example

    if (player in Forest or Village or Building) ...

often makes code much clearer than writing three separate conditions
out; or

    if (x > 100 or y) ...

can be convenient to check whether x is bigger than the minimum of 100
or y.

   Conditions can also be built up from simpler ones (just as long
expressions are built up from single operators) using the three logical
operators &&, || and ~~ (pronounced "and", "or" and "not").  For
example,

    if (alpha == 1 && (beta > 10 || beta < -10)) print "Lewis";
    if (~~(alpha > 6)) print "Clark";

"Lewis" is printed if alpha equals 1 and beta is outside the range -10
to 10; "Clark" is printed if alpha is less than or equal to 6.

   The discussion above makes it look as if conditions are special
kinds of expression which can only use certain operators (==, &&, or
and so on).  But this is not true: conditions are expressions like any
other.  It's legal to write

    print (beta == 4);

for instance, and this results in 1 being printed if beta equals 4, and
0 otherwise.  Thus:

         the result of a true condition is 1;
         the result of a false condition is 0.

This is why true and false are defined to be 1 and 0 respectively.
Thus one might write code along the lines of

    betaisfour = (beta == 4);
    ...
    if (betaisfour == true) ...

though it would be easier to write

    betaisfour = (beta == 4);
    ...
    if (betaisfour) ...

because, just as conditions can be used as numbers, so numbers can be
used as conditions.  Zero is considered to be "false", and all other
values are considered to be "true".  Thus

    if (1) print "Magellan";
    if (0) print "da Gama";

always results in "Magellan", never "da Gama", being printed.

   One common use of variables is as "flags".  A flag can only hold the
value 0 or 1, false or true according to some state of the program.
The fact that a number can be used as a condition allows
natural-looking statements like

    if (lower_caves_explored) print "You've already been that way.";

where lower_caves_explored is a variable being used in the program as a
flag.

!! Note that && and || only work out what they absolutely need to in
order to decide the truth.  That is,

    if (A && B) ...

will work out A first.  If this is false, there's no need to work out B,
and it never is worked out.  Only if A is true is B actually tested.
This only matters when working out conditions like

    if (x==7 && Routine(5)) ...

where it can be important to know that the Routine is never called if x
has a value other than 7.


File: inform,  Node: Example 4,  Next: Code Blocks,  Prev: Conditions,  Up: Routines

Example 4: Factorials
---------------------

   The factorial of a positive integer n is defined as the product

       1 * 2 * 3 * ... * n

so that, for example, the factorial of 4 is 24.  Here is an Inform
routine to calculate factorials:

    [ Main;
      print Factorial(7), "^";
    ];
    [ Factorial n;
      if (n==1) return 1;
      return n*Factorial(n-1);
    ];

This calculates 7 factorial and comes up with 5040.  (Factorials grow
rapidly and 8 factorial is already too large to hold in a standard
Inform number, so calling Factorial(8) would give a wrong answer.)

   The routine Factorial actually calls itself: this is called
"recursion".  Execution reaches "seven routines deep" before starting
to return back up.  Each of these copies of Factorial runs with its own
private copy of the variable n.

   Recursion is hazardous.  If one calls the routine

    [ Disaster;
      return Disaster();
    ];

then despite the reassuring presence of the word return, execution is
tied up forever, unable to finish evaluating the return value.  The
first call to Disaster needs to make a second before it can finish; the
second needs to make a third; and so on.  This is an example of a
programming error which will prove disastrous when the program is run,
yet will cause no errors when the source code is compiled.  (It can be
proved that it is impossible to construct a compiler capable of
detecting this general class of mistake.  Inform does not even try.)
