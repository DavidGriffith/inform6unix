This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Answers,  Next: Index,  Prev: Appendix,  Up: Top

Answers to all the exercises
****************************

     World is crazier and more of it than we think,
     Incorrigibly plural.  I peel and portion
     A tangerine and spit the pips and feel
     The drunkenness of things being various.
     
     -- Louis MacNeice (1907-1963), Snow

* Menu:

* Answer 1::                    mushroom picking
* Answer 2::                    opening medicine bottle
* Answer 3::                    before on second noun
* Answer 4::                    action validation
* Answer 5::                    orange cloud surrounding player
* Answer 6::                    Mayan directions
* Answer 7::                    reflecting the map east-west
* Answer 8::                    exchanging "east"/"west"
* Answer 9::                    acquisitive bag
* Answer 10::                   television set
* Answer 11::                   glass and steel boxes
* Answer 12::                   macrame bag
* Answer 13::                   plank bridge
* Answer 14::                   cage to open and enter
* Answer 15::                   car that won't go east
* Answer 16::                   pushing pumice ball uphill
* Answer 17::                   Tyndale's Bible
* Answer 18::                   bearded psychiatrist
* Answer 19::                   removing conversation actions
* Answer 20::                   computer (voice-activated)
* Answer 21::                   Charlotte playing Simon Says
* Answer 22::                   Charlotte's clapping game
* Answer 23::                   Dyslexic Dan
* Answer 24::                   extensions for one actor only
* Answer 25::                   alarm clock
* Answer 26::                   tricorder
* Answer 27::                   replicator
* Answer 28::                   communications badge
* Answer 29::                   Zen flight computer
* Answer 30::                   Picard and Maharg
* Answer 31::                   Martha the telepath
* Answer 32::                   troll afraid of the dark
* Answer 33::                   pet moth escapes in the dark
* Answer 34::                   thief who wanders
* Answer 35::                   weight--watching daemon
* Answer 36::                   scuttling claws
* Answer 37::                   Answer to Exercise 37
* Answer 38::                   midnight
* Answer 39::                   nightfall and daybreak
* Answer 40::                   mid-air location
* Answer 41::                   long time-scale game
* Answer 42::                   player reacting before
* Answer 43::                   silencing player
* Answer 44::                   the player's wayhel
* Answer 45::                   Giant with conscience
* Answer 46::                   chessboard of rooms
* Answer 47::                   varying the prompt
* Answer 48::                   Answer to Exercise 48
* Answer 49::                   printing pronouns
* Answer 50::                   ornate box (inventory inside)
* Answer 51::                   very verbose mode
* Answer 52::                   double inventory
* Answer 53::                   Scrabble pieces
* Answer 54::                   three denominations of coin
* Answer 55::                   I Ching coins
* Answer 56::                   tomato in red or green
* Answer 57::                   the artiste formerly known as Princess
* Answer 58::                   drinks machine
* Answer 59::                   parsing adjectives
* Answer 60::                   referring to objects by number
* Answer 61::                   wild-card for a single object
* Answer 62::                   wild-card for multiple objects
* Answer 63::                   "fly in amber"
* Answer 64::                   cherubim plural
* Answer 65::                   Answer to Exercise 65
* Answer 66::                   moving to a room by typing its name
* Answer 67::                   genie muddling black and white
* Answer 68::                   footnotes
* Answer 69::                   low numbers in French
* Answer 70::                   floating-point numbers
* Answer 71::                   phone numbers
* Answer 72::                   parsing times of day
* Answer 73::                   spaceship control panel
* Answer 74::                   implementing parser primitives
* Answer 75::                   parsing any quoted text
* Answer 76::                   tokens which never match
* Answer 77::                   Answer to Exercise 77
* Answer 78::                   third noun for parser
* Answer 79::                   "scope" verb
* Answer 80::                   "megalook" verb
* Answer 81::                   putting everything in scope
* Answer 82::                   room divided by glass window
* Answer 83::                   dwarf breathing in dark
* Answer 84::                   nose attached to player
* Answer 85::                   sterilising machine
* Answer 86::                   red sticky label
* Answer 87::                   "lock" and "unlock" inferring keys
* Answer 88::                   quotations in boxes
* Answer 89::                   Invisiclues hints
* Answer 90::                   saving the character
* Answer 91::                   title page
* Answer 92::                   status line invisible
* Answer 93::                   status line showing treasure
* Answer 94::                   status line with compass rose
* Answer 95::                   status line with centred room
* Answer 96::                   printf routine


File: inform,  Node: Answer 1,  Next: Answer 2,  Prev: Answers,  Up: Answers

Answer to Exercise 1: mushroom picking
======================================

   Change the mushroom's after rule to:

       after
       [;  Take: if (self hasnt general)
                 {   give self general;
                    "You pick the mushroom, neatly cleaving its thin stalk.";
                 }
                 "You pick up the slowly-disintegrating mushroom.";
           Drop: "The mushroom drops to the ground, battered slightly.";
       ],

As mentioned above, general is a general-purpose attribute, free for the
designer to use.  The `neatly cleaving' message can only happen once,
because after that the mushroom object must have general.  Note that
the mushroom is allowed to call itself self instead of mushroom.

   *Note Exercise 1: Getting Started.


File: inform,  Node: Answer 2,  Next: Answer 3,  Prev: Answer 1,  Up: Answers

Answer to Exercise 2: opening medicine bottle
=============================================

Object medicine "guaranteed child-proof medicine bottle" cupboard
  with name "medicine" "bottle",
       description "~Antidote only: no preventative effect.~",
       openup
       [;  give self open ~locked; "The bottle cracks open!";
       ],
  has  container openable locked;

Any other code in the game can send the message medicine.openup() to
crack open the bottle.  For brevity, this solution assumes that the
bottle is always visible to the player when it is opened -- if not the
printed message will be incongruous.

   *Note Exercise 2: Messages and Classes.


File: inform,  Node: Answer 3,  Next: Answer 4,  Prev: Answer 2,  Up: Answers

Answer to Exercise 3: before on second noun
===========================================

   Briefly: provide a GamePreRoutine which tests to see if second is an
object, rather than nothing or a number.  If it is, check whether the
object has a second_before rule (i.e. test the condition (object
provides second_before)).  If it has, send the second_before message to
it, and return the reply as the return value from GamePreRoutine.

   *Note Exercise 3: Actions and Reactions.


File: inform,  Node: Answer 4,  Next: Answer 5,  Prev: Answer 3,  Up: Answers

Answer to Exercise 4: action validation
=======================================

   Put any validation rules desired into the GamePreRoutine.  For
example, the following will filter out any stray Drop actions for
unheld objects:

[ GamePreRoutine;
  if (action==Drop && noun notin player)
      "You aren't holding ", (the) noun, ".";
  rfalse;
];

   *Note Exercise 4: Actions and Reactions.


File: inform,  Node: Answer 5,  Next: Answer 6,  Prev: Answer 4,  Up: Answers

Answer to Exercise 5: orange cloud surrounding player
=====================================================

Object orange_cloud "orange cloud"
  with name "orange" "cloud",
       react_before
       [;  Look: "You can't see for the orange cloud surrounding you.";
           Go, Exit: "You wander round in circles, choking.";
           Smell: if (noun==0) "Cinnamon?  No, nutmeg.";
       ],
  has  scenery;

   *Note Exercise 5: Places.


File: inform,  Node: Answer 6,  Next: Answer 7,  Prev: Answer 5,  Up: Answers

Answer to Exercise 6: Mayan directions
======================================

   Define four objects along the lines of:

Object white_obj "white wall" compass
  with name "white" "sac" "wall", article "the", door_dir n_to
  has  scenery;

and add the following line to Initialise:

remove n_obj; remove e_obj; remove w_obj; remove s_obj;

(We could even alias a new Property called white_to to be n_to, and
then enter map directions in the source code using Mayan direction
names.) As a fine point of style, turquoise (`yax') is the world colour
for `here', so add a grammar line to make this cause a "look":

Verb "turquoise" "yax" * -> Look;

   *Note Exercise 6: Places.


File: inform,  Node: Answer 7,  Next: Answer 8,  Prev: Answer 6,  Up: Answers

Answer to Exercise 7: reflecting the map east-west
==================================================

[ SwapDirs o1 o2 x;
  x=o1.door_dir; o1.door_dir=o2.door_dir; o2.door_dir=x; ];
[ ReflectWorld;
  SwapDirs(e_obj,w_obj); SwapDirs(ne_obj,nw_obj); SwapDirs(se_obj,sw_obj);
];

   *Note Exercise 7: Places.


File: inform,  Node: Answer 8,  Next: Answer 9,  Prev: Answer 7,  Up: Answers

Answer to Exercise 8: exchanging "east"/"west"
==============================================

   This is a prime candidate for using variable strings @nn.  Briefly:
at the head of the source, define

Lowstring east_str "east"; Lowstring west_str "west";

and then add two more routines to the game,

[ NormalWorld; String 0 east_str; String 1 west_str; ];
[ ReversedWorld; String 0 west_str; String 1 east_str; ];

where NormalWorld is called in Initialise or to go back to normal, and
ReversedWorld when the reflection happens.  Write @00 in place of east
in any double-quoted printable string, and similarly @01 for west.  It
will be printed as whichever is currently set.  (Inform provides up to
32 such variable strings.)

   *Note Exercise 8: Places.


File: inform,  Node: Answer 9,  Next: Answer 10,  Prev: Answer 8,  Up: Answers

Answer to Exercise 9: acquisitive bag
=====================================

Object -> bag "toothed bag"
  with name "toothed" "bag",
       description "A capacious bag with a toothed mouth.",
       before
       [; LetGo: "The bag defiantly bites itself
                  shut on your hand until you desist.";
          Close: "The bag resists all attempts to close it.";
       ],
       after
       [; Receive:
                 "The bag wriggles hideously as it swallows ",
                 (the) noun, ".";
       ],
  has  container open;

   *Note Exercise 9: Containers.


File: inform,  Node: Answer 10,  Next: Answer 11,  Prev: Answer 9,  Up: Answers

Answer to Exercise 10: television set
=====================================

Object television "portable television set" lounge
  with name "tv" "television" "set" "portable",
       before
       [;  SwitchOn: <<SwitchOn power_button>>;
           SwitchOff: <<SwitchOff power_button>>;
           Examine: <<Examine screen>>;
       ],
  has  transparent;
Object -> power_button "power button"
  with name "power" "button" "switch",
       after
       [;  SwitchOn, SwitchOff: <<Examine screen>>;
       ],
  has  switchable;
Object -> screen "television screen"
  with name "screen",
       before
       [;  Examine: if (power_button hasnt on) "The screen is black.";
               "The screen writhes with a strange Japanese cartoon.";
       ];

   *Note Exercise 10: Containers.


File: inform,  Node: Answer 11,  Next: Answer 12,  Prev: Answer 10,  Up: Answers

Answer to Exercise 11: glass and steel boxes
============================================

Object -> glass_box "glass box with a lid"
  with name "glass" "box" "with" "lid"
  has  container transparent openable open;
Object -> steel_box "steel box with a lid"
  with name "steel" "box" "with" "lid"
  has  container openable open;

   *Note Exercise 11: Containers.


File: inform,  Node: Answer 12,  Next: Answer 13,  Prev: Answer 11,  Up: Answers

Answer to Exercise 12: macrame bag
==================================

   (The describe part of this answer but is only decoration.)  Note the
careful use of inp1 and inp2 rather than noun or second: see the note
at the end of *Note Actions and Reactions::.

Object -> macrame_bag "macrame bag"
  with name "macrame" "bag" "string" "net" "sack",
       react_before
       [;  Examine, Search, Listen, Smell: ;
           default:
               if (inp1>1 && inp1 in self)
                   print_ret (The) inp1, " is tucked away in the bag.";
               if (inp2>1 && inp2 in self)
                   print_ret (The) inp2, " is tucked away in the bag.";
       ],
       describe
       [;  print "^A macrame bag hangs from the ceiling, shut tight";
           if (child(self)==0) ".";
           print ".  Inside you can make out ";
           WriteListFrom(child(self), ENGLISH_BIT); ".";
       ],
  has  container transparent;
Object -> -> "gold watch"
  with name "gold" "watch",
       description "The watch has no hands, oddly.",
       react_before
       [;  Listen: if (noun==0 or self) "The watch ticks loudly."; ];

   *Note Exercise 12: Containers.


File: inform,  Node: Answer 13,  Next: Answer 14,  Prev: Answer 12,  Up: Answers

Answer to Exercise 13: plank bridge
===================================

   The "plank breaking" rule is implemented here in its door_to routine.
Note that this returns `true' after killing the player.

Object -> PlankBridge "plank bridge"
  with description "Extremely fragile and precarious.",
       name "precarious" "fragile" "wooden" "plank" "bridge",
       when_open
           "A precarious plank bridge spans the chasm.",
       door_to
       [;  if (children(player)~=0)
           {   deadflag=1;
              "You step gingerly across the plank, which bows under
               your weight. But your meagre possessions are the straw
               which breaks the camel's back! There is a horrid crack...";
           }
           print "You step gingerly across the plank, grateful that
                  you're not burdened.^";
           if (location==NearSide) return FarSide; return NearSide;
       ],
       door_dir
       [;  if (location==NearSide) return s_to; return n_to;
       ],
       found_in NearSide FarSide,
  has  static door open;

There might be a problem with this solution if your game also contained
a character who wandered about, and whose code was clever enough to run
door_to routines for any doors it ran into.  If so, door_to could
perhaps be modified to check that the actor is the player.

   *Note Exercise 13: Doors.


File: inform,  Node: Answer 14,  Next: Answer 15,  Prev: Answer 13,  Up: Answers

Answer to Exercise 14: cage to open and enter
=============================================

Object -> cage "iron cage"
  with name "iron" "cage" "bars" "barred" "iron-barred",
       when_open
          "An iron-barred cage, large enough to stoop over inside,
           looms ominously here.",
       when_closed "The iron cage is closed.",
       inside_description "You stare out through the bars.",
  has  enterable container openable open transparent static;

   *Note Exercise 14: Things to Enter.


File: inform,  Node: Answer 15,  Next: Answer 16,  Prev: Answer 14,  Up: Answers

Answer to Exercise 15: car that won't go east
=============================================

   Change the car's before to

    before
    [; Go: if (noun==e_obj)
           {   print "The car will never fit through your front door.^";
               return 2;
           }
           if (car has on) "Brmm!  Brmm!";
           print "(The ignition is off at the moment.)^";
    ],

   *Note Exercise 15: Things to Enter.


File: inform,  Node: Answer 16,  Next: Answer 17,  Prev: Answer 15,  Up: Answers

Answer to Exercise 16: pushing pumice ball uphill
=================================================

   Insert these lines into the before rule for PushDir:

               if (second==u_obj) <<PushDir self n_obj>>;
               if (second==d_obj) <<PushDir self s_obj>>;

   *Note Exercise 16: Things to Enter.


File: inform,  Node: Answer 17,  Next: Answer 18,  Prev: Answer 16,  Up: Answers

Answer to Exercise 17: Tyndale's Bible
======================================

Object -> bible "black Tyndale Bible"
  with name "bible" "black" "book",
       initial "A black Bible rests on a spread-eagle lectern.",
       description "A splendid foot-high Bible, which must have survived
           the burnings of 1520.",
       before
       [ w x; Consult:
               wn = consult_from; w = NextWord();
               switch(w)
               {   'matthew': x="Gospel of St Matthew";
                   'mark': x="Gospel of St Mark";
                   'luke': x="Gospel of St Luke";
                   'john': x="Gospel of St John";
                   default: "There are only the four Gospels.";
               }
               if (consult_words==1)
                   "You read the ", (string) x, " right through.";
               w = TryNumber(wn);
               if (w==-1000)
                   "I was expecting a chapter number in the ",
                             (string) x, ".";
               "Chapter ", (number) w, " of the ", (string) x,
                     " is too sacred for you to understand now.";
       ];

   *Note Exercise 17: Reading Matter.


File: inform,  Node: Answer 18,  Next: Answer 19,  Prev: Answer 17,  Up: Answers

Answer to Exercise 18: bearded psychiatrist
===========================================

   Note that whether reacting before or after, the psychiatrist does
not cut any actions short, because react_before and react_after both
return false.

Object -> psychiatrist "bearded psychiatrist"
  with name "bearded" "doctor" "psychiatrist" "psychologist" "shrink",
       initial "A bearded psychiatrist has you under observation.",
       life
       [;  "He is fascinated by your behaviour, but makes no attempt to
            interfere with it.";
       ],
       react_after
       [;  Insert: print "~Subject puts ", (name) noun, " in ",
                       (name) second, ". Interesting.~^^";
           Look: print "~Pretend I'm not here,~ says the psychiatrist.^";
       ],
       react_before
       [;  Take, Remove: print "~Subject feels lack of ", (the) noun,
               ". Suppressed Oedipal complex? Mmm.~^";
       ],
  has  animate;

   *Note Exercise 18: Living Creatures.


File: inform,  Node: Answer 19,  Next: Answer 20,  Prev: Answer 18,  Up: Answers

Answer to Exercise 19: removing conversation actions
====================================================

   Add the following lines, after the inclusion of Grammar:

[ SayInsteadSub; "[To talk to someone, please type ~someone, something~
or else ~ask someone about something~.]"; ];
Extend "answer" replace * topic -> SayInstead;
Extend "tell"   replace * topic -> SayInstead;

A slight snag is that this will throw out "nigel, tell me about the
grunfeld defence" (which the library will normally convert to an Ask
action, but can't if the grammar for "tell" is missing).  To avoid
this, you could (instead of making the above directives) Replace the
TellSub routine (*note Extending the Library::.) by the SayInsteadSub
one.

   *Note Exercise 19: Living Creatures.


File: inform,  Node: Answer 20,  Next: Answer 21,  Prev: Answer 19,  Up: Answers

Answer to Exercise 20: computer (voice-activated)
=================================================

   There are several ways to do this.  The easiest is to add more
grammar to the parser and let it do the hard work:

Object -> computer "computer"
  with name "computer",
       orders
       [;  Theta: print_ret "~Theta now set to ", noun, ".~";
           default: print_ret "~Please rephrase.~";
       ],
  has  talkable;
...
[ ThetaSub; "You must tell your computer so."; ];
Verb "theta" * "is" number -> Theta;

   *Note Exercise 20: Living Creatures.


File: inform,  Node: Answer 21,  Next: Answer 22,  Prev: Answer 20,  Up: Answers

Answer to Exercise 21: Charlotte playing Simon Says
===================================================

   Obviously, a slightly wider repertoire of actions might be a good
idea, but:

Object -> Charlotte "Charlotte"
  with name "charlotte" "charlie" "chas",
       grammar
       [;  give self ~general;
           wn=verb_wordnum;
           if (NextWord()=='simon' && NextWord()=='says')
           {   give self general;
               verb_wordnum=verb_wordnum+2;
           }
       ],
       orders
       [ i;  if (self hasnt general) "Charlotte sticks her tongue out.";
           WaveHands: "Charlotte waves energetically.";
           default: "~Don't know how,~ says Charlotte.";
       ],
       initial "Charlotte wants to play Simon Says.",
  has  animate female proper;

(The variable i isn't needed yet, but will be used by the code added in
the answer to the next exercise.)

   *Note Exercise 21: Living Creatures.


File: inform,  Node: Answer 22,  Next: Answer 23,  Prev: Answer 21,  Up: Answers

Answer to Exercise 22: Charlotte's clapping game
================================================

   First add a Clap verb (this is easy).  Then give Charlotte a number
property (initially 0, say) and add these three lines to the end of
Charlotte's grammar routine:

           self.number=TryNumber(verb_wordnum);
           if (self.number~=-1000)
           {    action=##Clap; noun=0; second=0; rtrue; }

Her orders routine now needs a local variable called i, and the new
clause:

           Clap: if (self.number==0) "Charlotte folds her arms.";
                 for (i=0:i<self.number:i++)
                 {   print "Clap! ";
                     if (i==100)
                         print "(You must be regretting this by now.) ";
                     if (i==200)
                         print "(What a determined girl she is.) ";
                 }
                 if (self.number>100)
                    "^^Charlotte is a bit out of breath now.";
                "^^~Easy!~ says Charlotte.";

   *Note Exercise 22: Living Creatures.


File: inform,  Node: Answer 23,  Next: Answer 24,  Prev: Answer 22,  Up: Answers

Answer to Exercise 23: Dyslexic Dan
===================================

   The interesting point here is that when the grammar property finds
the word "take", it accepts it and has to move verb_wordnum on by one
to signal that a word has been parsed succesfully.

Object -> Dan "Dyslexic Dan"
  with name "dan" "dyslexic",
       grammar
       [;  if (verb_word == 'take') { verb_wordnum++; return 'drop'; }
           if (verb_word == 'drop') { verb_wordnum++; return 'take'; }
       ],
       orders
       [ i;
           Take: "~What,~ says Dan, ~ you want me to take ",
                     (the) noun, "?~";
           Drop: "~What,~ says Dan, ~ you want me to drop ",
                     (the) noun, "?~";
           Inv: "~That I can do,~ says Dan. ~I'm empty-handed.~";
           No: "~Right you be then.~";
           Yes: "~I'll be having to think about that.~";
           default: "~Don't know how,~ says Dan.";
       ],
       initial "Dyslexic Dan is here.",
  has  animate proper;

   *Note Exercise 23: Living Creatures.


File: inform,  Node: Answer 24,  Next: Answer 25,  Prev: Answer 23,  Up: Answers

Answer to Exercise 24: extensions for one actor only
====================================================

   Suppose Dan's grammar (but nobody else's) for the "examine" verb is
to be extended.  His grammar routine should also contain:

           if (verb_word == 'examine' or 'x')
           {   verb_wordnum++; return -'danx,'; }

(Note the crudity of this: it looks at the actual verb word, so you
have to check any synonyms yourself.)  The verb "danx," must be
declared later:

Verb "danx," * "conscience" -> Inv;

and now "Dan, examine conscience" will send him an Inv order: but "Dan,
examine cow pie" will still send Examine cow_pie as usual.

   *Note Exercise 24: Living Creatures.


File: inform,  Node: Answer 25,  Next: Answer 26,  Prev: Answer 24,  Up: Answers

Answer to Exercise 25: alarm clock
==================================

[ PrintTime x; print (x/60), ":", (x%60)/10, (x%60)%10; ];
Object -> alarm_clock "alarm clock"
  with name "alarm" "clock",
       number 480,
       description
       [;  print "The alarm is ";
           if (self has general) print "on, "; else print "off, but ";
           "the clock reads ", (PrintTime) the_time,
           " and the alarm is set for ", (PrintTime) self.number, ".";
       ],
       react_after
       [;  Inv:  if (self in player)   { new_line; <<Examine self>>; }
           Look: if (self in location) { new_line; <<Examine self>>; }
       ],
       daemon
       [;  if (the_time >= self.number && the_time <= self.number+3
               && self has general) "^Beep! Beep! The alarm goes off.";
       ],
       grammar [; return 'alarm,'; ],
       orders
       [;  SwitchOn:  give self general; StartDaemon(self); "~Alarm set.~";
           SwitchOff: give self ~general; StopDaemon(self); "~Alarm off.~";
           SetTo:     self.number=noun; <<Examine self>>;
           default: "~Commands are on, off or a time of day only, pliz.~";
       ],
       life
       [;  Ask, Answer, Tell:
              "[Try ~clock, something~ to address the clock.]";
       ],
  has  talkable;

and add a new verb to the grammar:

Verb "alarm," * "on"      -> SwitchOn
              * "off"     -> SwitchOff
              * TimeOfDay -> SetTo;

(using the `TimeOfDay' token from the exercises of *note Grammar
Tokens::.).  Note that since the word "alarm," can't be matched by
anything the player types, this verb is concealed from ordinary
grammar.  The orders we produce here are not used in the ordinary way
(for instance, the action SwitchOn with no noun or second would never
ordinarily be produced by the parser) but this doesn't matter: it only
matters that the grammar and the orders property agree with each other.

   *Note Exercise 25: Living Creatures.


File: inform,  Node: Answer 26,  Next: Answer 27,  Prev: Answer 25,  Up: Answers

Answer to Exercise 26: tricorder
================================

Object -> tricorder "tricorder"
  with name "tricorder",
       grammar [; return 'tc,'; ],
       orders
       [;  Examine: if (noun==player) "~You radiate life signs.~";
               print "~", (The) noun, " radiates ";
               if (noun hasnt animate) print "no ";
              "life signs.~";
           default: "The tricorder bleeps.";
       ],
       life
       [;  Ask, Answer, Tell: "The tricorder is too simple.";
       ],
  has  talkable;
...
Verb "tc,"    * noun      -> Examine;

   *Note Exercise 26: Living Creatures.


File: inform,  Node: Answer 27,  Next: Answer 28,  Prev: Answer 26,  Up: Answers

Answer to Exercise 27: replicator
=================================

Object replicator "replicator"
  with name "replicator",
       grammar [;  return 'rc,'; ],
       orders
       [;  Give:
               if (noun in self)
                   "The replicator serves up a cup of ",
                   (name) noun, " which you drink eagerly.";
               "~That is not something I can replicate.~";
           default: "The replicator is unable to oblige.";
       ],
       life
       [;  Ask, Answer, Tell: "The replicator has no conversation skill.";
       ],
  has  talkable;
Object -> "Earl Grey tea"    with name "earl" "grey" "tea";
Object -> "Aldebaran brandy" with name "aldebaran" "brandy";
Object -> "distilled water"  with name "distilled" "water";
...
Verb "rc,"    * held      -> Give;

The point to note here is that the `held' token means `held by the
replicator' here, as the actor is the replicator, so this is a neat way
of getting a `one of the following phrases' token into the grammar.

   *Note Exercise 27: Living Creatures.


File: inform,  Node: Answer 28,  Next: Answer 29,  Prev: Answer 27,  Up: Answers

Answer to Exercise 28: communications badge
===========================================

   This is similar to the previous exercises.  One creates an attribute
called crewmember and gives it to the crew objects: the orders property
is

       orders
       [;  Examine:
               if (parent(noun)==0)
                   "~", (name) noun,
                       " is no longer aboard this demonstration game.~";
               "~", (name) noun, " is in ", (name) parent(noun), ".~";
           default: "The computer's only really good for locating the crew.";
       ],

and the grammar simply returns 'stc,' which is defined as

[ Crew i;
  switch(scope_stage)
  {  1: rfalse;
     2: objectloop (i has crewmember) PlaceInScope(i); rtrue;
  }
];
Verb "stc,"   * "where" "is" scope=Crew -> Examine;

An interesting point is that the scope routine doesn't need to do
anything at stage 3 (usually used for printing out errors) because the
normal error-message printing system is never reached.  Something like
"computer, where is Comminder Doto" causes a ##NotUnderstood order.

   *Note Exercise 28: Living Creatures.


File: inform,  Node: Answer 29,  Next: Answer 30,  Prev: Answer 28,  Up: Answers

Answer to Exercise 29: Zen flight computer
==========================================

Object Zen "Zen" Flight_Deck
  with name "zen" "flight" "computer",
       initial "Square lights flicker unpredictably across a hexagonal
                fascia on one wall, indicating that Zen is on-line.",
       grammar [;  return -'zen,'; ],
       orders
       [;  Show: "The main screen shows a starfield,
                  turning through ", noun, " degrees.";
           Go:  "~Confirmed.~  The ship turns to a new bearing.";
           SetTo: if (noun==0) "~Confirmed.~  The ship comes to a stop.";
               if (noun>12) "~Standard by ", (number) noun,
                            " exceeds design tolerances.~";
               "~Confirmed.~  The ship's engines step to
                standard by ", (number) noun, ".";
           Take: if (noun~=force_wall) "~Please clarify.~";
                "~Force wall raised.~";
           Drop: if (noun~=blasters)   "~Please clarify.~";
              "~Battle-computers on line.
                Neutron blasters cleared for firing.~";
           NotUnderstood: "~Language banks unable to decode.~";
           default: "~Information. That function is unavailable.~";
       ],
  has  talkable proper static;
Object -> force_wall "force wall"     with name "force" "wall" "shields";
Object -> blasters "neutron blasters" with name "neutron" "blasters";
...
Verb "zen,"   * "scan" number "orbital"        -> Show
              * "set" "course" "for" Planet    -> Go
              * "speed" "standard" "by" number -> SetTo
              * "raise" held                   -> Take
              * "clear" held "for" "firing"    -> Drop;

Dealing with Ask, Answer and Tell are left to the reader.

   *Note Exercise 29: Living Creatures.


File: inform,  Node: Answer 30,  Next: Answer 31,  Prev: Answer 29,  Up: Answers

Answer to Exercise 30: Picard and Maharg
========================================

[ InScope;
   if (action_to_be == ##Examine or ##Show or ##ShowR)
       PlaceInScope(noslen_maharg);
   if (scope_reason == TALKING_REASON)
       PlaceInScope(noslen_maharg);
];

Note that ShowR is a variant form of Show in which the parameters are
`the other way round': thus "show maharg the phaser" generates ShowR
maharg phaser internally, which is then converted to the more usual
Show phaser maharg.

   *Note Exercise 30: Living Creatures.


File: inform,  Node: Answer 31,  Next: Answer 32,  Prev: Answer 30,  Up: Answers

Answer to Exercise 31: Martha the telepath
==========================================

   Martha and the sealed room are defined as follows:

Object sealed_room "Sealed Room"
  with description
          "I'm in a sealed room, like a squash court without a door,
           maybe six or seven yards across",
  has  light;
Object -> ball "red ball" with name "red" "ball";
Object -> martha "Martha"
  with name "martha",
       orders
       [ r; r=parent(self);
           Give:
               if (noun notin r) "~That's beyond my telekinesis.~";
               if (noun==self) "~Teleportation's too hard for me.~";
               move noun to player;
               "~Here goes...~ and Martha's telekinetic talents
                   magically bring ", (the) noun, " to your hands.";
           Look:
               print "~", (string) r.description;
               if (children(r)==1) ".  There's nothing here but me.~";
               print ".  I can see ";
               WriteListFrom(child(r),CONCEAL_BIT+ENGLISH_BIT);
              ".~";
           default: "~Afraid I can't help you there.~";
       ],
       life
       [;  Ask: "~You're on your own this time.~";
           Tell: "Martha clucks sympathetically.";
           Answer: "~I'll be darned,~ Martha replies.";
       ],
   has animate female concealed proper;

but the really interesting part is the InScope routine to fix things up:

[ InScope actor;
   if (actor==martha) PlaceInScope(player);
   if (actor==player && scope_reason==TALKING_REASON)
       PlaceInScope(martha);
   rfalse;
];

Note that since we want two-way communication, the player has to be in
scope to Martha too: otherwise Martha won't be able to follow the
command "martha, give me the fish", because "me" will refer to
something beyond her scope.

   *Note Exercise 31: Living Creatures.


File: inform,  Node: Answer 32,  Next: Answer 33,  Prev: Answer 31,  Up: Answers

Answer to Exercise 32: troll afraid of the dark
===============================================

   Just test if HasLightSource(gift)==1.

   *Note Exercise 32: Light and Dark.


File: inform,  Node: Answer 33,  Next: Answer 34,  Prev: Answer 32,  Up: Answers

Answer to Exercise 33: pet moth escapes in the dark
===================================================

   We could solve this using a daemon, but for the sake of
demonstrating a feature of thedark we won't.  In Initialise, write
thedark.initial = GoMothGo; and add the routine:

[ GoMothGo;
   if (moth in player)
   {   remove moth;
      "As your eyes try to adjust, you feel a ticklish sensation
       and hear a tiny fluttering sound.";
   }
];

   *Note Exercise 33: Light and Dark.


File: inform,  Node: Answer 34,  Next: Answer 35,  Prev: Answer 33,  Up: Answers

Answer to Exercise 34: thief who wanders
========================================

   This is a crude implementation, for brevity (the real Zork thief has
an enormous stock of attached messages).  A life routine is omitted,
and of course this particular thief steals nothing.  See `The Thief'
for a much fuller, annotated implementation.

Object -> thief "thief"
  with name "thief" "gentleman" "mahu" "modo",
       each_turn "^The thief growls menacingly.",
       daemon
       [ i p j n k;
           if (random(3)~=1) rfalse;
           p=parent(thief);
           objectloop (i in compass)
           {   j=p.(i.door_dir);
               if (j ofclass Object && j hasnt door) n++;
           }
           if (n==0) rfalse;
           k=random(n); n=0;
           objectloop (i in compass)
           {   j=p.(i.door_dir);
               if (j ofclass Object && j hasnt door) n++;
               if (n==k)
               {   move self to j;
                   if (p==location) "^The thief stalks away!";
                   if (j==location) "^The thief stalks in!";
                   rfalse;
               }
           }
       ],
  has  animate;

(Not forgetting to StartDaemon(thief) at some point, for instance in
the game's Initialise routine.)  So the thief walks at random but never
via doors, bridges and the like (because these may be locked or have
rules attached); it's only a first approximation, and in a good game
one should occasionally see the thief do something surprising, such as
open a secret door.  As for the name, note that `The Prince of darkness
is a gentleman. Modo he's called, and Mahu' (William Shakespeare, `King
Lear' III iv).

   *Note Exercise 34: Daemons.


File: inform,  Node: Answer 35,  Next: Answer 36,  Prev: Answer 34,  Up: Answers

Answer to Exercise 35: weight--watching daemon
==============================================

   We shall use a new property called weight and decide that any object
which doesn't provide any particular weight will weigh 10 units.
Clearly, an object which contains other objects will carry their weight
too, so:

[ WeightOf obj t i;
   if (obj provides weight) t = obj.weight; else t = 10;
   objectloop (i in obj) t = t + WeightOf(i);
   return t;
];

Once every turn we shall check how much the player is carrying and
adjust a measure of the player's fatigue accordingly.  There are many
ways we could choose to calculate this: for the sake of example we'll
define two constants:

Constant CARRYING_STRENGTH = 500;
Constant HEAVINESS_THRESHOLD = 100;

Initially the player's strength will be the maximum possible, which
we'll set to 500.  Each turn the amount of weight being carried is
substracted from this, but 100 is also added on (without exceeding the
maximum value).  So if the player carries more than 100 units, then her
strength declines, but by dropping things to get the weight below 100
she can allow it to recover.  If she drops absolutely everything, her
entire strength will recuperate in at most 5 turns.  Exhaustion sets in
if her strength reaches 0, and at this point she is forced to drop
something, which gives her strength a slight boost.  Anyway, here's an
implementation of all this:

Object weight_monitor
  with players_strength,
       warning_level 5,
       activate
       [;  self.players_strength = CARRYING_STRENGTH; StartDaemon(self);
       ],
       daemon
       [ w s b bw;
            if (location ~= Weights_Room) { StopDaemon(self); return; }
            s = self.players_strength
                - WeightOf(player) + HEAVINESS_THRESHOLD;
            if (s<0) s=0; if (s>CARRYING_STRENGTH) s=CARRYING_STRENGTH;
            self.players_strength = s;
            if (s==0)
            {   bw=-1;
                objectloop(b in player)
                    if (WeightOf(b) > bw) { bw = WeightOf(b); w=b; }
                self.players_strength = self.players_strength + bw;
                print "^Exhausted with carrying so much, you decide
                    to discard ", (the) w, ": "; <<Drop w>>;
            }
            w=s/100; if (w==self.warning_level) return;
            self.warning_level = w;
            switch(w)
            {   3: "^You are feeling a little tired.";
                2: "^You possessions are weighing you down.";
                1: "^Carrying so much weight is wearing you out.";
                0: "^You're nearly exhausted enough to drop everything
                     at an inconvenient moment.";
            }
       ];

Notice that items are actually dropped with Drop actions: one of them
might be, say, a wild boar, which would bolt away into the forest when
released.  The daemon tries to drop the heaviest item.  (Obviously a
little improvement would be needed if the game contained, say, an
un-droppable but very heavy ball and chain.)  Finally, of course, at
some point the weight monitor has to be sent an activate message to get
things going.

   *Note Exercise 35: Daemons.


File: inform,  Node: Answer 36,  Next: Answer 37,  Prev: Answer 35,  Up: Answers

Answer to Exercise 36: scuttling claws
======================================

   See the next answer.

   *Note Exercise 36: Daemons.


File: inform,  Node: Answer 37,  Next: Answer 38,  Prev: Answer 36,  Up: Answers

Answer to Exercise 37
=====================

Object tiny_claws "sound of tiny claws" thedark
  with article "the",
       name "tiny" "claws" "sound" "of" "scuttling" "scuttle"
            "things" "creatures" "monsters" "insects",
       initial "Somewhere, tiny claws are scuttling.",
       before
       [;  Listen: "How intelligent they sound, for mere insects.";
           Touch, Taste: "You wouldn't want to.  Really.";
           Smell: "You can only smell your own fear.";
           Attack: "They easily evade your flailing about in the dark.";
           default: "The creatures evade you, chittering.";
       ],
       each_turn [; StartDaemon(self); ],
       number 0,
       daemon
       [;  if (location~=thedark) { self.number=0; StopDaemon(self); rtrue; }
           switch(++(self.number))
           {   1: "^The scuttling draws a little nearer, and your breathing
                    grows loud and hoarse.";
               2: "^The perspiration of terror runs off your brow.  The
                    creatures are almost here!";
               3: "^You feel a tickling at your extremities and kick outward,
                    shaking something chitinous off.  Their sound alone
                    is a menacing rasp.";
               4: deadflag=1;
                  "^Suddenly there is a tiny pain, of a hypodermic-sharp fang
                    at your calf.  Almost at once your limbs go into spasm,
                    your shoulders and knee-joints lock, your tongue swells...";
           }
       ];

   *Note Exercise 37: Daemons.


File: inform,  Node: Answer 38,  Next: Answer 39,  Prev: Answer 37,  Up: Answers

Answer to Exercise 38: midnight
===============================

   Either set a daemon to watch for the_time suddenly dropping, or put
such a watch in the game's TimePasses routine.

   *Note Exercise 38: Daemons.


File: inform,  Node: Answer 39,  Next: Answer 40,  Prev: Answer 38,  Up: Answers

Answer to Exercise 39: nightfall and daybreak
=============================================

   A minimal solution is as follows:

Constant SUNRISE  360;  ! i.e., 6 am
Constant SUNSET  1140;  ! i.e., 7 pm
Attribute outdoors;     ! Give this to external locations
Attribute lit;          ! And this to artificially lit ones
Global day_state = 2;
[ TimePasses f obj;
  if (the_time >= SUNRISE && the_time < SUNSET) f=1;
  if (day_state == f) rfalse;
  objectloop (obj)
  {   if (obj has lit) give obj light;
      if (obj has outdoors && obj hasnt lit)
      {   if (f==0) give obj ~light; else give obj light;
      }
  }
  if (day_state==2) { day_state = f; return; }
  day_state = f; if (location hasnt outdoors) return;
  if (f==1) "^The sun rises, illuminating the landscape!";
 "^As the sun sets, the landscape is plunged into darkness.";
];

In the Initialise routine, set the time (using SetTime) and then call
TimePasses to set all the light attributes accordingly.  Note that with
this system, there's no need to set light at all: that's automatic.

   *Note Exercise 39: Daemons.


File: inform,  Node: Answer 40,  Next: Answer 41,  Prev: Answer 39,  Up: Answers

Answer to Exercise 40: mid-air location
=======================================

   Because you don't know what order daemons will run in.  A `fatigue'
daemon which makes the player drop something might come after the
`mid-air' daemon has run for this turn.  Whereas each_turn happens
after daemons and timers have run their course, and can fairly assume
no further movements will take place this turn.

   *Note Exercise 40: Daemons.


File: inform,  Node: Answer 41,  Next: Answer 42,  Prev: Answer 40,  Up: Answers

Answer to Exercise 41: long time-scale game
===========================================

   It would have to provide its own code to keep track of time, and it
can do this by providing a TimePasses() routine.  Providing "time" or
even "date" verbs to tell the player would also be a good idea.

   *Note Exercise 41: Daemons.


File: inform,  Node: Answer 42,  Next: Answer 43,  Prev: Answer 41,  Up: Answers

Answer to Exercise 42: player reacting before
=============================================

   Two reasons.  Firstly, there are times when we want to be able to
trap orders to other people, which react_before does not.  Secondly,
the player's react_before rule is not necessarily the first to react.
In the case of the player's deafness, a cuckoo may have already used
react_before to sing.  But it would have been safe to use
GamePreRoutine, if a little untidy (because a rule about the player
would not be part of the player's definition, which makes for confusing
source code).  See *Note Actions and Reactions:: for the exact sequence
of events when actions are processed.

   *Note Exercise 42: Player.


File: inform,  Node: Answer 43,  Next: Answer 44,  Prev: Answer 42,  Up: Answers

Answer to Exercise 43: silencing player
=======================================

       orders
       [;  if (gasmask hasnt worn) rfalse;
           if (actor==self && action~=##Answer or ##Tell or ##Ask) rfalse;
          "Your speech is muffled into silence by the gas mask.";
       ],

   *Note Exercise 43: Player.


File: inform,  Node: Answer 44,  Next: Answer 45,  Prev: Answer 43,  Up: Answers

Answer to Exercise 44: the player's wayhel
==========================================

   The common man's `wayhel' was a lowly mouse.  Since we think much
more highly of the player:

Object hog "Warthog" Caldera
  with name "wart" "hog" "warthog", description "Muddy and grunting.",
       number 0,
       initial "A warthog snuffles and grunts about in the ash.",
       orders
       [;  Go, Look, Examine, Eat, Smell, Taste, Touch: rfalse;
           default: "Warthogs can't do anything as tricky as that!";
       ],
  has  animate proper;

and we just ChangePlayer(warthog);.  Note that the same orders routine
applies to the player-as-human typing "warthog, listen" as to the
player-as-warthog typing just "listen".

   *Note Exercise 44: Player.


File: inform,  Node: Answer 45,  Next: Answer 46,  Prev: Answer 44,  Up: Answers

Answer to Exercise 45: Giant with conscience
============================================

      orders
      [;  if (player==self)
          {   if (actor~=self)
                 "You only become tongue-tied and gabble.";
              rfalse;
          }
          Attack: "The Giant looks at you with doleful eyes.
                   ~Me not be so bad!~";
          default: "The Giant is unable to comprehend your instructions.";
      ],

   *Note Exercise 45: Player.


File: inform,  Node: Answer 46,  Next: Answer 47,  Prev: Answer 45,  Up: Answers

Answer to Exercise 46: chessboard of rooms
==========================================

   Give the "chessboard" room a short_name routine (it probably already
has one, to print names like "Chessboard d6") and make it change the
short name to "the gigantic Chessboard" if and only if action is
currently set to ##Places.

   *Note Exercise 46: Constants and Scoring.


File: inform,  Node: Answer 47,  Next: Answer 48,  Prev: Answer 46,  Up: Answers

Answer to Exercise 47: varying the prompt
=========================================

   Put the following definition between inclusion of "Parser" and
"Verblib":

     Object LibraryMessages
       with before
            [;  Prompt: if (turns==1)
                        print "What should you, the detective, do now?^>";
                    else
                        print "What next?^>";
                    rtrue;
            ];

   *Note Exercise 47: Extending the Library.


File: inform,  Node: Answer 48,  Next: Answer 49,  Prev: Answer 47,  Up: Answers

Answer to Exercise 48
=====================

   See the `Inform Translator's Manual'.  One must provide a new
grammar file (generating the same actions but from different syntax),
tables showing how pronouns, possessives and articles work in the new
language, a sheaf of translated library messages and so on.  But it can
be done.

   *Note Exercise 48: Extending the Library.


File: inform,  Node: Answer 49,  Next: Answer 50,  Prev: Answer 48,  Up: Answers

Answer to Exercise 49: printing pronouns
========================================

   Simply define the following (for accusative, nominative and
capitalised nominative pronouns, respectively):

[ PronounAcc i;
    if (i hasnt animate) print "it";
    else { if (i has female) print "her"; else print "him"; } ];
[ PronounNom i;
    if (i hasnt animate) print "it";
    else { if (i has female) print "she"; else print "he"; } ];
[ CPronounNom i;
    if (i hasnt animate) print "It";
    else { if (i has female) print "She"; else print "He"; } ];

   *Note Exercise 49: Describing Objects.


File: inform,  Node: Answer 50,  Next: Answer 51,  Prev: Answer 49,  Up: Answers

Answer to Exercise 50: ornate box (inventory inside)
====================================================

   Use the invent routine to signal to short_name and article routines
to change their usual habits:

       invent
       [;  if (inventory_stage==1) give self general;
           else give self ~general;
       ],
       short_name
       [;  if (self has general) { print "box"; rtrue; } ],
       article
       [;  if (self has general) { print "that hateful"; rtrue; }
           else print "a"; ],

   *Note Exercise 50: Describing Objects.


File: inform,  Node: Answer 51,  Next: Answer 52,  Prev: Answer 50,  Up: Answers

Answer to Exercise 51: very verbose mode
========================================

   This answer is cheating, as it needs to know about the library's
lookmode variable (set to 1 for normal, 2 for verbose or 3 for
superbrief).  Simply include:

[ TimePasses;
  if (action~=##Look && lookmode==2) <Look>;
];

   *Note Exercise 51: Describing Objects.
