<HTML><HEAD><TITLE>Section 26: How verbs are parsed</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE></SMALL>
<TR><TD><TD><P>
<TR><TD Valign="top"><A HREF="contents.html">Contents</A><BR><A HREF="section25.html">Back</A><BR><A HREF="section27.html">Forward</A><TD bgcolor="#F5DEB3"><BLOCKQUOTE><H3>26. How verbs are parsed</H3></BLOCKQUOTE><TR><TD><TD>
<P>

<BLOCKQUOTE>
<BR>Grammar, which can govern even kings.
<BR><P>...Moli&#233;re (<B>1622</B>--<B>1673</B>), <I>Les Femmes savantes</I></BLOCKQUOTE>
<P>


The parser's fundamental method is simple.  Given a stream of text like
<BLOCKQUOTE>
<TT>saint</TT> / <TT>peter</TT> / <TT>,</TT> / <TT>take</TT> / <TT>the</TT> / <TT>keys</TT> / <TT>from</TT> / <TT>paul</TT><BR>
</BLOCKQUOTE>

it first calls the entry point <TT>BeforeParsing</TT> (in case you want to
meddle with the text stream before it gets underway).  It then
works out who is being addressed, if anyone, by looking for
a comma, and trying out the text up to there as a noun (anyone <TT>animate</TT>
or anything <TT>talkable</TT> will do): in this case St Peter.  This person
is called the "actor'', since he is going to perform the action, and
is usually the player himself (thus, typing "myself, go north'' is
equivalent to typing "go north'').
The next word, in this case <TT>'take'</TT>, is the "verb word''.  An
Inform verb usually has several English verb words attached, which
are called synonyms of each other: for instance, the library
is set up with
<BLOCKQUOTE>"take" = "carry" = "hold"</BLOCKQUOTE>
all referring to the same Inform verb.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> The parser sets up global variables <TT>actor</TT> and <TT>verb_word</TT>
while working.  (In the example above, their values would
be the St Peter object and <TT>'take'</TT>, respectively.)
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> It isn't quite that simple: names of direction objects are
treated as implicit "go'' commands, so that "n'' is acceptable as
an alternative to "go north''.  There are also "again'', "oops'' and
"undo'' to grapple with.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> Also, a major feature (the <TT>grammar</TT> property for the person
being addressed) has been missed out of this description: see the latter
half of <A HREF="section16.html">Section 16</A> for details.
</SMALL>
<TR><TD><TD><P>


Teaching the parser a new synonym is easy.  Like all of the directives
in this section, the following must appear <I> after</I> the inclusion
of the library file <TT>Grammar</TT>:
<PRE>
    Verb "steal" "acquire" "grab" = "take";
</PRE>

This creates another three synonyms for "take''.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> One can also prise synonyms apart, as will appear later.
</SMALL>
<TR><TD><TD><P>


The parser is now up to word 5; i.e., it has "the keys from paul'' left
to understand.  Apart from a list of English verb-words which refer to
it, an Inform verb also has a "grammar''.  This is a list of
1 or more "lines'', each a pattern which the rest of the text might
match.  The parser tries the first, then the second and so on, and
accepts the earliest one that matches, without ever considering later
ones.
<P>

A line is itself a row of "tokens''.  Typical tokens might mean
'the name of a nearby object', 'the word <TT>from</TT>' or 'somebody's name'.
To match a line, the parser must match against each token in sequence.
For instance, the line of 3 tokens
<BLOCKQUOTE>
<I><B>&#60;a noun&#62;</B></I> <I><B>&#60;the word <TT>from</TT>&#62;</B></I> <I><B>&#60;a noun&#62;</B></I><BR>
</BLOCKQUOTE>

matches the text.  Each line has an action attached, which in this
case is <TT>Remove</TT>: so the parser has ground up the original
text into just four numbers, ending up with
<PRE>
    actor = st_peter
    action = Remove   noun = gold_keys   second = st_paul
</PRE>

What happens then is that the St Peter's <TT>orders</TT> routine (if any)
is sent the action, and may if it wishes cooperate.  If the actor
had been the player, then the action would have been processed in
the usual way.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> The action for the line which is currently being worked through
is stored in the variable <TT>action_to_be</TT>; or, at earlier stages when the
verb hasn't been deciphered yet, it holds the value <TT>NULL</TT>.
</SMALL>
<TR><TD><TD><P>

<P>
The <TT>Verb</TT> directive creates Inform verbs, giving them some English verb
words and a grammar.  The library's <TT>Grammar</TT> file consists almost
exclusively of <TT>Verb</TT> directives: here is an example simplified from one
of them.
<PRE>
Verb "take" "get" "carry" "hold"
                * "out"                          -&#62; Exit
                * multi                          -&#62; Take
                * multiinside "from" noun        -&#62; Remove
                * "in" noun                      -&#62; Enter
                * multiinside "off" noun         -&#62; Remove
                * "off" held                     -&#62; Disrobe
                * "inventory"                    -&#62; Inv;
</PRE>

(You can look at the grammar being used in a game with the
debugging verb "showverb'': see <A HREF="section30.html">Section 30</A> for details.)
Each line of grammar begins with a <TT>*</TT>, gives a list of tokens as far
as <TT>-&#62;</TT> and then the action which the line produces.  The first line
can only be matched by something like "get out'', the second might
be matched by
<BLOCKQUOTE>
take the banana<BR>
get all the fruit except the apple<BR>
</BLOCKQUOTE>

and so on.  A full list of tokens will be given later: briefly,
<TABLE Border><TR><TD><TT>"out"</TT></TABLE> means the literal word "out'', <TABLE Border><TR><TD><TT>multi</TT></TABLE> means
one or more objects nearby, <TABLE Border><TR><TD><TT>noun</TT></TABLE> means just one and
<TABLE Border><TR><TD><TT>multiinside</TT></TABLE> means one or more objects inside the second
noun.  In this book, grammar tokens are written in the style
<TABLE Border><TR><TD><TT>noun</TT></TABLE> to prevent confusion (as there is also a variable
called <TT>noun</TT>).
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Since this book was first written, the library has been
improved so that "take'' and "get'' each have their own
independent grammars.  But for the sake of example,
suppose they share the grammar written out above.
Sometimes this has odd results: "get in bed" is correctly
understood as a request to enter the bed, "take in washing" is misunderstood
as a request to enter the washing.  You might avoid this by using <TT>Extend only</TT>
to separate them into different grammars, or you could fix the <TT>Enter</TT>
action to see if the variable <TT>verb_word=='take'</TT> or <TT>'get'</TT>.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL>  Some verbs are <TT>meta</TT> - they are not really part of the game:
for example, "save'', "score'' and "quit''.  These are declared using
<TT>Verb meta</TT>, as in
<PRE>
Verb meta "score"
                *                                -&#62; Score;
</PRE>
ninepoint
and any debugging verbs you create would probably work better this way,
since meta-verbs are protected from interference by the game and take
up no game time.</SMALL><TR><TD><TD>
</SMALL>
<TR><TD><TD><P>


After the <TT>-&#62;</TT> in each line is the name of an action.  Giving a name
in this way is what creates an action, and if you give the name of one
which doesn't already exist then you must also write a routine
to execute the action, even if it's one which doesn't do very much.
The name of the routine is always the name of the action with <TT>Sub</TT>
appended.  For instance:
<PRE>
[ XyzzySub; "Nothing happens."; ];
Verb "xyzzy"    *                                -&#62; Xyzzy;
</PRE>

will make a new magic-word verb "xyzzy'', which always says "Nothing
happens'' -- always, that is, unless some <TT>before</TT> rule gets there first,
as it might do in certain magic places.
<TT>Xyzzy</TT> is now an action just as good as all the standard ones:
<TT>##Xyzzy</TT> gives its action number, and you can write <TT>before</TT>
and <TT>after</TT> rules for it in <TT>Xyzzy:</TT> fields just as you would for, say,
<TT>Take</TT>.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL>
Finally, the line can end with the word <TT>reverse</TT>.
This is only useful if there are objects and numbers
in the line which occur in the wrong order.  An example from the
library's grammar:
<PRE>
Verb "show" "present" "display"
                * creature held                  -&#62; Show reverse
                * held "to" creature             -&#62; Show;
</PRE>

The point is that the <TT>Show</TT> action expects the first
parameter to be an item, and the second to be a person.
When the text "show him the shield'' is typed in, the
parser must reverse the two parameters "him'' and
"the shield'' before causing a <TT>Show</TT> action.  On the other
hand, in "show the shield to him'' the parameters are in
the right order already.
</SMALL>
<TR><TD><TD><P>

<P>
The library defines grammars for the 100 or so English verbs most
often used by adventure games.  However, in practice you very often
need to alter these, usually to add extra lines of grammar but
sometimes to remove existing ones.  For example, consider an
array of 676 labelled buttons, any of which could be pushed:
it's hardly convenient to define 676 button objects.  It would be
more sensible to create a grammar line which understands things like
<BLOCKQUOTE>
"button j16",<SAMP>      </SAMP> "d11",<SAMP>      </SAMP> "a5 button"
</BLOCKQUOTE>

(it's easy enough to write code for a token to do this), and then
to add it to the grammar for the "press'' verb.
The <TT>Extend</TT> directive is provided for exactly this purpose:
<PRE>
Extend "push"   * Button                    -&#62; PushButton;   
</PRE>

The point of <TT>Extend</TT> is that it is against the spirit of the Library to
alter the standard library files -- including the grammar table -- unless
absolutely necessary.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Another method would be to create a single button object
with a <TT>parse_name</TT> routine which carefully remembers what it was last
called, so that the object always knows which button it represents.
See 'Balances' for an example.
</SMALL>
<TR><TD><TD><P>


Normally, extra lines of grammar are added at the bottom of those already
there.  This may not be what you want.  For instance, "take" has a grammar
line
<PRE>
                * multi                     -&#62; Take
</PRE>

quite early on.  So if you want to add a grammar line which diverts
"take something-edible" to a different action, like so:
<PRE>
                * edible                    -&#62; Eat
</PRE>

(<TABLE Border><TR><TD><TT>edible</TT></TABLE> being a token matching anything which has the
attribute <TT>edible</TT>) then it's no good
adding this at the bottom of the <TT>Take</TT> grammar, because
the earlier line will always be matched first.  Thus, you really want
to insert your line at the top, not the bottom, in this case.  The right
command is
<PRE>
Extend "take" first
                * edible                    -&#62; Eat;
</PRE>

You might even want to over-ride the old grammar completely, not
just add a line or two.  For this, use
<PRE>
Extend "push" replace
                * Button                    -&#62; PushButton;
</PRE>

and now "push" can be used only in this way.  To sum up, <TT>Extend</TT> can take
three keywords:

<BR><TABLE Border><TR><TD> <TT>replace</TT> <TD> completely replace the old grammar with this one;
<TR><TD> <TT>first</TT>   <TD> insert the new grammar at the top of the old one;
<TR><TD> <TT>last</TT>    <TD> insert the new grammar at the bottom of the old one;
</TABLE>
<P>
with <TT>last</TT> being the default (which doesn't need to be said explicitly).
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> In library grammar, some verbs have many synonyms: for instance,
<PRE>
"attack" "break" "smash" "hit" "fight" "wreck" "crack"
"destroy" "murder" "kill" "torture" "punch" "thump"
</PRE>

are all treated as identical.  But you might want to distinguish between
murder and lesser crimes.  For this, try
<PRE>
Extend only "murder" "kill" replace * animate -&#62; Murder;
</PRE>

The keyword <TT>only</TT> tells Inform to extract the two verbs "murder" and
"kill".  These then become a new verb which is initially an identical copy
of the old one, but then <TT>replace</TT> tells Inform to throw that away in favour
of an entirely new grammar.  Similarly,
<PRE>
Extend only "get" * "with" "it" -&#62; Sing;
</PRE>

makes "get" behave exactly like "take" (as usual) except that it also
recognises "with it", so that "get with it" makes the player sing but
"take with it" doesn't.  Other good pairs to separate might be "cross''
and "enter'', "drop'' and "throw'', "give'' and "feed'', "swim''
and "dive'', "kiss'' and "hug'', "cut'' and
"prune''.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Bear in mind that once a pair has been split apart like this, any
subsequent extension made to one will not be made to the other.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> There are (a few) times when verb definition commands are not
enough.  For example, in the original 'Advent' (or 'Colossal Cave'),
the player could type the name of a not-too-distant place which had
previously been visited, and be taken there.  There are several ways to code
this -- say, with 60 rather similar verb definitions, or with a single
"travel" verb which has 60 synonyms, whose action routine looks at the
parser's <TT>verb_word</TT> variable to see which one was typed, or even by restocking
the compass object with new directions in each room -- but here's
another.  The library will call the <TT>UnknownVerb</TT> routine (if you provide one)
when the parser can't even get past the first word.  This has two options:
it can return false, in which case the parser just goes on to complain as it
would have done anyway.  Otherwise, it can return a verb word which is
substituted for what the player actually typed.  Here is a foolish example:
<PRE>
[ UnknownVerb w;
  if (w=='shazam') { print "Shazam!^"; return 'inventory'; }
  rfalse;
];
</PRE>

which responds to the magic word "shazam" by printing <TT>Shazam!</TT> and then,
rather disappointingly, taking the player's inventory.  But in the example
above, it could be used to look for the word <TT>w</TT> through the locations of
the game, store the place away in some global variable, and then return <TT>'go'</TT>.
The <TT>GoSub</TT> routine could then be fixed to look at this variable.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex65"><B>EXERCISE 65:</B><BR>(link to <A HREF="answers2/answer65.html">the answer</A>)<TR><TD><TD>  Why is it usually a bad idea to print text out in an
<TT>UnknownVerb</TT> routine?
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> If you allow a flexible collection of verbs (say, names of
spells or places) then you may want a single 'dummy' verb to stand for
whichever is being typed.  This may make the parser produce strange
questions because it is unable to sensibly print the verb back at the
player, but you can fix this using the <TT>PrintVerb</TT> entry
point.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex66"><B>EXERCISE 66:</B><BR>(link to <A HREF="answers2/answer66.html">the answer</A>)<TR><TD><TD>  Implement the Crowther and Woods feature
of moving from one room to another by typing its name, using a
dummy verb.

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dexercise.gif" ALT="??/\"><TD bgcolor="#FBB9AC"><A NAME="ex67"><B>EXERCISE 67:</B><BR>(link to <A HREF="answers2/answer67.html">the answer</A>)<TR><TD><TD>  Implement a lamp which, when rubbed, produces a
genie who casts a spell over the player to make him confuse the
words "white'' and "black''.

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/refs.gif" ALT="*"><TD bgcolor="#EEEEEE"><B>REFERENCES:</B><BR><SMALL>  'Advent' makes a string of simple <TT>Verb</TT> definitions;
'Alice Through The Looking-Glass' uses <TT>Extend</TT> a little.
<BR> 'Balances' has a large extra grammar and also
uses the <TT>UnknownVerb</TT> and <TT>PrintVerb</TT> entry points.
</TABLE>
<HR><A HREF="contents.html">Contents</A> / <A HREF="section25.html">Back</A> / <A HREF="section27.html">Forward</A> <BR>
<A HREF="chapter1.html">Chapter I</A> / <A HREF="chapter2.html">Chapter II</A> / <A HREF="chapter3.html">Chapter III</A> / <A HREF="chapter4.html">Chapter IV</A> / <A HREF="chapter5.html">Chapter V</A> / <A HREF="chapter6.html">Chapter VI</A> / <A HREF="chapterA.html">Appendix</A><HR><SMALL><I>Mechanically translated to HTML from third edition as revised 16 May 1997. Copyright &#169; Graham Nelson 1993, 1994, 1995, 1996, 1997: all rights reserved.</I></SMALL></BODY></HTML>
