This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Answer 52,  Next: Answer 53,  Prev: Answer 51,  Up: Answers

Answer to Exercise 52: double inventory
=======================================

[ DoubleInvSub i count1 count2;
  print "You are carrying ";
  objectloop (i in player)
  {   if (i hasnt worn) { give i workflag; count1++; }
      else { give i ~workflag; count2++; }
  }
  if (count1==0) print "nothing.";
  else
  WriteListFrom(child(player),
      FULLINV_BIT + ENGLISH_BIT + RECURSE_BIT + WORKFLAG_BIT);

  if (count2==0) ".";
  print ".  In addition, you are wearing ";
  objectloop (i in player)
  {   if (i hasnt worn) give i ~workflag; else give i workflag;
  }
  WriteListFrom(child(player),
      ENGLISH_BIT + RECURSE_BIT + WORKFLAG_BIT);
  ".";
];

   *Note Exercise 52: Listing Objects.


File: inform,  Node: Answer 53,  Next: Answer 54,  Prev: Answer 52,  Up: Answers

Answer to Exercise 53: Scrabble pieces
======================================

Class Letter
  with list_together
       [; if (inventory_stage==1)
          { print "the letters ";
            if (~~(c_style & ENGLISH_BIT))   c_style = c_style + ENGLISH_BIT;
            if (~~(c_style & NOARTICLE_BIT)) c_style = c_style + NOARTICLE_BIT;
            if (c_style & NEWLINE_BIT)       c_style = c_style - NEWLINE_BIT;
            if (c_style & INDENT_BIT)        c_style = c_style - INDENT_BIT;
          }
          else print " from a Scrabble set";
       ],
       short_name
       [;  if (listing_together ofclass Letter) rfalse;
           print "letter ", (object) self, " from a Scrabble set"; rtrue;
       ],
       article "the";

and then as many letters as desired, along the lines of

Letter -> "X" with name "x";

   *Note Exercise 53: Listing Objects.


File: inform,  Node: Answer 54,  Next: Answer 55,  Prev: Answer 53,  Up: Answers

Answer to Exercise 54: three denominations of coin
==================================================

Class  Coin
  with name "coin" "coins//p",
       description "A round unstamped disc, presumably local currency.",
       list_together "coins",
       plural
       [;  print (string) (self.&name)-->0;
           if (~~(listing_together ofclass Coin)) print " coins";
       ],
       short_name
       [;  if (listing_together ofclass Coin)
           {   print (string) (self.&name)-->0; rtrue; }
       ],
       article
       [;  if (listing_together ofclass Coin) print "one"; else print "a";
       ];
Class  Gold_coin   class Coin with name "gold";
Class  Silver_coin class Coin with name "silver";
Class  Bronze_coin class Coin with name "bronze";
SilverCoin -> "silver coin";
... and so on

   *Note Exercise 54: Listing Objects.


File: inform,  Node: Answer 55,  Next: Answer 56,  Prev: Answer 54,  Up: Answers

Answer to Exercise 55: I Ching coins
====================================

   Firstly, a printing rule to print the state of coins.  Coin-objects
will have a property called way_up which is always either 1 or 2:

[ Face x; if (x.way_up==1) print "Heads"; else print "Tails"; ];

There are two kinds of coin but we'll implement them with three
classes: Coin and two sub-categories, GoldCoin and SilverCoin.  Since
the coins only join up into trigrams when present in groups of three,
we need a routine to detect this:

[ CoinsTogether cla i x y;
  objectloop (i ofclass cla)
  {   x=parent(i);
      if (y==0) y=x; else { if (x~=y) return 0; }
  }
  return y;
];

Thus CoinsTogether(cla) decides whether all objects of class cla are in
the same place.  (cla will always be either GoldCoin or SilverCoin.)
We must now write the class definitions:

Class  Coin
  with name "coin" "coins//p",
       way_up 1, article "the",
       after
       [; Drop, PutOn:
             self.way_up = random(2); print (Face) self;
             if (CoinsTogether(self.which_class))
             {   print ". The ";
                 if (self.which_class == GoldCoin)
                     print "gold"; else print "silver";
                 " trigram is now ", (Trigram) self.which_class;
             }
             ".";
       ];
[ CoinLT k i c;
  if (inventory_stage==1)
  {   if (self.which_class == GoldCoin)
          print "the gold"; else print "the silver";
      print " coins ";
      k=CoinsTogether(self.which_class);
      if (k==location || k has supporter)
      {   objectloop (i ofclass self.which_class)
          {   print (name) i;
              switch(++c)
              {  1: print ", "; 2: print " and ";
                 3: print " (showing the trigram ",
                    (Trigram) self.which_class, ")";
              }
          }
          rtrue;
      }
      if (~~(c_style & ENGLISH_BIT))   c_style = c_style + ENGLISH_BIT;
      if (~~(c_style & NOARTICLE_BIT)) c_style = c_style + NOARTICLE_BIT;
      if (c_style & NEWLINE_BIT)       c_style = c_style - NEWLINE_BIT;
      if (c_style & INDENT_BIT)        c_style = c_style - INDENT_BIT;
  }
  rfalse;
];
Class  GoldCoin class Coin
  with name "gold", which_class GoldCoin,
       list_together [; return CoinLT(); ];
Class  SilverCoin class Coin
  with name "silver", which_class SilverCoin,
       list_together [; return CoinLT(); ];

(There are two unusual points here.  Firstly, the CoinsLT routine is
not simply given as the common list_together value in the coin class
since, if it were, all six coins would be grouped together: we want two
groups of three, so the gold and silver coins have to have different
list_together values.  Secondly, if a trigram is together and on the
floor, it is not good enough to simply append text like "showing Tails,
Heads, Heads (change)" at inventory_stage 2 since the coins may be
listed in a funny order: for example, in the order snake, robin, bison.
In that event, the order the coins are listed in doesn't correspond to
the order their values are listed in, which is misleading.  So instead
CoinsLT takes over entirely at inventory_stage 1 and prints out the
list of three itself, returning true to stop the list from being
printed out by the library as well.) To resume: whenever coins are
listed together, they are grouped into gold and silver.  Whenever
trigrams are visible they are to be described by either
Trigram(GoldClass) or Trigram(SilverClass):

Array gold_trigrams -->   "fortune" "change" "river flowing" "chance"
                          "immutability" "six stones in a circle"
                          "grace" "divine assistance";
Array silver_trigrams --> "happiness" "sadness" "ambition" "grief"
                          "glory" "charm" "sweetness of nature"
                          "the countenance of the Hooded Man";
[ Trigram cla i k state;
  objectloop (i ofclass cla)
  {   print (Face) i; if (k++<2) print ","; print " ";
      state=state*2 + (i.way_up-1);
  }
  if (cla == GoldCoin) i=gold_trigrams; else i=silver_trigrams;
  print "(", (string) i-->state, ")";
];

(These interpretations of the coins are quite bogus.)  Finally, we have
to make the six actual coins:

GoldCoin ->   "goat"    with name "goat";
GoldCoin ->   "deer"    with name "deer";
GoldCoin ->   "chicken" with name "chicken";
SilverCoin -> "robin"   with name "robin";
SilverCoin -> "snake"   with name "snake";
SilverCoin -> "bison"   with name "bison";

   *Note Exercise 55: Listing Objects.


File: inform,  Node: Answer 56,  Next: Answer 57,  Prev: Answer 55,  Up: Answers

Answer to Exercise 56: tomato in red or green
=============================================

parse_name
[ i j w; if (self has general) j='red'; else j='green';
         w=NextWord();
         while (w==j or 'fried')
         {   w=NextWord(); i++;
         }
         if (w=='tomato') return i+1;
         return 0;
],

   *Note Exercise 56: Parsing Nouns.


File: inform,  Node: Answer 57,  Next: Answer 58,  Prev: Answer 56,  Up: Answers

Answer to Exercise 57: the artiste formerly known as Princess
=============================================================

Object -> "/?%?/ (the artiste formerly known as Princess)"
  with name "princess" "artiste" "formerly" "known" "as",
       short_name
       [;   if (self hasnt general) { print "Princess"; rtrue; }
       ],
       react_before
       [;  Listen: print_ret (name) self, " sings a soft siren song.";
       ],
       initial
       [;  print_ret (name) self, " is singing softly.";
       ],
       parse_name
       [ x n; if (self hasnt general)
            {   if (NextWord()=='princess') return 1;
                return 0;
            }
            x=WordAddress(wn);
            if (   x->0 == '/' && x->1 == '?' && x->2 == '%'
                && x->3 == '?' && x->4 == '/')
            {   while (wn<=parse->1 && WordAddress(wn++)<x+5) n++;
                return n;
            }
            return -1;
       ],
       life
       [;   Kiss: give self general; self.life = NULL;
                "In a fairy-tale transformation, the Princess
                 steps back and astonishes the world by announcing
                 that she will henceforth be known as ~/?%?/~.";
       ],
  has  animate proper female;

   *Note Exercise 57: Parsing Nouns.


File: inform,  Node: Answer 58,  Next: Answer 59,  Prev: Answer 57,  Up: Answers

Answer to Exercise 58: drinks machine
=====================================

   Something to note here is that the button can't be called just
"coffee" when the player's holding a cup of coffee: this means the game
responds sensibly to the sequence "press coffee" and "drink coffee".
Also note the way itobj is set to the delivered drink, so that "drink
it" works nicely.

Object -> drinksmat "drinks machine",
  with name "drinks" "machine",
       initial
          "A drinks machine here has buttons for Cola, Coffee and Tea.",
  has  static;
Object -> thebutton "drinks machine button"
  has  scenery
 with  parse_name
       [ i flag type;
            for (: flag == 0: i++)
            {   flag = 1;
                switch(NextWord())
                {   'button', 'for': flag = 0;
                    'coffee': if (type == 0) { flag = 0; type = 1; }
                    'tea':    if (type == 0) { flag = 0; type = 2; }
                    'cola':   if (type == 0) { flag = 0; type = 3; }
                }
            }
            if (type==drink.number && i==2 && type~=0 && drink in player)
                return 0;
            self.number=type; return i-1;
        ],
        number 0,
        before
        [; Push, SwitchOn:
             if (self.number == 0)
                "You'll have to say which button to press.";
             if (parent(drink) ~= 0) "The machine's broken down.";
             drink.number = self.number; move drink to player; itobj = drink;
             print_ret "Whirr!  The machine puts ", (a) drink, " into your \
                 glad hands.";
           Attack: "The machine shudders and squirts cola at you.";
           Drink:  "You can't drink until you've worked the machine.";
        ];
Object  drink "drink"
  with  parse_name
        [ i flag type;
            for (: flag == 0: i++)
            {   flag = 1;
                switch(NextWord())
                {   'drink', 'cup', 'of': flag = 0;
                    'coffee': if (type == 0) { flag = 0; type = 1; }
                    'tea':    if (type == 0) { flag = 0; type = 2; }
                    'cola':   if (type == 0) { flag = 0; type = 3; }
                }
            }
            if (type ~= 0 && type ~= self.number) return 0;
            return i-1;
        ],
        short_name
        [;  print "cup of ";
            switch (self.number)
            { 1: print "coffee"; 2: print "tea"; 3: print "cola"; }
            rtrue;
        ],
        number 0,
        before
        [; Drink: remove self;
            "Ugh, that was awful.  You crumple the cup and responsibly \
             dispose of it.";
        ];

   *Note Exercise 58: Parsing Nouns.


File: inform,  Node: Answer 59,  Next: Answer 60,  Prev: Answer 58,  Up: Answers

Answer to Exercise 59: parsing adjectives
=========================================

   Create a new property adjective, and move names which are adjectives
to it: for instance,

    name "tomato" "vegetable", adjective 'fried' 'green' 'cooked',

(Recall that dictionary words can only be written in " quotes for the
name property.)  Then (using the same IsAWordIn routine),

[ ParseNoun obj n m;
  while (IsAWordIn(NextWord(),obj,adjective) == 1) n++; wn--;
  while (IsAWordIn(NextWord(),obj,noun) == 1) m++;
  if (m==0) return 0; return n+m;
];

   *Note Exercise 59: Parsing Nouns.


File: inform,  Node: Answer 60,  Next: Answer 61,  Prev: Answer 59,  Up: Answers

Answer to Exercise 60: referring to objects by number
=====================================================

[ ParseNoun obj;
  if (NextWord() == 'object' && TryNumber(wn) == obj) return 2;
  wn--; return -1;
];

   *Note Exercise 60: Parsing Nouns.


File: inform,  Node: Answer 61,  Next: Answer 62,  Prev: Answer 60,  Up: Answers

Answer to Exercise 61: wild-card for a single object
====================================================

[ ParseNoun;
  if (WordLength(wn)==1 && WordAddress(wn)->0 == '#') return 1;
  return -1;
];

   *Note Exercise 61: Parsing Nouns.


File: inform,  Node: Answer 62,  Next: Answer 63,  Prev: Answer 61,  Up: Answers

Answer to Exercise 62: wild-card for multiple objects
=====================================================

[ ParseNoun;
  if (WordLength(wn)==1 && WordAddress(wn)->0 == '#') return 1;
  if (WordLength(wn)==1 && WordAddress(wn)->0 == '*')
  {   parser_action = ##PluralFound; return 1; }
  return -1;
];

   *Note Exercise 62: Parsing Nouns.


File: inform,  Node: Answer 63,  Next: Answer 64,  Prev: Answer 62,  Up: Answers

Answer to Exercise 63: "fly in amber"
=====================================

   The trick is to convert "fly in amber" into "fly fly amber" (a
harmless name) before the parser gets under way.

[ BeforeParsing i j;
  for (i=parse->1,j=2:j<i:j++)
  {   wn=j-1;
      if (NextWord()=='fly' && NextWord()=='in' && NextWord()=='amber')
          parse-->(j*2-1) = 'fly';
  }
];

   *Note Exercise 63: Parsing Nouns.


File: inform,  Node: Answer 64,  Next: Answer 65,  Prev: Answer 63,  Up: Answers

Answer to Exercise 64: cherubim plural
======================================

Global c_warned = false;
Class  Cherub
  with parse_name
       [ i j flag;
         for (flag=true:flag:flag=false)
         {   j=NextWord();
             if (j=='cherub' or j==self.name) flag=true;
             if (j=='cherubs' && (~~c_warned))
             {   c_warned=true;
                 parser_action=##PluralFound; flag=true;
 print "(I'll let this go once, but the plural of cherub is cherubim.)^";
             }
             if (j=='cherubim')
             {   parser_action=##PluralFound; flag=true; }
             i++;
         }
         return i-1;
       ];

Then again, Shakespeare even wrote "cherubins" in `Twelfth Night', so
who are we to censure?

   *Note Exercise 64: Plural Names.


File: inform,  Node: Answer 65,  Next: Answer 66,  Prev: Answer 64,  Up: Answers

Answer to Exercise 65
=====================

   Because the parser might go on to reject the line it's working on:
for instance, if the player typed "shazam splurge" then the message
"Shazam!" followed by a parser complaint will be somewhat unedifying.

   *Note Exercise 65: Parsing Verbs.


File: inform,  Node: Answer 66,  Next: Answer 67,  Prev: Answer 65,  Up: Answers

Answer to Exercise 66: moving to a room by typing its name
==========================================================

   The scheme will work like this: any room that ought to have a name
should have a place_name property set to a dictionary word; say, the
Bedquilt cave could be called 'bedquilt'.  Clearly you should only be
allowed to type this from adjacent rooms.  So we'll implement the
following: you can only move by name to those rooms listed in the
current room's to_places property.  For instance, the Soft Room might
have to_places set to

to_places Bedquilt Slab_Room Twopit_Room;

Now the code: if the player's verb is not otherwise understood, we'll
check it to see if it's a place name of a nearby room, and if so store
that room's object number in goto_room, converting the verb to
'go#room' (which we'll deal with below).

Global goto_room;
[ UnknownVerb word p i;
    p = location.&to_places; if (p==0) rfalse;
    for (i=0:(2*i)<location.#to_places:i++)
        if (word==(p-->i).place_name)
        {   goto_room = p-->i; return 'go#room';
        }
    rfalse;
];
[ PrintVerb word;
    if (word=='go#room')
    {   print "go to ", (name) goto_room; rtrue; }
    rfalse;
];

(The supplied PrintVerb is icing on the cake: so the parser can say
something like "I only understood you as far as wanting to go to
Bedquilt." in reply to, say, "bedquilt the nugget".)  It remains only
to create the dummy verb:

[ GoRoomSub;
    if (goto_room hasnt visited) "But you have never been there.";
    PlayerTo(goto_room);
];
Verb "go#room"  *                                -> GoRoom;

Note that if you don't know the way, you can't go there!  A purist might
prefer instead to not recognise the name of an unvisited room, back at
the UnknownVerb stage, to avoid the player being able to deduce names
of nearby rooms from this `error message'.

   *Note Exercise 66: Parsing Verbs.


File: inform,  Node: Answer 67,  Next: Answer 68,  Prev: Answer 66,  Up: Answers

Answer to Exercise 67: genie muddling black and white
=====================================================

Object -> genies_lamp "brass lamp"
  with name "brass" "lamp",
       before
       [; Rub: if (self hasnt general) give self general;
               else give self ~general;
              "A genie appears from the lamp, declaring:^^
               ~Mischief is my sole delight:^
               If white means black, black means white!~^^
               She vanishes away with a vulgar wink.";
       ];
Object -> white_stone "white stone" with name "white" "stone";
Object -> black_stone "black stone" with name "black" "stone";
...
[ BeforeParsing;
   if (genies_lamp hasnt general) return;
   for (wn=1::)
   {   switch(NextWordStopped())
       {   'white': parse->(wn*2-3) = 'black';
           'black': parse->(wn*2-3) = 'white';
           -1: return;
       }
   }
];

   *Note Exercise 67: Parsing Verbs.


File: inform,  Node: Answer 68,  Next: Answer 69,  Prev: Answer 67,  Up: Answers

Answer to Exercise 68: footnotes
================================

Constant MAX_FOOTNOTES 10;
Array footnotes_seen -> MAX_FOOTNOTES;
Global footnote_count;
[ Note n i pn;
    for (i=0:i<footnote_count:i++)
        if (n==footnotes_seen->i) pn=i;
    if (footnote_count==MAX_FOOTNOTES) "** MAX_FOOTNOTES exceeded! **";
    if (pn==0) { pn=footnote_count++; footnotes_seen->pn=n; }
    print " [",pn+1,"]";
];
[ FootnoteSub n;
    if (noun>footnote_count)
        "No footnote [", noun, "] has been mentioned.";
    if (noun==0) "Footnotes count upward from 1.";
    n=footnotes_seen->(noun-1);
    print "[",noun,"]  ";
    switch(n)
    {   0: "This is a footnote.";
        1: "D.G.REG.F.D is inscribed around English coins.";
        2: "~Jackdaws love my big sphinx of quartz~, for example.";
    }
];
Verb "footnote" "note" * number              -> Footnote;

And then you can code, for instance,

    print "Her claim to the throne is in every pocket ", (Note) 1,
       ", her portrait in every wallet.";

   *Note Exercise 68: Grammar Tokens.


File: inform,  Node: Answer 69,  Next: Answer 70,  Prev: Answer 68,  Up: Answers

Answer to Exercise 69: low numbers in French
============================================

   The general parsing routine needed is:

[ FrenchNumber n;
    switch(NextWord())
    {   'un', 'une': n=1;
        'deux': n=2;
        'trois': n=3;
        'quatre': n=4;
        'cinq': n=5;
        default: return -1;
    }
    parsed_number = n; return 1;
];

   *Note Exercise 69: Grammar Tokens.


File: inform,  Node: Answer 70,  Next: Answer 71,  Prev: Answer 69,  Up: Answers

Answer to Exercise 70: floating-point numbers
=============================================

   First we must decide how to store floating-point numbers internally:
in this case we'll simply store 100x to represent x, so that "5.46"
will be parsed as 546.

[ DigitNumber n type x;
  x = NextWordStopped(); if (x==-1) return -1; wn--;
  if (type==0)
  {   x = WordAddress(wn);
      if (x->n>='0' && x->n<='9') return (x->n) - '0';
      return -1;
  }
  if (x=='nought' or 'oh') { wn++; return 0; }
  x = TryNumber(wn++); if (x==-1000 || x>=10) x=-1; return x;
];
[ FloatingPoint a x b w d1 d2 d3 type;
  a = TryNumber(wn++);
  if (a==-1000) return -1;
  w = NextWordStopped(wn); if (w==-1) return a*100;
  x = NextWordStopped(wn); if (x==-1) return -1; wn--;
  if (w=='point') type=1;
  else
  {   if (WordAddress(wn-1)->0~='.' || WordLength(wn-1)~=1)
          return -1;
  }
  d1 = DigitNumber(0,type);
  if (d1==-1) return -1;
  d2 = DigitNumber(1,type); d3 = DigitNumber(2,type);
  b=d1*10; if (d2>=0) b=b+d2; else d3=0;
  if (type==1)
  {   x=1; while (DigitNumber(x,type)>=0) x++; wn--;
  }
  else wn++;
  parsed_number = a*100 + b;
  if (d3>=5) parsed_number++;
  return 1;
];

   *Note Exercise 70: Grammar Tokens.


File: inform,  Node: Answer 71,  Next: Answer 72,  Prev: Answer 70,  Up: Answers

Answer to Exercise 71: phone numbers
====================================

   Again, the first question is how to store the number dialled: in
this case, into a string array.  The token is:

Constant MAX_PHONE_LENGTH = 30;
Array dialled_number string MAX_PHONE_LENGTH;
[ PhoneNumber f a l ch pp i;
  pp=1; if (NextWordStopped()==-1) return 0;
  do
  {   a=WordAddress(wn-1); l=WordLength(wn-1);
      for (i=0:i<l:i++)
      {   ch=a->i;
          if (ch<'0' || ch>'9')
          {   if (ch~='-') { f=1; if (i~=0) return -1; } }
          else
          {   if (pp<MAX_PHONE_LENGTH)
                  dialled_number->(pp++)=ch-'0';
          }
      }
  } until (f==1 || NextWordStopped()==-1);
  if (pp==1) return -1;
  dialled_number->0 = pp-1;
  return 0;
];

To demonstrate this in use,

[ DialPhoneSub i;
  print "You dialled <";
  for (i=1:i<=dialled_number->0:i++) print dialled_number->i;
  ">";
];
Verb "dial"  * PhoneNumber -> DialPhone;

   *Note Exercise 71: Grammar Tokens.


File: inform,  Node: Answer 72,  Next: Answer 73,  Prev: Answer 71,  Up: Answers

Answer to Exercise 72: parsing times of day
===========================================

   The time of day will be returned as a number in the usual Inform
time format: as hours times 60 plus minutes (on the 24-hour clock, so
that the `hour' part is between 0 and 23).

Constant TWELVE_HOURS = 720;
[ NumericTime hr mn word x;
  if (hr>=24) return -1;
  if (mn>=60) return -1;
  x=hr*60+mn; if (hr>=13) return x;
  x=x%TWELVE_HOURS; if (word=='pm') x=x+TWELVE_HOURS;
  if (word~='am' or 'pm' && hr==12) x=x+TWELVE_HOURS;
  return x;
];
[ MyTryNumber wordnum i j;
  i=wn; wn=wordnum; j=NextWordStopped(); wn=i;
  switch(j)
  {   'twenty-five': return 25;
      'thirty': return 30;
      default: return TryNumber(wordnum);
  }
];
[ TimeOfDay i j k flag loop ch hr mn;
  i=NextWord();
  switch(i)
  {  'midnight': parsed_number=0; return 1;
     'midday', 'noon': parsed_number=TWELVE_HOURS; return 1;
  }
  !   Next try the format 12:02
  j=WordAddress(wn-1); k=WordLength(wn-1);
  flag=0;
  for (loop=0:loop<k:loop++)
  {   ch=j->loop;
      if (ch==':' && flag==0 && loop~=0 && loop~=k-1) flag=1;
      else { if (ch<'0') flag=-1; if (ch>'9') flag=-1; }
  }
  if (k<3) flag=0; if (k>5) flag=0;
  if (flag==1)
  {   for (loop=0:j->loop~=':':loop++, hr=hr*10)
          hr=hr+j->loop-'0';
      hr=hr/10;
      for (loop++:loop<k:loop++, mn=mn*10)
          mn=mn+j->loop-'0';
      mn=mn/10;
      j=NextWordStopped();
      parsed_number=NumericTime(hr, mn, j);
      if (parsed_number<0) return -1;
      if (j~='pm' or 'am') wn--;
      return 1;
  }
  !   Next the format "half past 12"
  j=-1; if (i=='half') j=30; if (i=='quarter') j=15;
  if (j<0) j=MyTryNumber(wn-1); if (j<0) return -1;
  if (j>=60) return -1;
  k=NextWordStopped();
  if (k==-1)
  {   hr=j; if (hr>12) return -1; jump TimeFound; }
  if (k=='o^clock' or 'am' or 'pm')
  {   hr=j; if (hr>12) return -1; jump TimeFound; }
  if (k=='to' or 'past')
  {   mn=j; hr=MyTryNumber(wn);
      if (hr<=0)
      {   switch(NextWordStopped())
          {   'noon', 'midday': hr=12;
              'midnight': hr=0;
              default: return -1;
          }
      }
      if (hr>=13) return -1;
      if (k=='to') { mn=60-mn; hr=hr-1; if (hr==-1) hr=23; }
      wn++; k=NextWordStopped();
      jump TimeFound;
  }
  hr=j; mn=MyTryNumber(--wn);
  if (mn<0) return -1; if (mn>=60) return -1;
  wn++; k=NextWordStopped();
 .TimeFound;
  parsed_number = NumericTime(hr, mn, k);
  if (parsed_number<0) return -1;
  if (k~='pm' or 'am' or 'o^clock') wn--;
  return 1;
];

   *Note Exercise 72: Grammar Tokens.


File: inform,  Node: Answer 73,  Next: Answer 74,  Prev: Answer 72,  Up: Answers

Answer to Exercise 73: spaceship control panel
==============================================

   Here goes: we could implement the buttons with five separate
objects, essentially duplicates of each other.  (And by using a class
definition, this wouldn't look too bad.)  But if there were 500 slides
this would be less reasonable.

[ ASlide w n;
   if (location~=Machine_Room) return -1;
   w=NextWord(); if (w=='slide') w=NextWord();
   switch(w)
   {   'first', 'one': n=1;
       'second', 'two': n=2;
       'third', 'three': n=3;
       'fourth', 'four': n=4;
       'fifth', 'five': n=5;
       default: return -1;                !  Failure!
   }
   w=NextWord(); if (w~='slide') wn--;    !  (Leaving word counter at the
                                          !  first misunderstood word)
   parsed_number=n;
   return 1;                              !  Success!
];
Global slide_settings --> 5;              !  A five-word array
[ SetSlideSub;
   slide_settings-->(noun-1) = second;
   print_ret "You set slide ", (number) noun,
             " to the value ", second, ".";
];
[ XSlideSub;
   print_ret "Slide ", (number) noun, " currently stands at ",
       slide_settings-->(noun-1), ".";
];
Extend "set" first
           * ASlide "to" number                  -> SetSlide;
Extend "push" first
           * ASlide "to" number                  -> SetSlide;
Extend "examine" first
           * ASlide                              -> XSlide;

   *Note Exercise 73: Grammar Tokens.


File: inform,  Node: Answer 74,  Next: Answer 75,  Prev: Answer 73,  Up: Answers

Answer to Exercise 74: implementing parser primitives
=====================================================

   (See the Parser file.)  NextWord roughly returns parse-->(w*2-1)
(but it worries a bit about commas and full stops).

[ WordAddress w; return buffer + parse->(w*4+1); ];
[ WordLength w; return parse->(w*4); ];

   *Note Exercise 74: Grammar Tokens.


File: inform,  Node: Answer 75,  Next: Answer 76,  Prev: Answer 74,  Up: Answers

Answer to Exercise 75: parsing any quoted text
==============================================

   (Cf. the blackboard code in `Toyshop'.)

Global from_char; Global to_char;
[ QuotedText i j f;
   i = parse->((++wn)*4-3);
   if (buffer->i=='"')
   {   for (j=i+1:j<=(buffer->1)+1:j++)
           if (buffer->j=='"') f=j;
       if (f==0) return -1;
       from_char = i+1; to_char=f-1;
       if (from_char>to_char) return -1;
       while (f> (parse->(wn*4-3))) wn++; wn++;
       return 0;
   }
   return -1;
];

Note that in the case of success, the word marker wn is moved beyond the
last word accepted (since the Z-machine automatically tokenises a
double-quote as a single word).  The text is treated as though it were
a preposition, and the positions where the quoted text starts and
finishes in the raw text buffer are recorded, so that an action routine
can easily extract the text and use it later.  (Note that "" with no
text inside is not matched by this routine but only because the last if
statement throws out that one case.)

   *Note Exercise 75: Grammar Tokens.


File: inform,  Node: Answer 76,  Next: Answer 77,  Prev: Answer 75,  Up: Answers

Answer to Exercise 76: tokens which never match
===============================================

[ NeverMatch; return -1; ];

   *Note Exercise 76: Grammar Tokens.


File: inform,  Node: Answer 77,  Next: Answer 78,  Prev: Answer 76,  Up: Answers

Answer to Exercise 77
=====================

   Perhaps to arrange better error messages when the text has failed
all the `real' grammar lines of a verb (see `Encyclopaedia Frobozzica'
for an example).

   *Note Exercise 77: Grammar Tokens.


File: inform,  Node: Answer 78,  Next: Answer 79,  Prev: Answer 77,  Up: Answers

Answer to Exercise 78: third noun for parser
============================================

   (See the NounDomain specification in *Note Objects and Routines::.)
This routine passes on any REPARSE_CODE, as it must, but keeps a
matched object in its own third variable, returning the `skip this
text' code to the parser.  Thus the parser never sees any third
parameter.

Global third;
[ ThirdNoun x;
  x=NounDomain(player,location,0);
  if (x==REPARSE_CODE) return x; if (x==0) return -1; third = x;
  return 0;
];

   *Note Exercise 78: Grammar Tokens.


File: inform,  Node: Answer 79,  Next: Answer 80,  Prev: Answer 78,  Up: Answers

Answer to Exercise 79: "scope" verb
===================================

Global scope_count;
[ PrintIt obj; print_ret ++scope_count, ": ", (a) obj, " (", obj, ")"; ];
[ ScopeSub; LoopOverScope(PrintIt);
  if (scope_count==0) "Nothing is in scope.";
];
Verb meta "scope" *                              -> Scope;

   *Note Exercise 79: Scope.


File: inform,  Node: Answer 80,  Next: Answer 81,  Prev: Answer 79,  Up: Answers

Answer to Exercise 80: "megalook" verb
======================================

[ MegaExam obj; print "^", (a) obj, ": "; <Examine obj>; ];
[ MegaLookSub; <Look>; LoopOverScope(MegaExam); ];
Verb meta "megalook" *                           -> MegaLook;

   *Note Exercise 80: Scope.


File: inform,  Node: Answer 81,  Next: Answer 82,  Prev: Answer 80,  Up: Answers

Answer to Exercise 81: putting everything in scope
==================================================

   A slight refinement of such a "purloin" verb is already defined in
the library (if the constant DEBUG is defined), so there's no need.
But here's how it could be done:

[ Anything i;
  if (scope_stage==1) rfalse;
  if (scope_stage==2)
  {   objectloop (i ofclass Object) PlaceInScope(i); rtrue; }
  "No such in game.";
];

(This disallows multiple matches for efficiency reasons -- the parser
has enough work to do with such a huge scope definition as it is.)  Now
the token scope=Anything will match anything at all, even things like
the abstract concept of `east'.

   *Note Exercise 81: Scope.


File: inform,  Node: Answer 82,  Next: Answer 83,  Prev: Answer 81,  Up: Answers

Answer to Exercise 82: room divided by glass window
===================================================

   Note the sneaky way looking through the window is implemented, and
that the `on the other side' part of the room description isn't printed
in that case.

Property far_side;
Class  Window_Room
  with description
          "This is one end of a long east/west room.",
       before
       [;  Examine, Search: ;
           default:
             if (inp1~=1 && noun~=0 && noun in self.far_side)
                 print_ret (The) noun, " is on the far side of
                    the glass.";
             if (inp2~=1 && second~=0 && second in self.far_side)
                 print_ret (The) second, " is on the far side of
                    the glass.";
       ],
       after
       [;  Look:
             if (ggw has general) rfalse;
             print "^The room is divided by a great glass window";
             if (location.far_side hasnt light) " onto darkness.";
             print ", stretching from floor to ceiling.^";
             if (Locale(location.far_side,
                    "Beyond the glass you can see",
                    "Beyond the glass you can also see")~=0) ".";
       ],
  has  light;
Window_Room window_w "West of Window"
  with far_side window_e;
Window_Room window_e "East of Window"
  with far_side window_w;
Object ggw "great glass window"
  with name "great" "glass" "window",
       before
       [ place; Examine, Search: place=location;
               if (place.far_side hasnt light)
                   "The other side is dark.";
               give self general;
               PlayerTo(place.far_side,1); <Look>; PlayerTo(place,1);
               give self ~general;
               give place.far_side ~visited; rtrue;
       ],
       found_in window_w window_e,
  has  scenery;

A few words about inp1 and inp2 are in order.  noun and second can hold
either objects or numbers, and it's sometimes useful to know which.
inp1 is equal to noun if that's an object, or 1 if that's a number;
likewise for inp2 and second.  (In this case we're just being careful
that the action SetTo eggtimer 35 wouldn't be stopped if object 35
happened to be on the other side of the glass.)  We also need:

[ InScope actor;
   if (actor in window_w && window_e has light) ScopeWithin(window_e);
   if (actor in window_e && window_w has light) ScopeWithin(window_w);
   rfalse;
];

   *Note Exercise 82: Scope.


File: inform,  Node: Answer 83,  Next: Answer 84,  Prev: Answer 82,  Up: Answers

Answer to Exercise 83: dwarf breathing in dark
==============================================

   For good measure, we'll combine this with the previous rule about
moved objects being in scope in the dark.  The following can be
inserted into the `Shell' game:

Object coal "dull coal" Blank_Room
  with name "dull" "coal";

Object Dark_Room "Dark Room"
  with description "An empty room with a west exit.",
       each_turn
       [; if (self has general) self.each_turn=0;
          else "^You hear the breathing of a dwarf.";
       ],
       w_to Blank_Room;

Object -> light_switch "light switch"
  with name "light" "switch",
       initial "On one wall is the light switch.",
       after
       [; SwitchOn: give Dark_Room light;
          SwitchOff: give Dark_Room ~light;
       ],
  has  switchable static;

Object -> diamond "shiny diamond"
  with name "shiny" "diamond"
  has  scored;

Object -> dwarf "dwarf"
  with name "voice" "dwarf",
       life
       [; Order: if (action==##SwitchOn && noun==light_switch)
                 {   give Dark_Room light general;
                     give light_switch on; "~Right you are, squire.~";
                 }
       ],
  has  animate;

[ InScope person i;
  if (parent(person)==Dark_Room)
  {   if (person==dwarf || Dark_Room has general)
          PlaceInScope(light_switch);
  }
  if (person==player && location==thedark)
      objectloop (i near player)
          if (i has moved || i==dwarf)
              PlaceInScope(i);
  rfalse;
];

Note that the routine puts the light switch in scope for the dwarf --
if it didn't, the dwarf would not be able to understand "dwarf, turn
light on", and that was the whole point.

   *Note Exercise 83: Scope.


File: inform,  Node: Answer 84,  Next: Answer 85,  Prev: Answer 83,  Up: Answers

Answer to Exercise 84: nose attached to player
==============================================

   In the Initialise routine, move newplay somewhere and ChangePlayer
to it, where:

Object newplay "yourself"
  with description "As good-looking as ever.", number 0,
       add_to_scope nose,
       capacity 5,
       before
       [;  Inv: if (nose has general) print "You're holding your nose.  ";
           Smell: if (nose has general)
                     "You can't smell a thing with your nose held.";
       ],
  has  concealed animate proper transparent;

Object nose "nose"
  with name "nose", article "your",
       before
       [; Take: if (self has general)
                   "You're already holding your nose.";
                if (children(player) > 1) "You haven't a free hand.";
                give self general; player.capacity=1;
               "You hold your nose with your spare hand.";
          Drop: if (self hasnt general) "But you weren't holding it!";
                give self ~general; player.capacity=5;
                print "You release your nose and inhale again.  ";
                <<Smell>>;
       ],
  has  scenery;

   *Note Exercise 84: Scope.


File: inform,  Node: Answer 85,  Next: Answer 86,  Prev: Answer 84,  Up: Answers

Answer to Exercise 85: sterilising machine
==========================================

Object steriliser "sterilising machine"
  with name "washing" "sterilising" "machine",
       add_to_scope  top_of_wm  go_button,
       before
       [;  PushDir: AllowPushDir(); rtrue;
               Receive:
                   if (receive_action==##PutOn)
                       <<PutOn noun top_of_wm>>;
           SwitchOn: <<Push go_button>>;
       ],
       after
       [;  PushDir: "It's hard work, but the steriliser does roll.";
       ],
       initial
       [;  print "There is a sterilising machine on casters here (a kind of
               chemist's washing machine) with a ~go~ button.  ";
           if (children(top_of_wm)~=0)
           {   print "On top";
               WriteListFrom(child(top_of_wm), ISARE_BIT + ENGLISH_BIT);
               print ".  ";
           }
           if (children(self)~=0)
           {   print "Inside";
               WriteListFrom(child(self), ISARE_BIT + ENGLISH_BIT);
               print ".  ";
           }
       ],
  has  static container open openable;
Object top_of_wm "top of the sterilising machine",
  with article "the",
  has  static supporter;
Object go_button "~go~ button"
  with name "go" "button",
       before [; Push, SwitchOn: "The power is off."; ],
  has  static;

   *Note Exercise 85: Scope.


File: inform,  Node: Answer 86,  Next: Answer 87,  Prev: Answer 85,  Up: Answers

Answer to Exercise 86: red sticky label
=======================================

   The label object itself is not too bad:

Object -> label "red sticky label"
  with name "red" "sticky" "label",
       number 0,
       before
       [;  PutOn, Insert:
               if (self.number~=0)
               {   print "(first removing the label from ",
                   (the) self.number, ")^"; self.number=0; move self to player;
               }
               if (second==self) "That would only make a red mess.";
               self.number=second; remove self;
               print_ret "You affix the label to ", (the) second, ".";
       ],
       react_after
       [ x; x=self.number; if (x==0) rfalse;
           Look: if (x in location)
                   print "^The red sticky label is stuck to ", (the) x, ".^";
           Inv:  if (x in player)
                   print "^The red sticky label is stuck to ", (the) x, ".^";
       ],
       each_turn
       [;  if (parent(self)~=0) self.number=0; ];

Note that label.number holds the object the label is stuck to, or 0 if
it's unstuck: and that when it is stuck, it is removed from the object
tree.  It therefore has to be moved into scope, so we need the rule: if
the labelled object is in scope, then so is the label.

Global disable_self;
[ InScope actor i1 i2;
  if (label.number==0) rfalse; if (disable_self==1) rfalse;
  disable_self=1;
  i1 = TestScope(label, actor);
  i2 = TestScope(label.number, actor);
  disable_self=0;
  if (i1~=0) rfalse;
  if (i2~=0) PlaceInScope(label);
  rfalse;
];

This routine has two interesting points: firstly, it disables itself
while testing scope (since otherwise the game would go into an endless
recursion), and secondly it only puts the label in scope if it isn't
already there.  This is just a safety precaution to prevent the label
reacting twice to actions (and isn't really necessary since the label
can't already be in scope, but is included for the sake of example).

   *Note Exercise 86: Scope.


File: inform,  Node: Answer 87,  Next: Answer 88,  Prev: Answer 86,  Up: Answers

Answer to Exercise 87: "lock" and "unlock" inferring keys
=========================================================

   Firstly, create an attribute is_key and give it to all the keys in
the game.  Then:

Global assumed_key;
[ DefaultLockSub;
  print "(with ", (the) assumed_key, ")^"; <<Lock noun assumed_key>>;
];
[ DefaultLockTest i count;
  if (noun hasnt lockable) rfalse;
  objectloop (i in player)
      if (i has is_key) { count++; assumed_key = i; }
  if (count==1) rtrue; rfalse;
];
Extend "lock" first * noun = DefaultLockTest -> DefaultLock;

(and similar code for "unlock").  Note that "lock strongbox" is matched
by this new grammar line only if the player only has one key: the
DefaultLock strongbox action is generated: which is converted to, say,
Lock strongbox brass_key.

   *Note Exercise 87: Helping the Parser.


File: inform,  Node: Answer 88,  Next: Answer 89,  Prev: Answer 87,  Up: Answers

Answer to Exercise 88: quotations in boxes
==========================================

Array quote_done -> 50;
Global next_quote = -1;
[ Quote i;
  if (quote_done->i==0) { quote_done->i = 1; next_quote = i; }
];
[ AfterPrompt;
  switch(next_quote)
  {   0: box "His stride is wildernesses of freedom:"
             "The world rolls under the long thrust of his heel."
             "Over the cage floor the horizons come."
             ""
             "-- Ted Hughes, ~The Jaguar~";
      1: ...
  }
  next_quote = -1;
];

   *Note Exercise 88: Boxes.


File: inform,  Node: Answer 89,  Next: Answer 90,  Prev: Answer 88,  Up: Answers

Answer to Exercise 89: Invisiclues hints
========================================

   Note the magic line of assembly code here, which only works for
Advanced games:

[ GiveHint hint keypress;
  print (string) hint; new_line; new_line;
  @read_char 1 0 0 keypress;
  if (keypress == 'H' or 'h') rfalse;
  rtrue;
];

And a typical menu item using it:

 if (menu_item==1)
 {   print "(Press ENTER to return to menu, or H for another hint.)^^";
     if (GiveHint("(1/3)  What kind of bird is it, exactly?")==1) return 2;
     if (GiveHint("(2/3)  Magpies are attracted by shiny items.")==1) return 2;
     "(3/3)  Wave at the magpie with the kitchen foil.";
 }

   *Note Exercise 89: Boxes.


File: inform,  Node: Answer 90,  Next: Answer 91,  Prev: Answer 89,  Up: Answers

Answer to Exercise 90: saving the character
===========================================

   By encoding the character into a byte array and using @save and
@restore.  The numbers in this array might contain the character's
name, rank and abilities, together with some coding system to show what
possessions the character has (a brass lamp, 50 feet of rope, etc.)

   *Note Exercise 90: Assembly Language.


File: inform,  Node: Answer 91,  Next: Answer 92,  Prev: Answer 90,  Up: Answers

Answer to Exercise 91: title page
=================================

   Note that we wait for a space character (32) or either kind of
new-line which typical ASCII keyboards produce (10 or 13), just to be
on the safe side:

[ TitlePage i;
   @erase_window -1; print "^^^^^^^^^^^^^";
   i = 0->33; if (i==0) i=80; i=(i-50)/2;
   style bold; font off; spaces(i);
   print "                     RUINS^";
   style roman; print "^^"; spaces(i);
   print "         [Please press SPACE to begin.]^";
   font on;
   box "And make your chronicle as rich with praise"
       "As is the ooze and bottom of the sea"
       "With sunken wreck and sumless treasures."
       ""
       "-- William Shakespeare, ~Henry V~ I. ii. 163";
   do { @read_char 1 0 0 i; } until (i==32 or 10 or 13);
   @erase_window -1;
];

   *Note Exercise 91: Assembly Language.


File: inform,  Node: Answer 92,  Next: Answer 93,  Prev: Answer 91,  Up: Answers

Answer to Exercise 92: status line invisible
============================================

   First put the directive Replace DrawStatusLine; before including the
library; define the global variable invisible_status somewhere.  Then
give the following redefinition:

[ DrawStatusLine i width posa posb;
   if (invisible_status==1) return;
   @split_window 1; @set_window 1; @set_cursor 1 1; style reverse;
   width = 0->33; posa = width-26; posb = width-13;
   spaces (width-1);
   @set_cursor 1 2;  PrintShortName(location);
   if (width > 76)
   {   @set_cursor 1 posa; print "Score: ", sline1;
       @set_cursor 1 posb; print "Moves: ", sline2;
   }
   if (width > 63 && width <= 76)
   {   @set_cursor 1 posb; print sline1, "/", sline2;
   }
   @set_cursor 1 1; style roman; @set_window 0;
];

   *Note Exercise 92: Assembly Language.


File: inform,  Node: Answer 93,  Next: Answer 94,  Prev: Answer 92,  Up: Answers

Answer to Exercise 93: status line showing treasure
===================================================

   First put the directive Replace DrawStatusLine; before including the
library.  Then add the following routine anywhere after treasures_found,
an `Advent' variable, is defined:

[ DrawStatusLine;
   @split_window 1; @set_window 1; @set_cursor 1 1; style reverse;
   spaces (0->33)-1;
   @set_cursor 1 2;  PrintShortName(location);
   if (treasures_found > 0)
   {   @set_cursor 1 50; print "Treasure: ", treasures_found;
   }
   @set_cursor 1 1; style roman; @set_window 0;
];

   *Note Exercise 93: Assembly Language.


File: inform,  Node: Answer 94,  Next: Answer 95,  Prev: Answer 93,  Up: Answers

Answer to Exercise 94: status line with compass rose
====================================================

   Replace with the following.  (Note the use of @@92 as a string
escape, to include a literal backslash character, and @@124 for a
vertical line.)

Constant U_POS 28; Constant W_POS 30; Constant C_POS 31;
Constant E_POS 32; Constant IN_POS 34;
[ DrawStatusLine i;
    @split_window 3; @set_window 1; style reverse; font off;
    @set_cursor 1 1; spaces (0->33)-1;
    @set_cursor 2 1; spaces (0->33)-1;
    @set_cursor 3 1; spaces (0->33)-1;
    @set_cursor 1 2;  print (name) location;
    @set_cursor 1 51; print "Score: ", sline1;
    @set_cursor 1 64; print "Moves: ", sline2;
    if (location ~= thedark)
    {   ! First line
        if (location.u_to ~= 0)  { @set_cursor 1 U_POS; print "U"; }
        if (location.nw_to ~= 0) { @set_cursor 1 W_POS; print "@@92"; }
        if (location.n_to ~= 0)  { @set_cursor 1 C_POS; print "@@124"; }
        if (location.ne_to ~= 0) { @set_cursor 1 E_POS; print "/"; }
        if (location.in_to ~= 0) { @set_cursor 1 IN_POS; print "I"; }
        ! Second line
        if (location.w_to ~= 0)  { @set_cursor 2 W_POS; print "-"; }
                                   @set_cursor 2 C_POS; print "o";
        if (location.e_to ~= 0)  { @set_cursor 2 E_POS; print "-"; }
        ! Third line
        if (location.d_to ~= 0)  { @set_cursor 3 U_POS; print "D"; }
        if (location.sw_to ~= 0) { @set_cursor 3 W_POS; print "/"; }
        if (location.s_to ~= 0)  { @set_cursor 3 C_POS; print "@@124"; }
        if (location.se_to ~= 0) { @set_cursor 3 E_POS; print "@@92"; }
        if (location.out_to ~= 0){ @set_cursor 3 IN_POS; print "O"; }
    }
    @set_cursor 1 1; style roman; @set_window 0; font on;
];

   *Note Exercise 94: Assembly Language.


File: inform,  Node: Answer 95,  Next: Answer 96,  Prev: Answer 94,  Up: Answers

Answer to Exercise 95: status line with centred room
====================================================

   The tricky part is working out the number of characters in the
location name, and this is where @output_stream is so useful.  This
time Replace with:

Array printed_text table 64;
[ DrawStatusLine i j;
  i = 0->33; if (i==0) i=80;
  font off;
  @split_window 1; @buffer_mode 0; @set_window 1;
  style reverse; @set_cursor 1 1; spaces(i);
  printed_text-->0 = 64;
  @output_stream 3 printed_text;
  print (name) location;
  @output_stream -3;
  j=(i-(printed_text-->0))/2;
  @set_cursor 1 j; print (name) location; spaces(j-1);
  style roman;
  @buffer_mode 1; @set_window 0; font on;
];

Note that the table can hold 128 characters (plenty for this purpose),
and that these are stored in printed_text->2 to printed_text->129; the
length printed is held in printed_text-->0.  (`Trinity' actually does
this more crudely, storing away the width of each location name.)

   *Note Exercise 95: Assembly Language.


File: inform,  Node: Answer 96,  Prev: Answer 95,  Up: Answers

Answer to Exercise 96: printf routine
=====================================

   The following implementation is limited to a format string 2 * 64 =
128 characters long, and six subsequent arguments.  %d becomes a
decimal number, %e an English one; %c a character, %% a (single)
percentage sign and %s a string.

Array printed_text table 64;
Array printf_vals --> 6;
[ Printf format p1 p2 p3 p4 p5 p6   pc j k;
  printf_vals-->0 = p1; printf_vals-->1 = p2; printf_vals-->2 = p3;
  printf_vals-->3 = p4; printf_vals-->4 = p5; printf_vals-->5 = p6;
  printed_text-->0 = 64; @output_stream 3 printed_text;
  print (string) format; @output_stream -3;
  j=printed_text-->0;
  for (k=2:k<j+2:k++)
  {   if (printed_text->k == '%')
      {   switch(printed_text->(++k))
          {   '%': print "%";
              'c': print (char) printf_vals-->pc++;
              'd': print printf_vals-->pc++;
              'e': print (number) printf_vals-->pc++;
              's': print (string) printf_vals-->pc++;
              default: print "<** Unknown printf escape **>";
          }
      }
      else print (char) printed_text->k;
  }
];

   *Note Exercise 96: Assembly Language.


File: inform,  Node: Index,  Next: Concept Index,  Prev: Answers,  Up: Top

Index of Attributes, Properties, Objects, and Routines
******************************************************

* Menu:

* absent:                               Attributes.
* Achieved:                             Objects and Routines.
* AddToScope:                           Objects and Routines.
* add_to_scope:                         Properties.
* after:                                Properties.
* AfterLife:                            Entry Points.
* AfterPrompt:                          Entry Points.
* AllowPushDir:                         Objects and Routines.
* Amusing:                              Entry Points.
* animate:                              Attributes.
* article:                              Properties.
* articles:                             Properties.
* autosearch:                           Attributes.
* before:                               Properties.
* BeforeParsing:                        Entry Points.
* cant_go:                              Properties.
* capacity:                             Properties.
* CDefArt:                              Objects and Routines.
* ChangeDefault:                        Objects and Routines.
* ChangePlayer:                         Objects and Routines.
* ChooseObjects:                        Entry Points.
* clothing:                             Attributes.
* compass:                              Objects and Routines.
* concealed:                            Attributes.
* container:                            Attributes.
* daemon:                               Properties.
* DarkToDark:                           Entry Points.
* DeathMessage:                         Entry Points.
* DefArt:                               Objects and Routines.
* describe:                             Properties.
* description:                          Properties.
* DoMenu:                               Objects and Routines.
* door:                                 Attributes.
* door_dir:                             Properties.
* door_to:                              Properties.
* each_turn:                            Properties.
* edible:                               Attributes.
* EnglishNumber:                        Objects and Routines.
* enterable:                            Attributes.
* female:                               Attributes.
* found_in:                             Properties.
* GamePostRoutine:                      Entry Points.
* GamePreRoutine:                       Entry Points.
* general:                              Attributes.
* grammar:                              Properties.
* HasLightSource:                       Objects and Routines.
* InDefArt:                             Objects and Routines.
* initial:                              Properties.
* Initialise:                           Entry Points.
* InScope:                              Entry Points.
* inside_description:                   Properties.
* invent:                               Properties.
* life:                                 Properties.
* light:                                Attributes.
* list_together:                        Properties.
* Locale:                               Objects and Routines.
* lockable:                             Attributes.
* locked:                               Attributes.
* LookRoutine:                          Entry Points.
* LoopOverScope:                        Objects and Routines.
* male:                                 Attributes.
* moved:                                Attributes.
* name:                                 Properties.
* neuter:                               Attributes.
* NewRoom:                              Entry Points.
* NextWord:                             Objects and Routines.
* NextWordStopped:                      Objects and Routines.
* NounDomain:                           Objects and Routines.
* number:                               Properties.
* ObjectIsUntouchable:                  Objects and Routines.
* OffersLight:                          Objects and Routines.
* on:                                   Attributes.
* open:                                 Attributes.
* openable:                             Attributes.
* orders:                               Properties.
* ParseNoun:                            Entry Points.
* ParseNumber:                          Entry Points.
* ParserError:                          Entry Points.
* parse_name:                           Properties.
* PlaceInScope:                         Objects and Routines.
* PlayerTo:                             Objects and Routines.
* plural:                               Properties.
* pluralname:                           Attributes.
* PrintRank:                            Entry Points.
* PrintShortName:                       Objects and Routines.
* PrintTaskName:                        Entry Points.
* PrintVerb:                            Entry Points.
* PronounNotice:                        Objects and Routines.
* PronounValue:                         Objects and Routines.
* proper:                               Attributes.
* react_after:                          Properties.
* react_before:                         Properties.
* REPARSE_CODE:                         Objects and Routines.
* scenery:                              Attributes.
* ScopeWithin:                          Objects and Routines.
* scored:                               Attributes.
* selfobj:                              Objects and Routines.
* SetPronoun:                           Objects and Routines.
* SetTime:                              Objects and Routines.
* short_name:                           Properties.
* short_name_indef:                     Properties.
* StartDaemon:                          Objects and Routines.
* StartTimer:                           Objects and Routines.
* static:                               Attributes.
* StopDaemon:                           Objects and Routines.
* StopTimer:                            Objects and Routines.
* supporter:                            Attributes.
* switchable:                           Attributes.
* talkable:                             Attributes.
* TestScope:                            Objects and Routines.
* thedark:                              Objects and Routines.
* TimePasses:                           Entry Points.
* time_left:                            Properties.
* time_out:                             Properties.
* transparent:                          Attributes.
* TryNumber:                            Objects and Routines.
* UnknownVerb:                          Entry Points.
* UnsignedCompare:                      Objects and Routines.
* visited:                              Attributes.
* when_closed:                          Properties.
* when_off:                             Properties.
* when_on:                              Properties.
* when_open:                            Properties.
* with_key:                             Properties.
* WordAddress:                          Objects and Routines.
* WordLength:                           Objects and Routines.
* workflag:                             Attributes.
* worn:                                 Attributes.
* WriteListFrom:                        Objects and Routines.
* YesOrNo:                              Objects and Routines.
* ZRegion:                              Objects and Routines.
