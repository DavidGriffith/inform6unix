<HTML><HEAD><TITLE>Section 8: Introducing messages and classes</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE><P>
<TR><TD Valign="top"><A HREF="contents.html">Contents</A><BR><A HREF="section7.html">Back</A><BR><A HREF="section9.html">Forward</A><TD bgcolor="#F5DEB3"><BLOCKQUOTE><H3>8. Introducing messages and classes</H3></BLOCKQUOTE><TR><TD><TD>
<P>

<BLOCKQUOTE>
<BR>On a round ball
<BR>A workman that hath copies by, can lay
<BR>An Europe, Afrique and an Asia,
<BR>And quickly make that, which was nothing, All.
<BR><P>...John Donne (<B>1571</B>?--<B>1631</B>), <I>Valediction: Of Weeping</I></BLOCKQUOTE>
<P>


In fact, messages have already appeared in <A HREF="section7.html">Section 7</A>.  Recall from <A HREF="section3.html">Section 3</A>
that a message called <TT>messagename</TT> can be sent to an object called
<TT>objectname</TT> with various supplied details (called <TT>info1</TT> and <TT>info2</TT>
here, though there can be any number from none to 6) as follows:
<PRE>
       objectname.messagename(info1, info2);
</PRE>

And the given object sends back a reply value (which is just a single
quantity).  This is what is really happening when the player tries to
eat the mushroom: first the library sends the mushroom a <TT>before</TT> message
to warn it that something will happen; it might reply <TT>true</TT>, in which
case the library gives up; otherwise the eating takes place, and the
library sends an <TT>after</TT> message to inform the mushroom of its demise.
<P>

Properties like <TT>before</TT>, then, are really rules to deal with incoming
messages.  The same applies to most of the properties in <A HREF="section3.html">Section 3</A>.  For
example, the message
<PRE>
       mushroom.description();
</PRE>

is sent when the player tries to examine the mushroom: if the reply is
<TT>false</TT> then the game prints "You see nothing special about the speckled
mushroom.''  Now the mushroom was set up with
<PRE>
       description
          "The mushroom is capped with blotches, and you aren't at all sure
           it's not a toadstool.",
</PRE>

which doesn't look like a rule for receiving a message, but it is one
all the same: it means "print this text out, print a new-line and
reply <TT>true</TT>''.  A more complicated rule could have been given instead,
as in the following elaboration of the stone-cut steps in 'Ruins':
<PRE>
       description
       [;  print "The cracked and worn steps descend into a dim chamber.
                  Yours might ";
           if (Square_Chamber has visited)
                print "be the first feet to tread";
           else print "have been the first feet to have trodden";
           " them for five hundred years.  On the top step is inscribed
            the glyph Q1.";
       ],
</PRE>

<TT>visited</TT> is an attribute which is currently held only by rooms which
the player has been to.  (The glyphs will be explained later on, as will
the <TT>SquareChamber</TT> room, which is where the steps will lead down into.)
<P>

The library, i.e., the standard game rules, can send out about 40
different kinds of message, <TT>before</TT> and <TT>description</TT> being two of these.
The more interesting an object is, the more ingeniously it will respond
to these messages: an object which ignores all incoming messages will be
lifeless and inert in play, like a small stone.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> In fact there are subtle differences between how the library
uses properties, and message-sending: the <TT>name</TT> property, for example,
is not really a message-receiver but is just what it appears
to be -- a list of useful data.  Also, the library is careful not
to send (for instance) a <TT>description</TT> message to an object which doesn't
provide a rule for what to do with one.  But the idea is right.
</SMALL>
<TR><TD><TD><P>

So the library is sending out messages to your objects all the time
during play.  Your objects can also send each other messages, including
"new'' ones that the library would never send.  It's sometimes
convenient to use these to trigger off happenings in the game.
For example, suppose the 'Ruins' are home to a parrot which
squawks from time to time, for a variety of reasons:
<PRE>
Object -&#62; parrot "red-tailed parrot"
  with name "red" "tailed" "red-tailed" "parrot" "bird",
       description
          "Beautiful plumage.",
       squawk
       [ utterance;
           if (self in location)
               print "The parrot squawks, ~", (string) utterance,
                   "! ", (string) utterance, "!~^";
       ],
  has  animate;
</PRE>

We might then, for instance, change the <TT>after</TT> rule for dropping the
mushroom to read:
<PRE>
           Drop: parrot.squawk("Drop the mushroom");
                 "The mushroom drops to the ground, battered slightly.";
</PRE>

so that the wretched creature would squawk "Drop the mushroom! Drop the
mushroom!'' each time this was done.  Likewise, <TT>squawk</TT> messages could
be sent for any number of other reasons connected with other objects.
But at present it would be an error to send a <TT>squawk</TT> message to any
object other than the parrot, since only the parrot has been given a
rule telling it what to do if it receives one.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex2"><B>EXERCISE 2:</B><BR>(link to <A HREF="answers1/answer2.html">the answer</A>)<TR><TD><TD> Make a medicine bottle, which can be opened in a variety
of ways in the game, so that the opening--code only occurs once in
the bottle definition.
<P>

<P>
In most games there are groups of objects with certain rules in common,
which it would be tiresome to have to write out many times.  For
making such a group, a class definition is the better technique.
These closely resemble object definitions, but since they define prototypes
rather than actual things, they have no initial location.  (An individual
tree may be somewhere, but the concept of being a tree has no
particular place.)  So the 'header' part of the definition is simpler.
<P>

For example, the scoring system in 'Ruins'
works as follows: the player, an archaeologist of the old school,
gets a certain number of points for each 'treasure' (i.e., cultural
artifact) he can filch and put away into his packing case.  This is
implemented with the following class:
<PRE>
 Class Treasure
  with cultural_value 10,
       after
       [; Insert:
                if (second==packing_case)
                    score = score + self.cultural_value;
                "Safely packed away.";
       ],
       before
       [; Take, Remove:
                if (self in packing_case)
                   "Unpacking such a priceless artifact had best wait
                    until the Metropolitan Museum can do it.";
       ];
</PRE>

Note that <TT>self</TT> is a variable, which always means "whatever object
I am''.  If we used it in the definition of the mushroom it would mean
the mushroom: used here, it means whatever treasure happens to be
being dealt with.
(Explanations about <TT>Insert</TT> and <TT>Remove</TT> will come later, but hopefully
the idea is clear enough.)  An object of the class <TT>Treasure</TT> inherits
the properties and attributes it defines: in this case, an object of class
<TT>Treasure</TT> picks up the given score and rules automatically.  So
<PRE>
Treasure statuette "pygmy statuette"
  with description
          "A menacing, almost cartoon-like statuette of a pygmy spirit
           with a snake around its neck.",
       initial "A precious Mayan statuette rests here!",
       name "snake" "mayan" "pygmy" "spirit" "statue" "statuette";
</PRE>

inherits the <TT>cultural_value</TT> score of 10 and the rules about taking
and dropping.  If the statuette had itself set <TT>cultural_value</TT> to 15, say,
then the value would be 15, because the object's actual definition always
takes priority over anything the class might have specified.
<P>

A more unusual artifact:
<PRE>
Treasure honeycomb "ancient honeycomb"
  with article "an",
       name "ancient" "old" "honey" "honeycomb",
       description "Perhaps some kind of funerary votive offering.",
       initial "An exquisitely preserved, ancient honeycomb rests here!",
       after
       [;  Eat: "Perhaps the most expensive meal of your life.  The honey
               tastes odd, perhaps because it was used to store the entrails
               of the king buried here, but still like honey.";
       ],
  has  edible;
</PRE>

The honeycomb now has two <TT>after</TT> rules: a new one of its own, plus the
existing one that all treasures have.  Both apply, but the new one happens
first.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> So comparing <TT>cultural_value</TT> and <TT>after</TT>, there seems to be an
inconsistency.  In the first case, an object's own given value wiped out
the value from the class, but in the second, the two values were joined
up into a list.  Why?  The reason is that some of the library's properties
are special (again) in being what's called "additive'', so that their
values accumulate into a list when class inheritance takes place.  The
three useful examples are <TT>before</TT>, <TT>after</TT> and <TT>name</TT>.

</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Non-library properties you invent (like <TT>squawk</TT> or
<TT>cultural_value</TT>) will never be additive, unless you write a directive
like:
<PRE>
Property additive squawk;
</PRE>

(before <TT>squawk</TT> is otherwise mentioned) to say so.
</SMALL>
<TR><TD><TD><P>

 Finally, note that an object can inherit from several
classes at once (see <A HREF="section3.html">Section 3</A> for how to give such a definition).  Moreover,
a class can itself inherit from other classes, so it's easy to make a
class for "like Treasure but with <TT>cultural_value</TT> normally 8 instead
of 10''.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/refs.gif" ALT="*"><TD bgcolor="#EEEEEE"><B>REFERENCES:</B><BR><SMALL>  See 'Balances' for an extensive use of message-sending.
<BR>
'Advent' has a treasure-class similar to this one, and uses
class definitions for the many similar maze and dead-end rooms
(and the sides of the fissure).
<BR>
That class definitions can be worthwhile even when only two
objects use them, can be seen from the kittens-class in
'Alice Through The Looking-Glass'.
<BR> 'Balances' defines many complicated classes:
see especially the white cube, spell and scroll classes.
<BR> 'Toyshop' contains one easy one (the wax candles) and
one unusually hard one (the building blocks).

</TABLE>
<HR><A HREF="contents.html">Contents</A> / <A HREF="section7.html">Back</A> / <A HREF="section9.html">Forward</A> <BR>
<A HREF="chapter1.html">Chapter I</A> / <A HREF="chapter2.html">Chapter II</A> / <A HREF="chapter3.html">Chapter III</A> / <A HREF="chapter4.html">Chapter IV</A> / <A HREF="chapter5.html">Chapter V</A> / <A HREF="chapter6.html">Chapter VI</A> / <A HREF="chapterA.html">Appendix</A><HR><SMALL><I>Mechanically translated to HTML from third edition as revised 16 May 1997. Copyright &#169; Graham Nelson 1993, 1994, 1995, 1996, 1997: all rights reserved.</I></SMALL></BODY></HTML>
