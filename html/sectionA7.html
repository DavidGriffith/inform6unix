<HTML><HEAD><TITLE>Section A7: Library-defined objects and routines</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE><P>
<TR><TD Valign="top"><A HREF="contents.html">Contents</A><BR><A HREF="sectionA6.html">Back</A><BR><A HREF="sectionA8.html">Forward</A><TD bgcolor="#F5DEB3"><BLOCKQUOTE><H3>A7. Library-defined objects and routines</H3></BLOCKQUOTE><TR><TD><TD>
The library defines the following
special objects:
<P>
<P>

<DT><B><TT>compass</TT></B><DD>
To contain the directions.  A direction object provides a
<TT>door_dir</TT> property, and should have the <TT>direction</TT> attribute.  A compass
direction with <TT>enterable</TT>, if there is one (which there usually isn't),
will have an <TT>Enter</TT> action converted to <TT>Go</TT>.
<P>

<DT><B><TT>n_obj, ...</TT></B><DD>

Both the object signifying the abstract concept of 'northness', and the
'north wall' of the current room.  (Thus, if a player types "examine the
north wall'' then the action <TT>Examine n_obj</TT> will be generated.)  Its
<TT>door_dir</TT> property holds the direction property it corresponds to (<TT>n_to</TT>). 
The other such objects are <TT>s_obj</TT>, <TT>e_obj</TT>, <TT>w_obj</TT>, <TT>ne_obj</TT>, <TT>nw_obj</TT>,
<TT>se_obj</TT>, <TT>sw_obj</TT>, <TT>u_obj</TT>, <TT>d_obj</TT>, <TT>in_obj</TT> and <TT>out_obj</TT>.
Note that the parser understands "ceiling'' to refer to <TT>u_obj</TT> and "floor'' to refer to
<TT>d_obj</TT>.  (<TT>in_obj</TT> and <TT>out_obj</TT> differ slightly, because "in'' and
"out'' are verbs with other effects in some cases; these objects should not
be removed from the <TT>compass</TT>.)
<P>

<DT><B><TT>thedark</TT></B><DD>
A pseudo-room representing 'being in darkness'.  <TT>location</TT>
is then set to this room, but the player object is not moved to it.  Its
<TT>description</TT> can be changed to whatever "It is dark here'' message is
desired.
<P>

<DT><B><TT>selfobj</TT></B><DD>
The default player-object.  Code should never refer directly
to <TT>selfobj</TT>, but only to <TT>player</TT>, a variable whose value is usually indeed
<TT>selfobj</TT> but which might become <TT>green_frog</TT> if the player is transformed
into one.
<P>

<DT><B><TT>InformLibrary</TT></B><DD>
Represents the library.  You never need to use
it, but it might sometimes be the value of <TT>sender</TT> when a message is received.
<P>

<DT><B><TT>InformParser</TT></B><DD>
Represents the parser.
<P>

<P>
The following routines are defined in the library and available for public
use:
<P>
<P>

<DT><B><TT>Achieved(task)</TT></B><DD>

Indicate the <TT>task</TT> is achieved (which only
awards score the first time).
<P>

<DT><B><TT>AddToScope(obj)</TT></B><DD>

Used in an <TT>add_to_scope</TT> routine of an object to add another object
into scope whenever the first is in scope.
<P>

<DT><B><TT>AllowPushDir()</TT></B><DD>

Signal that an attempt to push an object from
one place to another should be allowed.
<P>

<DT><B><TT>CDefArt(obj)</TT></B><DD>

Print the capitalised definite article and
short name of <TT>obj</TT>.  Equivalent to <TT>print (The) obj;</TT>.
<P>

<DT><B><TT>ChangeDefault(p,v)</TT></B><DD>

Changes the default value of property <TT>p</TT>.  (But this won't
do anything useful to <TT>name</TT>.)
<P>

<DT><B><TT>ChangePlayer(obj,flag)</TT></B><DD>

Cause the player at the keyboard to
play as the given object, which must have a <TT>number</TT> property supplied.  If
the <TT>flag</TT> is set to 1, then subsequently print messages like "(as Ford
Prefect)'' in room description headers.  This routine, however, prints nothing
itself.
<P>

<DT><B><TT>DefArt(obj)</TT></B><DD>

Print the definite article and short name of
<TT>obj</TT>.  Equivalent to <TT>print (the) obj;</TT>.
<P>

<DT><B><TT>DoMenu(text,R1,R2)</TT></B><DD>

Produce a menu, using the two routines given.
<P>

<DT><B><TT>EnglishNumber(x)</TT></B><DD>

Prints out <TT>x</TT> in English (e.g., "two hundred and seventy-seven").
<P>

<DT><B><TT>HasLightSource(obj)</TT></B><DD>

Returns true if <TT>obj</TT> 'has light'.
<P>

<DT><B><TT>InDefArt(obj)</TT></B><DD>

Print the indefinite article and short name
of <TT>obj</TT>.  Equivalent to <TT>print (a) obj;</TT>.
<P>

<DT><B><TT>Locale(obj,tx1,tx2)</TT></B><DD>

Prints out the paragraphs of room description which would appear
if <TT>obj</TT> were the room: i.e., prints out descriptions of objects
in <TT>obj</TT> according to the usual rules.  After describing the
objects which have their own paragraphs, a list is given of
the remaining ones.  The string <TT>tx1</TT> is printed if there were
no previous paragraphs, and the string <TT>tx2</TT> otherwise.
(For instance, you might want "On the ledge you can see''
and "On the ledge you can also see''.)  After the list, nothing
else is printed (not even a full stop) and the return value is
the number of objects in the list (possibly zero).
<P>

<DT><B><TT>LoopOverScope(R,actor)</TT></B><DD>

Calls routine <TT>R(obj)</TT> for each object <TT>obj</TT> in scope.  <TT>actor</TT>
is optional: if it's given, then scope is calculated for the
given actor, not the player.
<P>

<DT><B><TT>NextWord()</TT></B><DD>

Returns the next dictionary word in the player's
input, moving the word number <TT>wn</TT> on by one.  Returns 0
if the word is not in the dictionary or if the word stream has
run out.
<P>

<DT><B><TT>NextWordStopped()</TT></B><DD>

As <TT>NextWord</TT>, but returning -1 when the word stream has run out.
<P>

<DT><B><TT>NounDomain(o1,o2,type)</TT></B><DD>

This routine is one of the keystones of the parser: the objects
given are the domains to search through when parsing (almost
always the location and the actor) and the <TT>type</TT> indicates a
token.  The only tokens safely usable are: 0: <TABLE Border><TR><TD><TT>noun</TT></TABLE>,
1: <TABLE Border><TR><TD><TT>held</TT></TABLE> and 6: <TABLE Border><TR><TD><TT>creature</TT></TABLE>.  The routine parses
the best single object name it can from the current position
of <TT>wn</TT>.  It returns 0 (no match), an object number or
the constant <TT>REPARSE_CODE</TT> (to indicate that it had to ask
a clarifying question: this reconstructed the input drastically
and the parser must begin all over again).  <TT>NounDomain</TT> should
only be used by general parsing routines and these should
always return <TT>REPARSE_CODE</TT> if it does.  Note that all of the
usual scope and name-parsing rules apply to the search performed
by <TT>NounDomain</TT>.
<P>

<DT><B><TT>ObjectIsUntouchable</TT></B><DD>

Determines whether any solid barrier (that is, any <TT>container</TT> that
is not <TT>open</TT>) lies between the player and <TT>obj</TT>.  If <TT>flag</TT> is set,
this routine never prints anything; otherwise it prints a message
like "You can't, because ... is in the way.'' if any barrier is
found.  Returns <TT>true</TT> if a barrier is found, <TT>false</TT> if not.
<P>

<DT><B><TT>OffersLight(obj)</TT></B><DD>

Returns true if <TT>obj</TT> 'offers light'.
<P>

<DT><B><TT>PlaceInScope(obj)</TT></B><DD>

Puts <TT>obj</TT> into scope for the parser.
<P>

<DT><B><TT>PlayerTo(place,flag)</TT></B><DD>

Move the player to <TT>place</TT>.  Unless
<TT>flag</TT> is given and is 1, describe the player's surroundings.
<P>

<DT><B><TT>PrintShortName(obj)</TT></B><DD>

Print the short name of <TT>obj</TT>.
(This is protected against <TT>obj</TT> having a meaningless value.)
Equivalent to <TT>print (name) obj;</TT>.
<P>

<DT><B><TT>ScopeWithin(obj)</TT></B><DD>

Puts the contents of <TT>obj</TT> into scope,
recursing downward according to the usual scope rules.
<P>

<DT><B><TT>SetTime(time,rate)</TT></B><DD>

Set the game clock (a 24-hour clock) to the
given <TT>time</TT> (in seconds since the start of the day), to run at the given <TT>rate</TT> <I>r</I>:
r=0
means it does not run, if
r&#62;0
then <I>r</I> seconds pass every turn,
if
r&#60;0
then
-r
turns pass every second.
<P>

<DT><B><TT>StartDaemon(obj)</TT></B><DD>

Makes the daemon of <TT>obj</TT> active, so
that its <TT>daemon</TT> routine will be called every turn.
<P>

<DT><B><TT>StartTimer(obj,time)</TT></B><DD>

Starts the timer of <TT>obj</TT>, set
to go off in <TT>time</TT> turns, at which time its <TT>time_out</TT> routine will be called
(it must provide a <TT>time_left</TT> property).
<P>

<DT><B><TT>StopDaemon(obj)</TT></B><DD>

Makes the daemon of <TT>obj</TT> inactive, so
that its <TT>daemon</TT> routine is no longer called.
<P>

<DT><B><TT>StopTimer(obj)</TT></B><DD>

Stops the timer of <TT>obj</TT>, so that
it won't go off after all.
<P>

<DT><B><TT>TestScope(obj,actor)</TT></B><DD>

Returns true if <TT>obj</TT> is in scope; otherwise false.  <TT>actor</TT>
is optional: if it's given, then scope is calculated for the
given actor, not the player.
<P>

<DT><B><TT>TryNumber(wordnum)</TT></B><DD>

Tries to parse the word at <TT>wordnum</TT> as a
number (recognising decimal numbers and English ones from "one'' to
"twenty''), returning
-1000
if it fails altogether, or the number.
Values exceeding 10000 are rounded down to 10000.
<P>

<DT><B><TT>UnsignedCompare(a,b)</TT></B><DD>

Returns 1 if <I>a</I> greater than <I>b</I>, 0 if <I>a</I> equals <I>b</I> and -1 if <I>a</I> less than <I>b</I>,
regarding <I>a</I> and <I>b</I> as unsigned
numbers between 0 and 65535 (or <TT>$ffff</TT>).  (The usual <TT>&#62;</TT> condition performs
a signed comparison.)
<P>

<DT><B><TT>WordAddress(n)</TT></B><DD>

Returns the byte array containing the raw text of the <I>n</I>-th
word in the word stream.
<P>

<DT><B><TT>WordLength(n)</TT></B><DD>

Returns the length of the raw text of the <I>n</I>-th
word in the word stream.
<P>

<DT><B><TT>WriteListFrom(obj,s)</TT></B><DD>

Write a list of <TT>obj</TT> and its
siblings, with the style being <TT>s</TT> (a bitmap of options).
<P>

<DT><B><TT>YesOrNo()</TT></B><DD>

Assuming that a question has already been printed,
wait for the player to type "yes'' or "no'', returning true or false
accordingly.
<P>

<DT><B><TT>ZRegion(value)</TT></B><DD>

Works out the type of <TT>value</TT>, if possible.  Returns 1 if it's a valid
object number, 2 if a routine address, 3 if a string address and 0
otherwise.
</TABLE>
<HR><A HREF="contents.html">Contents</A> / <A HREF="sectionA6.html">Back</A> / <A HREF="sectionA8.html">Forward</A> <BR>
<A HREF="chapter1.html">Chapter I</A> / <A HREF="chapter2.html">Chapter II</A> / <A HREF="chapter3.html">Chapter III</A> / <A HREF="chapter4.html">Chapter IV</A> / <A HREF="chapter5.html">Chapter V</A> / <A HREF="chapter6.html">Chapter VI</A> / <A HREF="chapterA.html">Appendix</A><HR><SMALL><I>Mechanically translated to HTML from third edition as revised 16 May 1997. Copyright &#169; Graham Nelson 1993, 1994, 1995, 1996, 1997: all rights reserved.</I></SMALL></BODY></HTML>
