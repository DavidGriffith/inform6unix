This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Appendix,  Next: Answers,  Prev: Testing and Hacking,  Up: Top

Tables and summaries
********************

* Menu:

* Operators::                   Table of operators and their precedence
* Statements::                  Table of all Inform statements
* Directives::                  Table of all Inform directives
* Grammar::                     Summary of the `Verb' and `Extend' directives
* Attributes::                  The attributes defined by the library
* Properties::                  The properties defined by the library
* Objects and Routines::        Library-defined objects and routines
* Actions and Fake Actions::    The actions and fakes
* Library Messages::            All the library messages and their numbers
* Entry Points::                Entry points and meaningful constants
* Program Order::               What order the program should be in
* Lexicon::                     A short Inform lexicon


File: inform,  Node: Operators,  Next: Statements,  Prev: Appendix,  Up: Appendix

Inform operators
================

   In the table, "Level" refers to precedence level: thus *, on level 6,
has precedence over +, down on level 5, but both subordinate to unary -,
up on level 8.  The "associativity" of an operator is the way it
brackets up if the formula doesn't specify this: for instance, - is left
associative because

    a - b - c

is understood as

    (a - b) - c

with brackets going on the left.  With some Inform operators, you're not
allowed to be vague like this; these are the ones whose associative is
listed as "none".  Thus

    a == b == c

will produce an error insisting that brackets be written into the
program to make clear what the meaning is.  Given the table (and
sufficient patience) all expressions can be broken down into order: for
instance

    a * b .& c --> d / - f

is calculated as

    ( a*((b.&c)-->d) ) / (-f)

Level Operator   Usage   Assoc.     Purpose
  0      ,       binary  left       separating values to work out
  1      =       binary  right      set equal to
  2      &&      binary  left       logical AND
  2      ||      binary  left       logical OR
  2      ~~      unary   (pre)      logical NOT
  3      ==      binary  none       equal to?
  3      ~=      binary  none       not equal to?
  3      >       binary  none       greater than?
  3      >=      binary  none       greater than or equal to?
  3      <       binary  none       less than?
  3      <=      binary  none       less than or equal to?
  3   has        binary  none       object has this attribute?
  3   hasnt      binary  none       object hasn't this attribute?
  3   in         binary  none       first obj a child of second?
  3   notin      binary  none       first obj not a child of second?
  3   ofclass    binary  none       obj inherits from class?
  3   provides   binary  none       obj provides this property?
  4   or         binary  left       separating alternative values
  5      +       binary  left       16-bit signed addition
  5      -       binary  left       16-bit signed subtraction
  6      *       binary  left       16-bit signed multiplication
  6      /       binary  left       16-bit signed integer division
  6      %       binary  left       16-bit signed remainder
  6      &       binary  left       bitwise AND
  6      |       binary  left       bitwise OR
  6      ~       unary   (pre)      bitwise NOT
  7      ->      binary  left       byte array entry
  7     -->      binary  left       word array entry
  8      -       unary   (pre)      16-bit (signed!) negation
  9      ++      unary   (pre/post) increment
  9      --      unary   (pre/post) decrement
 10      .&      binary  left       property address
 10      .#      binary  left       property length
 11     (...)    binary  left       function call on right hand side
 12      .       binary  left       property value
 13      ::      binary  left       "superclass" operator
 14     (...)    binary  left       function call on left hand side


File: inform,  Node: Statements,  Next: Directives,  Prev: Operators,  Up: Appendix

Inform statements
=================

     box <line-1> <line-2> ... <line-n>
     break
     continue
     do <code block> until <condition>
     font on `or' off
     for (<initial code>:<condition to carry on>:<update code>) <code block>
     give <object> <attribute-1> ... <attribute-n>
     if <condition> <code block>
     if <condition> <code block> else <code-block>
     inversion
     jump <label>
     move <object> to <destination>
     new_line
     objectloop <condition choosing objects> <code block>
     print <list of printing specifications>
     print_ret <list of printing specifications>
     quit
     read <text-buffer> <parsing-buffer>
     remove <object>
     restore <label>
     return <optional value>
     rfalse
     rtrue
     save <label>
     spaces <number of spaces to print>
     string <number> <text>
     style roman `or' bold `or' underline `or' reverse `or' fixed
     switch (<value>) <block of cases>
     while <condition> <code-block>

Statements must be given in lower case.  Code blocks consist of either
a single statement or a group of statements enclosed in braces { and }.
Print specifications are given as a list of one or more items,
separated by commas:

     "<some literal text to print>"
     <numerical quantity>
     (char) <a character code>
     (string) <a string address>
     (address) <text held at this byte address>
     (name) <object>
     (a) <object>
     (an) <object>
     (the) <object>
     (The) <object>
     (property) <name of a property>
     (object) <internal ``hardware'' object short name>


File: inform,  Node: Directives,  Next: Grammar,  Prev: Statements,  Up: Appendix

Inform directives
=================

     Abbreviate <word-1> ... <word-n>
     Array <new-name> <type> <initial values>
     Attribute <new-name>
     Class <new-name> <body of definition>
     Constant <new-name> = <value>
     Default <possibly-new-name>
     End
     Endif
     Extend <grammar extension>
     Global <new-name> = <value>
     Ifdef <symbol-name>
     Ifndef <symbol-name>
     Ifnot
     Iftrue <condition>
     Iffalse <condition>
     Import <list of imported goods>
     Include <source code filename>
     Link <module filename>
     Lowstring <text>
     Message <message-type> <diagnostic-message>
     Object <header> <body of definition>
     Property <new-name>
     Release <number>
     Replace <routine-name>
     Serial "<serial number>"
     Switches <list of switches>
     Statusline score `or' time
     System_file
     Verb <verb-definition>

Nearby, much used in Inform 5 code, is still allowed but in modern code
the notation Object -> is preferable.  A few other directives,
Dictionary, Fake_action, Ifv3, Ifv5, Stub, Trace and Version, are
obsolete or for compiler maintenance.


File: inform,  Node: Grammar,  Next: Attributes,  Prev: Directives,  Up: Appendix

Grammar
=======

   A `verb' is a set of possible initial words in keyboard command,
which are treated synonymously (for example, "wear" and "don") together
with a `grammar'.  A grammar is a list of `lines' which the parser
tries to match, one at a time, and accepts the first one which matches.
The directive

     Verb [meta] <verb-word-1> ... <verb-word-n> <grammar>

creates a new verb.  If it is said to be meta then it will count as `out
of the game': for instance "score" or "save".  New synonyms can be added
to an old verb with:

     Verb <new-word-1> ... <new-word-n> = <existing-verb-word>

An old verb can be modified with the directive

  Extend [only] <existing-word-1> ... <existing-word-n> [<priority>] <grammar>

If only is specified, the existing words given (which must all be from
the same existing verb) are split off into a new independent copy of
the verb.  If not, the directive extends the whole existing verb.  The
priority can be first (insert this grammar at the head of the list),
last (insert it at the end) or replace (throw away the old list and use
this instead); the default is last.

   A line is a list of `tokens' together with the action generated if
each token matches so that the line is accepted.  The syntax of a line
is

     * <token-1> <token-2> ...<token-n> -> <action>

where 0 <= n <= 31.  The action is named without initial ## signs and if
an action which isn't in the standard library set is named then an
action routine (named with the action name followed by Sub) must be
defined somewhere in the game.

   A grammar line can optionally be followed by the word reverse.  This
signals that the action to be generated has two parameters, but which
have been parsed in the wrong order and need to swapped over.  (Note
that a topic is not a parameter, and nor is a preposition.)

A token matches a single particle of what has been typed.  The possible
tokens are:
    "<word>"           that literal word only
    noun               any object in scope
    held               object held by the player
    multi              one or more objects in scope
    multiheld          one or more held objects
    multiexcept        one or more in scope, except the other
    multiinside        one or more in scope, inside the other
    <attribute>        any object in scope which has the attribute
    creature           an object in scope which is animate
    noun = <routine>   any object in scope passing the given test
    scope = <routine>  an object in this definition of scope
    number             a number only
    <routine>          any text accepted by the given routine
    topic              any text at all
    special            any single word or number

Two or more literal words (only) can be written with slash signs /
between them as alternatives.  E.g., "in"/"on" matches either the word
"in" or the word "on".

   For the `noun = <Routine>' token, the test routine must decide
whether or not the object in the noun variable is acceptable and return
true or false.

   For the `scope = <Routine>' token, the routine must look at the
variable scope_stage.  If this is 1, then it must decide whether or not
to allow a multiple object (such as "all") here and return true or
false.  If 2, then the routine may put objects into scope by calling
either PlaceInScope(obj) to put just obj in, or ScopeWithin(obj) to put
the contents of obj into scope.  It must then return either true (to
prevent any other objects from entering scope) or false (to let the
parser put in all the usual objects).  If scope_stage=3, it must print
a suitable message to tell the player that this token was misunderstood.

   A general parsing routine can match any text it likes.  It should
use wn, the variable holding the number of the word currently being
parsed (counting from the verb being word 1) and the routine NextWord()
to read the next word and move wn on by 1.  The routine returns:

     -1    if the user's input isn't understood,
     0    if it's understood but doesn't refer to anything,
     1    if there is a numerical value resulting, or
     n    if object n is understood.

In the case of a number, the actual value should be put into the
variable parsed_number.  On an unsuccessful match (returning -1) it
doesn't matter what the final value of wn is.  Otherwise it should be
left pointing to the next thing `after' what the routine understood.


File: inform,  Node: Attributes,  Next: Properties,  Prev: Grammar,  Up: Appendix

Library attributes
==================

   Here is a concise account of all the normal rules concerning all the
library's attributes, except that: rules about how the parser sorts out
ambiguities are far too complicated to include here, but should not
concern designers anyway; and the definitions of `scope' and `darkness'
are given in *Note Scope:: and *Note Light and Dark:: respectively.
These rules are the result of pragmatism and compromise, but are all
easily modifiable.

`absent'
     A `floating object' (one with a found_in property, which can
     appear in many different rooms) which is absent will in future no
     longer appear in the game.  Note that you cannot make a floating
     object disappear merely by giving it absent, but must explicitly
     remove it as well.

`animate'
     "Is alive (human or animal)."  Can be spoken to in "richard,
     hello" style; matches the creature token in grammar; picks up
     "him" or "her" (according to gender) rather than "it", likewise
     "his"; an object the player is changed into becomes animate; some
     messages read "on whom", etc., instead of "on which"; can't be
     taken; its subobjects "belong to" it rather than "are part of" it;
     messages don't assume it can be "touched" or "squeezed" as an
     ordinary object can; the actions Attack, ThrowAt are diverted to
     life rather than rejected as being `futile violence'.

`clothing'
     "Can be worn."

`concealed'
     "Concealed from view but present." The player object has this; an
     object which was the player until ChangePlayer happened loses this
     property; a concealed door can't be entered; does not appear in
     room descriptions.

`container'
     Affects scope and light; object lists recurse through it if open
     (or transparent); may be described as closed, open, locked, empty;
     a possession will give it a LetGo action if the player tries to
     remove it, or a Receive if something is put in; things can be
     taken or removed from it, or inserted into it, but only if it is
     open; likewise for "transfer" and "empty"; room descriptions
     describe using when_open or when_closed if given; if there is no
     defined description, an Examine causes the contents to be searched
     (i.e. written out) rather than a message "You see nothing special
     about..."; Search only reveals the contents of containers,
     otherwise saying "You find nothing".

`door'
     "Is a door or bridge."  Room descriptions describe using when_open
     or when_closed if given; and an Enter action becomes a Go action.
     If a Go has to go through this object, then: if concealed, the
     player "can't go that way"; if not open, then the player is told
     either that this cannot be ascended or descended (if the player
     tried "up" or "down"), or that it is in the way (otherwise); but
     if neither, then its door_to property is consulted to see where it
     leads; finally, if this is zero, then it is said to "lead nowhere"
     and otherwise the player actually moves to the location.

`edible'
     "Can be eaten" (and thus removed from game).

`enterable'
     Affects scope and light; only an enterable on the floor can be
     entered.  If an enterable is also a container then it can only be
     entered or exited if it is open.

`female'
     This object has a feminine name.  In games written in English,
     this makes her a female person, though in other languages it might
     be inanimate.  The parser uses this information when considering
     pronouns like "her".  (In English, anything animate is assumed to
     be male unless female or neuter is set.)

`general'
     A general-purpose attribute, defined by the library but never
     looked at or altered by it.  This is left free to mean something
     different for each object: often used by programmers for something
     like "the puzzle for this object has been solved".

`light'
     "Is giving off light."  (See *Note Light and Dark::.)  Also: the
     parser understands "lit", "lighted", "unlit" using this;
     inventories will say "(providing light)" of it, and so will room
     descriptions if the current location is ordinarily dark; it will
     never be automatically put away into the player's SACK_OBJECT, as
     it might plausibly be inflammable or the main light source.

`lockable'
     Can be locked or unlocked by a player holding its key object,
     which is given by the property with_key; if a container and also
     locked, may be called "locked" in inventories.

`locked'
     Can't be opened.   If a container and also lockable, may be called
     "locked" in inventories.

`male'
     This object has a masculine name.  In games written in English,
     this makes him a male person, though in other languages it might
     be inanimate.  The parser uses this information when considering
     pronouns like "him".  (In English, anything animate is assumed to
     be male unless female or neuter is set.)

`moved'
     "Has been or is being held by the player."  Objects (immediately)
     owned by the player after Initialise has run are given it; at the
     end of each turn, if an item is newly held by the player and is
     scored, it is given moved and OBJECT_SCORE points are awarded; an
     object's initial message only appears in room descriptions if it
     is unmoved.

`neuter'
     This object's name is neither masculine nor feminine.  (In English,
     anything without animate is assumed neuter, because only people and
     higher animals have gender.  Anything animate is assumed male
     unless female or neuter is set.  A robot, for instance, might be
     an animate object worth making neuter.)

`on'
     "Switched on."  A switchable object with this is described by
     with_on in room descriptions; it will be called "switched on" by
     Examine.

`open'
     "Open door or container."  Affects scope and light; lists (such as
     inventories) recurse through an open container; if a container,
     called "open" by some descriptions; things can be taken or removed
     from an open container; similarly inserted, transferred or
     emptied.  A container can only be entered or exited if it is both
     enterable and open.  An open door can be entered.  Described by
     when_open in room descriptions.

`openable'
     Can be opened or closed, unless locked.

`pluralname'
     This single object's name is in the plural.  For instance, an
     object called "seedless grapes" should have pluralname set.  The
     library will then use the pronoun "them" and the indefinite
     article "some" automatically.

`proper'
     Its short name is a proper noun, and never preceded by "the" or
     "The".  The player's object must have this (so something changed
     into will be given it).

`scenery'
     Not listed by the library in room descriptions; "not portable" to
     be taken; "you are unable to" pull, push, or turn it.

`scored'
     The player gets OBJECT_SCORE points for picking it up for the
     first time; or, if a room, ROOM_SCORE points for visiting it for
     the first time.

`static'
     "Fixed in place" if player tries to take, remove, pull, push or
     turn.

`supporter'
     "Things can be put on top of it."  Affects scope and light; object
     lists recurse through it; a possession will give it a LetGo action
     if the player tries to remove it, or a Receive if something is put
     in; things can be taken or removed from it, or put on it; likewise
     for transfers; a player inside it is said to be "on" rather than
     "in" it; room descriptions list its contents in separate
     paragraphs if it is itself listed.

`switchable'
     Can be switched on or off; listed as such by Examine; described
     using when_on or when_off in room descriptions.

`talkable'
     Player can talk to this object in "thing, do this" style.  This is
     useful for microphones and the like, when animate is inappropriate.

`transparent'
     "Contents are visible."  Affects scope and light; a transparent
     container is treated as if it were open for printing of contents.

`visited'
     "Has been or is being visited by the player." Given to a room
     immediately after a Look first happens there: if this room is
     scored then ROOM_SCORE points are awarded.  Affects whether room
     descriptions are abbreviated or not.

`workflag'
     Temporary flag used by Inform internals, also available to outside
     routines; can be used to select items for some lists printed by
     WriteListFrom.

`worn'
     "Item of clothing being worn."  Should only be an object being
     immediately carried by player.  Affects inventories; doesn't count
     towards the limit of MAX_CARRIED; won't be automatically put away
     into the SACK_OBJECT; a Drop action will cause a Disrobe action
     first; so will PutOn or Insert.

Note that very few attributes sensibly apply to rooms: only really
light, scored and visited, together with general if you choose to use
it.  Note also that an object cannot be both a container and a
supporter; and that the old attribute autosearch, which was in earlier
releases, has been withdrawn as obsolete.


File: inform,  Node: Properties,  Next: Objects and Routines,  Prev: Attributes,  Up: Appendix

Library properties
==================

The following table lists every library-defined property.  The banner
headings give the name, what type of value makes sense and the default
value (if other than 0).  The symbol (+) means "this property is
additive" so that inherited values from class definitions pile up into
a list, rather than wipe each other out.  Recall that `false' is the
value 0 and `true' the value 1.

n_to, s_to, e_to, w_to, ...                            Room, object or routine
     For rooms:
     These twelve properties (there are also ne_to, nw_to, se_to,
     sw_to, in_to, out_to, u_to and d_to) are the map connections for
     the room.  A value of 0 means "can't go this way".  Otherwise, the
     value should either be a room or a door object: thus, e_to might
     be set to crystal_bridge if the direction "east" means "over the
     crystal bridge".

     Routine returns:
     The room or object the map connects to; or 0 for "can't go this
     way"; or 1 for "can't go this way; stop and print nothing further".

     Warning:
     Do not confuse the direction properties n_to and so on with the
     twelve direction objects, n_obj et al.

add_to_scope                                        List of objects or routine
     For objects:
     When this object is in scope, so are all those listed, or all those
     nominated by the routine.  A routine given here should call
     PlaceInScope(obj) to put obj in scope.

     No return value

after                                                       Routine  NULL  (+)
     Receives actions after they have happened, but before the player
     has been told of them.

     For rooms:
     All actions taking place in this room.

     For objects:
     All actions for which this object is noun (the first object
     specified in the command); and all fake actions for it.

     Routine returns:
     False to continue (and tell the player what has happened), true to
     stop here (printing nothing).

     The Search action is a slightly special case.  Here, after is
     called when it is clear that it would be sensible to look inside
     the object (e.g., it's an open container in a light room) but
     before the contents are described.

article                                                 String or routine  "a"
     For objects:
     Indefinite article for object or routine to print one.

     No return value

articles                                                      Array of strings
     For objects: If given, these are the articles used with the
     object's name.  (Provided for non-English languages where
     irregular nouns may have unusual vowel-contraction rules with
     articles: e.g. with French non-mute `H'.)

before                                                      Routine  NULL  (+)
     Receives advance warning of actions (or fake actions) about to
     happen.

     For rooms:
     All actions taking place in this room.

     For objects:
     All actions for which this object is noun (the first object
     specified in the command); and all fake actions, such as Receive
     and LetGo if this object is the container or supporter concerned.

     Routine returns:
     False to continue with the action, true to stop here (printing
     nothing).

     First special case: A vehicle object receives the Go action if the
     player is trying to drive around in it.  In this case:

     Routine returns:
     0 to disallow as usual; 1 to allow as usual, moving vehicle and
     player; 2 to disallow but do (and print) nothing; 3 to allow but do
     (and print) nothing.  If you want to move the vehicle in your own
     code, return 3, not 2: otherwise the old location may be restored
     by subsequent workings.

     Second special case: in a PushDir action, the before routine must
     call AllowPushDir() and then return true in order to allow the
     attempt (to push an object from one room to another) to succeed.

cant_go                            String or routine  "You can't go that way."
     For rooms:
     Message, or routine to print one, when a player tries to go in an
     impossible direction from this room.

     No return value

capacity                                                Number or routine  100
     For objects:
     Number of objects a container or supporter can hold.

     For the player-object:
     Number of things the player can carry (when the player is this
     object); the default player object (selfobj) has capacity initially
     set to the constant MAX_CARRIED.

daemon                                                           Routine  NULL
     This routine is run each turn, once it has been activated by a
     call to StartDaemon, and until stopped by a call to StopDaemon.

describe                                                    Routine  NULL  (+)
     For objects:
     Called when the object is to be described in a room description,
     before any paragraph break (i.e., skipped line) has been printed.
     A sometimes useful trick is to print nothing in this routine and
     return true, which makes an object `invisible'.

     For rooms:
     Called before a room's long ("look") description is printed.

     Routine returns:
     False to describe in the usual way, true to stop printing here.

description                                                  String or routine
     For objects:
     The Examine message, or a routine to print one out.

     For rooms:
     The long ("look") description, or a routine to print one out.

     No return value

door_dir                                         Direction property or routine
     For compass objects:
     When the player tries to go in this direction, e.g., by typing the
     name of this object, then the map connection tried is the value of
     this direction property for the current room.  For example, the
     n_obj "north" object normally has door_dir set to n_to.

     For objects:
     The direction that this door object goes via (for instance, a
     bridge might run east, in which case this would be set to e_to).

     Routine returns:
     The direction property to try.

door_to                                                        Room or routine
     For objects:
     The place this door object leads to.  A value of 0 means "leads
     nowhere".

     Routine returns:
     The room.  Again, 0 (or false) means "leads nowhere".  Further, 1
     (or true) means "stop the movement action immediately and print
     nothing further".

each_turn                                         String or routine  NULL  (+)
     String to print, or routine to run, at the end of each turn in
     which the object is in scope (after all timers and daemons for
     that turn have been run).

     No return value

found_in                                              List of rooms or routine
     This object will be found in all of the listed rooms, or if the
     routine says so, unless it has the attribute absent.  If an object
     in the list is not a room, it means "present in the same room as
     this object".

     Routine returns:
     True to be present, otherwise false.  The routine can look at the
     current location in order to decide.

     Warning:
     This property is only looked at when the player changes rooms.

grammar                                                                Routine
     For animate or talkable objects:
     This is called when the parser has worked out that the object in
     question is being spoken to, and has decided the verb_word and
     verb_wordnum (the position of the verb word in the word stream)
     but hasn't yet tried any grammar.  The routine can, if it wishes,
     parse past some words (provided it moves verb_wordnum on by the
     number of words it wants to eat up).

     Routine returns:
     False to carry on as usual; true to indicate that the routine has
     parsed the entire command itself, and set up action, noun and
     second to the appropriate order; or a dictionary value for a verb,
     such as 'take', to indicate "parse the command from this verb's
     grammar instead"; or minus such a value, e.g. -'take', to indicate
     "parse from this verb and then parse the usual grammar as well".

initial                                                      String or routine
     For objects:
     The description of an object not yet picked up, used when a room
     is described; or a routine to print one out.

     For rooms:
     Printed or run when the room is arrived in, either by ordinary
     movement or by PlayerTo.

     Warning:
     If the object is a door, or a container, or is switchable, then
     use one of the when_ properties rather than initial.

     No return value

inside_description                                           String or routine
     For objects:
     Printed as part or all of a room description when the player is
     inside the given object, which must be enterable.

invent                                                                 Routine
     This routine is for changing an object's inventory listing.  If
     provided, it's called twice, first with the variable
     inventory_stage set to 1, second with it set to 2.  At stage 1,
     you have an entirely free hand to print a different inventory
     listing.

     Routine returns:
     Stage 1: False to continue; true to stop here, printing nothing
     further about the object or its contents.

     At stage 2, the object's indefinite article and short name have
     already been printed, but messages like " (providing light)"
     haven't.  This is an opportunity to add something like " (almost
     empty)".

     Routine returns:
     Stage 2: False to continue; true to stop here, printing nothing
     further about the object or its contents.

life                                                        Routine  NULL  (+)
     This routine holds rules about animate objects, behaving much like
     before and after but only handling the person-to-person events:

     Attack Kiss WakeOther ThrowAt Give Show Ask Tell Answer Order

     See *Note Living Creatures::, and see also the properties orders
     and grammar.

     Routine returns:
     True to stop and print nothing, false to resume as usual (for
     example, printing "Miss Gatsby has better things to do.").

list_together                                        Number, string or routine
     For objects:
     Objects with the same list_together value are grouped together in
     object lists (such as inventories, or the miscellany at the end of
     a room description).  If a string such as "fish" is given, then
     such a group will be headed with text such as "five fish".

     A routine, if given, is called at two stages in the process (once
     with the variable inventory_stage set to 1, once with it set to 2).
     These stages occur before and after the group is printed; thus, a
     preamble or postscript can be printed.  Also, such a routine may
     change the variable c_style (which holds the current list style).
     On entry, the variable parser_one holds the first object in the
     group, and parser_two the current depth of recursion in the list.
     Applying x=NextEntry(x,parser_two); moves x on from parser_one to
     the next item in the group.  Another helpful variable is
     listing_together, set up to the first object of a group being
     listed (or to 0 whenever no group is being listed).

     Routine returns:
     Stage 1: False to continue, true not to print the group's list at
     all.

     Routine returns:
     Stage 2: No return value.

orders                                                                 Routine
     For animate or talkable objects:
     This carries out the player's orders (or doesn't, as it sees fit):
     it looks at actor, action, noun and second to do so.  Unless this
     object is the current player, actor is irrelevant (it is always
     the player) and the object is the person being ordered about.

     If the player typed an incomprehensible command, like "robot, og
     sthou", then the action is NotUnderstood and the variable etype
     holds the parser's error number.

     If this object is the current player then actor is the person
     being ordered about.  actor can either be this object -- in which
     case an action is being processed, because the player has typed an
     ordinary command -- or can be some other object, in which case the
     player has typed an order.  See *Note Living Creatures:: for how
     to write orders routines in these cases.

     Routine returns:
     True to stop and print nothing further; false to continue.
     (Unless the object is the current player, the life routine's Order
     section gets an opportunity to meddle next; after that, Inform
     gives up.)

name                                             List of dictionary words  (+)
     For objects:
     A list of dictionary words referring to this object.

     Warning:
     The parse_name property of an object may take precedence over this,
     if present.

     For rooms:
     A list of words which the room understands but which refer to
     things which "do not need to be referred to in this game"; these
     are only looked at if all other attempts to understand the
     player's command have failed.

     Warning:
     Uniquely in Inform syntax, these dictionary words are given in
     double quotes "thus", whereas in all other circumstances they
     would be 'thus'.  This means they can safely be only one letter
     long without ambiguity.

number                                                               Any value
     A general purpose property left free: conventionally holding a
     number like "number of turns' battery power left".

     For compass objects:
     Note that the standard compass objects defined by the library all
     provide a number property, in case this might be useful to the
     designer.

     For the player-object:
     Exception: an object to be used as a player-object must provide
     one of these, and musn't use it for anything.

parse_name                                                             Routine
     For objects:
     To parse an object's name (this overrides the name but is also
     used in determining if two objects are describably identical).
     This routine should try to match as many words as possible in
     sequence, reading them one at a time by calling NextWord(). (It
     can leave the "word marker" variable wn anywhere it likes).

     Routine returns:
     0 if the text didn't make any sense at all, -1 to make the parser
     resume its usual course (looking at the name), or the number of
     words in a row which successfully matched.

     In addition to this, if the text matched seems to be in the plural
     (for instance, a blind mouse object reading blind mice), the
     routine can set the variable parser_action to the value
     ##PluralFound.  The parser will then match with all of the
     different objects understood, rather than ask a player which of
     them is meant.

     A parse_name routine may also (voluntarily) assist the parser by
     telling it whether or not two objects which share the same
     parse_name routine are identical.  (They may share the same
     routine if they both inherit it from a class.)  If, when it is
     called, the variable parser_action is set to ##TheSame then this
     is the reason.  It can then decide whether or not the objects
     parser_one and parser_two are indistinguishable.

     Routine returns:
     -1 if the objects are indistinguishable, -2 if not.

plural                                                       String or routine
     For objects:
     The plural name of an object (when in the presence of others like
     it), or routine to print one; for instance, a wax candle might
     have plural set to "wax candles".

     No return value

react_after                                                            Routine
     For objects:
     Acts like an after rule, but detects any actions in the vicinity
     (any actions which take place when this object is in scope).

     Routine returns:
     True to print nothing further; false to carry on.

react_before                                                           Routine
     For objects:
     Acts like a before rule, but detects any actions in the vicinity
     (any actions which take place when this object is in scope).

     Routine returns:
     True to stop the action, printing nothing; false to carry on.

short_name                                                             Routine
     For objects:
     The short name of an object (like "brass lamp"), or a routine to
     print it.

     Routine returns:
     True to stop here, false to carry on by printing the object's
     `real' short name (the string given at the head of the object's
     definition).  It's sometimes useful to print text like "half-empty
     " and then return false.

short_name_indef                                                       Routine
     For objects:
     If set, this form of the short name is used when the name is
     prefaced by an indefinite article.  (This is not useful in
     English-language games, but in other languages adjectival parts of
     names agree with the definiteness of the article.)

time_left                                                               Number
     Number of turns left until the timer for this object (if set,
     which must be done using StartTimer) goes off.  Its initial value
     is of no significance, as StartTimer will write over this, but a
     timer object must provide the property.  If the timer is currently
     set, the value 0 means "will go off at the end of the current
     turn", the value 1 means "...at the end of next turn" and so on.

time_out                                                         Routine  NULL
     Routine to run when the timer for this object goes off (having
     been set by StartTimer and not in the mean time stopped by
     StopTimer).

     Warning:
     A timer object must also provide a time_left property.

when_closed                                                  String or routine
     For objects:
     Description, or routine to print one, of something closed (a door
     or container) in a room's long description.

     No return value

when_open                                                    String or routine
     For objects:
     Description, or routine to print one, of something open (a door or
     container) in a room's long description.

     No return value

when_on                                                      String or routine
     For objects:
     Description, or routine to print one, of a switchable object which
     is currently switched on, in a room's long description.

     No return value

when_off                                                     String or routine
     For objects:
     Description, or routine to print one, of a switchable object which
     is currently switched off, in a room's long description.

     No return value

with_key                                                       Object  nothing
     The key object needed to lock or unlock this lockable object. A
     player must explicitly name it as the key being used and be
     holding it at the time.  The value nothing, or 0, means that no
     key fits (though this is not made clear to the player, who can try
     as many as he likes).


File: inform,  Node: Objects and Routines,  Next: Actions and Fake Actions,  Prev: Properties,  Up: Appendix

Library-defined objects and routines
====================================

   The library defines the following special objects:

`compass'
     To contain the directions.  A direction object provides a door_dir
     property, and should have the direction attribute.  A compass
     direction with enterable, if there is one (which there usually
     isn't), will have an Enter action converted to Go.

`n_obj, ...'
     Both the object signifying the abstract concept of `northness',
     and the `north wall' of the current room.  (Thus, if a player
     types "examine the north wall" then the action Examine n_obj will
     be generated.)  Its door_dir property holds the direction property
     it corresponds to (n_to).  The other such objects are s_obj,
     e_obj, w_obj, ne_obj, nw_obj, se_obj, sw_obj, u_obj, d_obj, in_obj
     and out_obj.  Note that the parser understands "ceiling" to refer
     to u_obj and "floor" to refer to d_obj.  (in_obj and out_obj
     differ slightly, because "in" and "out" are verbs with other
     effects in some cases; these objects should not be removed from
     the compass.)

`thedark'
     A pseudo-room representing `being in darkness'.  location is then
     set to this room, but the player object is not moved to it.  Its
     description can be changed to whatever "It is dark here" message is
     desired.

`selfobj'
     The default player-object.  Code should never refer directly to
     selfobj, but only to player, a variable whose value is usually
     indeed selfobj but which might become green_frog if the player is
     transformed into one.

`InformLibrary'
     Represents the library.  You never need to use it, but it might
     sometimes be the value of sender when a message is received.

`InformParser'
     Represents the parser.

The following routines are defined in the library and available for
public use:

`Achieved(task)'
     Indicate the task is achieved (which only awards score the first
     time).

`AddToScope(obj)'
     Used in an add_to_scope routine of an object to add another object
     into scope whenever the first is in scope.

`AllowPushDir()'
     Signal that an attempt to push an object from one place to another
     should be allowed.

`CDefArt(obj)'
     Print the capitalised definite article and short name of obj.
     Equivalent to print (The) obj;.

`ChangeDefault(p,v)'
     Changes the default value of property p.  (But this won't do
     anything useful to name.)

`ChangePlayer(obj,flag)'
     Cause the player at the keyboard to play as the given object,
     which must have a number property supplied.  If the flag is set to
     1, then subsequently print messages like "(as Ford Prefect)" in
     room description headers.  This routine, however, prints nothing
     itself.

`DefArt(obj)'
     Print the definite article and short name of obj.  Equivalent to
     print (the) obj;.

`DoMenu(text,R1,R2)'
     Produce a menu, using the two routines given.

`EnglishNumber(x)'
     Prints out x in English (e.g., "two hundred and seventy-seven").

`HasLightSource(obj)'
     Returns true if obj `has light'.

`InDefArt(obj)'
     Print the indefinite article and short name of obj.  Equivalent to
     print (a) obj;.

`Locale(obj,tx1,tx2)'
     Prints out the paragraphs of room description which would appear
     if obj were the room: i.e., prints out descriptions of objects in
     obj according to the usual rules.  After describing the objects
     which have their own paragraphs, a list is given of the remaining
     ones.  The string tx1 is printed if there were no previous
     paragraphs, and the string tx2 otherwise.  (For instance, you
     might want "On the ledge you can see" and "On the ledge you can
     also see".)  After the list, nothing else is printed (not even a
     full stop) and the return value is the number of objects in the
     list (possibly zero).

`LoopOverScope(R,actor)'
     Calls routine R(obj) for each object obj in scope.  actor is
     optional: if it's given, then scope is calculated for the given
     actor, not the player.

`NextWord()'
     Returns the next dictionary word in the player's input, moving the
     word number wn on by one.  Returns 0 if the word is not in the
     dictionary or if the word stream has run out.

`NextWordStopped()'
     As NextWord, but returning -1 when the word stream has run out.

`NounDomain(o1,o2,type)'
     This routine is one of the keystones of the parser: the objects
     given are the domains to search through when parsing (almost
     always the location and the actor) and the type indicates a token.
     The only tokens safely usable are: 0: `noun', 1: `held' and 6:
     `creature'.  The routine parses the best single object name it can
     from the current position of wn.  It returns 0 (no match), an
     object number or the constant REPARSE_CODE (to indicate that it
     had to ask a clarifying question: this reconstructed the input
     drastically and the parser must begin all over again).  NounDomain
     should only be used by general parsing routines and these should
     always return REPARSE_CODE if it does.  Note that all of the usual
     scope and name-parsing rules apply to the search performed by
     NounDomain.

`ObjectIsUntouchable(obj,flag)'
     Determines whether any solid barrier (that is, any container that
     is not open) lies between the player and obj.  If flag is set,
     this routine never prints anything; otherwise it prints a message
     like "You can't, because ... is in the way." if any barrier is
     found.  Returns true if a barrier is found, false if not.

`OffersLight(obj)'
     Returns true if obj `offers light'.

`PlaceInScope(obj)'
     Puts obj into scope for the parser.

`PlayerTo(place,flag)'
     Move the player to place.  Unless flag is given and is 1, describe
     the player's surroundings.

`PrintShortName(obj)'
     Print the short name of obj.  (This is protected against obj
     having a meaningless value.) Equivalent to print (name) obj;.

`PronounNotice(obj)'
     Sets all appropriate pronouns to refer to obj.  That is, it works
     out if obj is a thing or a person, of what number and gender, which
     pronouns apply to it in the parser's current language, and so on.

`PronounValue(pronoun)'
     Returns the current setting of pronoun, which may be nothing.  In
     English, pronoun may be 'it', 'him', 'her', or 'them'.

`ScopeWithin(obj)'
     Puts the contents of obj into scope, recursing downward according
     to the usual scope rules.

`SetPronoun(pronoun,obj)'
     Makes pronoun refer to obj, which may be nothing.  In English,
     pronoun may be 'it', 'him', 'her', or 'them'.  You probably want
     to use PronounNotice instead.

`SetTime(time,rate)'
     Set the game clock (a 24-hour clock) to the given time (in seconds
     since the start of the day), to run at the given rate r: r=0 means
     it does not run, if r>0 then r seconds pass every turn, if r<0
     then -r turns pass every second.

`StartDaemon(obj)'
     Makes the daemon of obj active, so that its daemon routine will be
     called every turn.

`StartTimer(obj,time)'
     Starts the timer of obj, set to go off in time turns, at which
     time its time_out routine will be called (it must provide a
     time_left property).

`StopDaemon(obj)'
     Makes the daemon of obj inactive, so that its daemon routine is no
     longer called.

`StopTimer(obj)'
     Stops the timer of obj, so that it won't go off after all.

`TestScope(obj,actor)'
     Returns true if obj is in scope; otherwise false.  actor is
     optional: if it's given, then scope is calculated for the given
     actor, not the player.

`TryNumber(wordnum)'
     Tries to parse the word at wordnum as a number (recognising
     decimal numbers and English ones from "one" to "twenty"),
     returning -1000 if it fails altogether, or the number.  Values
     exceeding 10000 are rounded down to 10000.

`UnsignedCompare(a,b)'
     Returns 1 if a>b, 0 if a=b and a<b, regarding a and b as unsigned
     numbers between 0 and 65535 (or $ffff).  (The usual > condition
     performs a signed comparison.)

`WordAddress(n)'
     Returns the byte array containing the raw text of the n-th word in
     the word stream.

`WordLength(n)'
     Returns the length of the raw text of the n-th word in the word
     stream.

`WriteListFrom(obj,s)'
     Write a list of obj and its siblings, with the style being s (a
     bitmap of options).

`YesOrNo()'
     Assuming that a question has already been printed, wait for the
     player to type "yes" or "no", returning true or false accordingly.

`ZRegion(value)'
     Works out the type of value, if possible.  Returns 1 if it's a
     valid object number, 2 if a routine address, 3 if a string address
     and 0 otherwise.


File: inform,  Node: Actions and Fake Actions,  Next: Library Messages,  Prev: Objects and Routines,  Up: Appendix

Library actions
===============

   The actions implemented by the library are in three groups.  Group 1
consists of actions associated with `meta'-verbs, which are not subject
to game rules.  (If you want a room where the game can't be saved, as
for instance `Spellbreaker' cunningly does, you'll have to tamper with
SaveSub directly, using a Replaced routine.)

1a. Quit, Restart, Restore, Verify, Save, ScriptOn, ScriptOff, Pronouns,
    Score, Fullscore, LMode1, LMode2, LMode3, NotifyOn, NotifyOff,
    Version, Places, Objects.

(Lmode1, Lmode2 and Lmode3 switch between "brief", "verbose" and
"superbrief" room description styles.) In addition, but only if DEBUG
is defined, so that the debugging suite is present, group 1 contains

1b. TraceOn, TraceOff, TraceLevel, ActionsOn, ActionsOff, RoutinesOn,
    RoutinesOff, TimersOn, TimersOff, CommandsOn, CommandsOff, CommandsRead,
    Predictable, XPurloin, XAbstract, XTree, Scope, Goto, Gonear.

Group 2 contains actions which sometimes get as far as the `after'
stage, because the library sometimes does something when processing
them.

2. Inv, InvTall, InvWide, Take, Drop, Remove, PutOn, Insert, Transfer,
   Empty, Enter, Exit, GetOff, Go, GoIn, Look, Examine, Search, Give, Show,
   Unlock, Lock, SwitchOn, SwitchOff, Open, Close, Disrobe, Wear, Eat.

Group 3 contains the remaining actions, which never reach `after'
because the library simply prints a message and stops at the `during'
stage.

3. Yes, No, Burn, Pray, Wake, WakeOther [person], Consult,
   Kiss, Think, Smell, Listen, Taste, Touch, Dig,
   Cut, Jump [jump on the spot], JumpOver, Tie, Drink,
   Fill, Sorry, Strong [swear word], Mild [swear word], Attack, Swim,
   Swing [something], Blow, Rub, Set, SetTo, WaveHands [ie, just "wave"],
   Wave [something], Pull, Push, PushDir [push something in a direction],
   Turn, Squeeze, LookUnder [look underneath something],
   ThrowAt, Answer, Buy, Ask, AskFor, Sing, Climb, Wait, Sleep.

!! The actions PushDir and Go (while the player is inside an enterable
object) have special rules: see *Note Things to Enter::.

The library also defines 8 fake actions:

LetGo, Receive, ThrownAt, Order, TheSame, PluralFound, Miscellany, Prompt

LetGo, Receive and ThrownAt are used to allow the second noun of
Insert, PutOn, ThrowAt, Remove actions to intervene; Order is used to
process actions through somebody's life routine; TheSame and
PluralFound are defined by the parser as ways for the program to
communicate with it; Miscellany and Prompt are defined as slots for
LibraryMessages.
