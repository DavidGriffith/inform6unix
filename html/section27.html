<HTML><HEAD><TITLE>Section 27: Tokens of grammar</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE></SMALL>
<TR><TD><TD><P>
<TR><TD Valign="top"><A HREF="contents.html">Contents</A><BR><A HREF="section26.html">Back</A><BR><A HREF="section28.html">Forward</A><TD bgcolor="#F5DEB3"><BLOCKQUOTE><H3>27. Tokens of grammar</H3></BLOCKQUOTE><TR><TD><TD>
<P>


The complete list of grammar tokens is as
follows:

<BR><TABLE Border><TR><TD> <TABLE Border><TR><TD><TT>"</TT><I><B>&#60;word&#62;</B></I><TT>"</TT></TABLE> <TD>    that literal word only
<TR><TD> <TABLE Border><TR><TD><TT>noun</TT></TABLE>          <TD>    any object in scope
<TR><TD> <TABLE Border><TR><TD><TT>held</TT></TABLE>          <TD>    object held by the player
<TR><TD> <TABLE Border><TR><TD><TT>multi</TT></TABLE>         <TD>    one or more objects in scope
<TR><TD> <TABLE Border><TR><TD><TT>multiheld</TT></TABLE>     <TD>    one or more held objects
<TR><TD> <TABLE Border><TR><TD><TT>multiexcept</TT></TABLE>   <TD>    one or more in scope, except the other
<TR><TD> <TABLE Border><TR><TD><TT>multiinside</TT></TABLE>   <TD>    one or more in scope, inside the other
<TR><TD> <TABLE Border><TR><TD><I><B>&#60;attribute&#62;</B></I></TABLE>  <TD>    any object in scope which has the attribute
<TR><TD> <TABLE Border><TR><TD><TT>creature</TT></TABLE>      <TD>    an object in scope which is <TT>animate</TT>
<TR><TD> <TABLE Border><TR><TD><TT>noun = </TT><I><B>&#60;Routine&#62;</B></I></TABLE> <TD>    any object in scope passing the given test
<TR><TD> <TABLE Border><TR><TD><TT>scope = </TT><I><B>&#60;Routine&#62;</B></I></TABLE> <TD>    an object in this definition of scope
<TR><TD> <TABLE Border><TR><TD><TT>number</TT></TABLE>        <TD>    a number only
<TR><TD> <TABLE Border><TR><TD><I><B>&#60;Routine&#62;</B></I></TABLE>    <TD>    any text accepted by the given routine
<TR><TD> <TABLE Border><TR><TD><TT>topic</TT></TABLE>         <TD>    any text at all
<TR><TD> <TABLE Border><TR><TD><TT>special</TT></TABLE>       <TD>    any single word or number
</TABLE>
<P>


These tokens are all described in this section except for
<TABLE Border><TR><TD><TT>scope = </TT><I><B>&#60;Routine&#62;</B></I></TABLE>, which is postponed to the next.
<P>

<P><TABLE Border><TR><TD><TT>"</TT><I><B>&#60;word&#62;</B></I><TT>"</TT></TABLE><SAMP>            </SAMP>
This matches only the literal word given, normally a preposition such
as <TT>"into"</TT>.  Whereas most tokens produce a "parameter'' (an object
or group of objects, or a number), this token doesn't.  There can therefore
be as many or as few of them on a grammar line as desired.
<P>

It often happens that several prepositions really mean
the same thing for a given verb: "in", "into" and "inside"
are often equally sensible.  As a convenient shorthand
you can write a series of prepositions with slash marks <TT>/</TT>
in between, to mean "one of these words".  For example:
<PRE>
     * noun "in"/"into"/"inside" noun      -&#62; Insert
</PRE>

(Note that <TT>/</TT> can only be used with prepositions.)
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> Prepositions like this are unfortunately sometimes called 'adjectives'
inside the parser source code, and in Infocom hackers' documents: the usage
is traditional but has been avoided in this manual.
</SMALL>
<TR><TD><TD><P>

<P><TABLE Border><TR><TD><TT>noun</TT></TABLE><SAMP>            </SAMP>
The definition of "in scope'' will be given in the next section.  Roughly,
it means "visible to the player at the moment''.
<P>

<P><TABLE Border><TR><TD><TT>held</TT></TABLE><SAMP>            </SAMP>
Convenient for two reasons.  Firstly, many actions
only sensibly apply to things being held (such as <TT>Eat</TT> or <TT>Wear</TT>), and
using this token in the grammar you can make sure that the action is
never generated by the parser unless the object is being held.  That
saves on always having to write "You can't eat what you're not holding"
code.  Secondly, suppose we have grammar
<PRE>
Verb "eat"
                * held                           -&#62; Eat;
</PRE>

and the player types "eat the banana''
while the banana is, say, in plain view on a shelf.  It would be
petty of the game to refuse on the grounds that the banana is
not being held.  So the parser will generate a <TT>Take</TT> action for the
banana and then, if the <TT>Take</TT> action succeeds, an <TT>Eat</TT> action.  Notice
that the parser does not just pick up the object, but issues an action
in the proper way -- so if the banana had rules making it too slippery
to pick up, it won't be picked up.  This is called "implicit taking''.
<P>

<P>
The <TABLE Border><TR><TD><TT>multi-</TT></TABLE> tokens indicate that a list of one or more objects can
go here.  The parser works out all the things the player has asked
for, sorting out plural nouns and words like "except" by itself, and
then generates actions for each one.  A single grammar line can only
contain one <TABLE Border><TR><TD><TT>multi-</TT></TABLE> token: so "hit everything with everything"
can't be parsed (straightforwardly, that is: you can parse <I> anything</I>
with a little more effort).  The reason not all nouns can be multiple
is that too helpful a parser makes too easy a game.  You probably don't
want to allow "unlock the mystery door with all the keys''
-- you want the player to suffer having to try them one at a time,
or else to be thinking.
<P>

<P><TABLE Border><TR><TD><TT>multiexcept</TT></TABLE><SAMP>            </SAMP>
Provided to make commands like "put everything in the rucksack''
parsable: the "everything" is matched by all of the player's
possessions except the rucksack.  This stops the parser from
generating an action to put the rucksack inside itself.
<P>

<P><TABLE Border><TR><TD><TT>multiinside</TT></TABLE><SAMP>            </SAMP>
Similarly, this matches anything inside the other parameter on
the line, and is good for parsing commands like
"remove everything from the cupboard''.
<P>

<P><TABLE Border><TR><TD><I><B>&#60;attribute&#62;</B></I></TABLE><SAMP>            </SAMP> 
This allows you to sort out objects according to attributes that they have:
<PRE>
Verb "use" "employ" "utilise"
                * edible                    -&#62; Eat
                * clothing                  -&#62; Wear
      ...and so on...
                * enterable                 -&#62; Enter;
</PRE>

though the library grammar does not contain such an
appallingly convenient verb!  Since you can define your own attributes,
it's easy to make a token matching only your own class of object.
<P>

<P><TABLE Border><TR><TD><TT>creature</TT></TABLE><SAMP>            </SAMP> Same as <TABLE Border><TR><TD><TT>animate</TT></TABLE>
(a hangover from older editions of Inform).
<P>

<P><TABLE Border><TR><TD><TT>noun = </TT><I><B>&#60;Routine&#62;</B></I></TABLE><SAMP>            </SAMP>
The last and most powerful of the "a nearby object satisfying some condition''
tokens.  When determining whether an object passes this test, the parser
sets the variable <TT>noun</TT> to the object in question and calls the routine.
If it returns true, the parser accepts the object, and otherwise it rejects it.
For example, the following should only apply to animals kept in a cage:
<PRE>
[ CagedCreature;
    if (noun in wicker_cage) rtrue; rfalse;
];
Verb "free" "release"
                * noun=CagedCreature        -&#62; FreeAnimal;
</PRE>

So that only nouns which pass the <TT>CagedCreature</TT> test are allowed.
The <TT>CagedCreature</TT> routine can appear anywhere in the code, though
it's tidier to keep it nearby.
<P>

<P><TABLE Border><TR><TD><TT>scope = </TT><I><B>&#60;Routine&#62;</B></I></TABLE><SAMP>            </SAMP>
An even more powerful token, which means "an object in scope'' where
scope is redefined specially.  See the next section.
<P>

<P><TABLE Border><TR><TD><TT>number</TT></TABLE><SAMP>            </SAMP> Matches any decimal number from 0 upwards
(though it rounds off large numbers to 10000), and also matches the numbers
"one'' to "twenty'' written in English.  For example:
<PRE>
Verb "type"
                * number                    -&#62; TypeNum;
</PRE>

causes actions like <TT>Typenum 504</TT> when the player types "type 504''.  Note
that <TT>noun</TT> is set to 504, not to an object.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex68"><B>EXERCISE 68:</B><BR>(link to <A HREF="answers2/answer68.html">the answer</A>)<TR><TD><TD>  (A beautiful feature stolen from David M. Baggett's game
'The Legend Lives', which uses it to great effect.)  Some games produce
footnotes every now and then.  Arrange matters so that these are
numbered <TT>[1]</TT>, <TT>[2]</TT> and so on in order of appearance, to be read by the
player when "footnote 1'' is typed.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> 
The entry point <TT>ParseNumber</TT> allows you to provide your own
number-parsing routine, which opens up many sneaky possibilities --
Roman numerals, coordinates like "J4", very long telephone numbers
and so on.  This takes the form
<PRE>
[ ParseNumber buffer length;
  ...returning 0 if no match is made, or the number otherwise...
];
</PRE>

and examines the supposed 'number' held at the byte address <TT>buffer</TT>,
a row of characters of the given <TT>length</TT>.  If you provide a <TT>ParseNumber</TT>
routine but return 0 from it, then the parser falls back on its usual
number-parsing mechanism to see if that does any better.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Note that <TT>ParseNumber</TT> can't return 0 to mean the number zero.
Probably "zero'' won't be needed too often, but if it is you can
always return some value like 1000 and code the verb in question to
understand this as 0.  (Sorry: this was a poor design decision made
too long ago to change now.)
</SMALL>
<TR><TD><TD><P>

<P><TABLE Border><TR><TD><I><B>&#60;Routine&#62;</B></I></TABLE><SAMP>            </SAMP>
The most flexible token is simply the name of a "general parsing routine''. 
This looks at the word stream using <TT>NextWord</TT> and <TT>wn</TT> (see <A HREF="section24.html">Section 24</A>) and
should return:
<BLOCKQUOTE>
-1<SAMP>      </SAMP> if the text isn't understood,<BR>
0<SAMP>      </SAMP> if it's understood but no parameter results,<BR>
1<SAMP>      </SAMP> if a number results, or<BR>
<I>n</I><SAMP>      </SAMP> if the object <I>n</I> results.<BR>
</BLOCKQUOTE>

In the case of a number, the actual value should be put into the variable
<TT>parsed_number</TT>.
On an unsuccessful match (returning -1) it doesn't matter what the final
value of <TT>wn</TT> is.  On a successful match it should be left pointing to the next
thing <I> after</I> what the routine understood.  Since <TT>NextWord</TT> moves
<TT>wn</TT> on by one each time it is called, this happens automatically unless
the routine has read too far.  For example:
<PRE>
[ OnAtorIn w;
  w=NextWord(); if (w=='on' or 'at' or 'in') return 0;
  return -1;
];
</PRE>

makes a token which accepts any of the words "on", "at" or "in" as
prepositions (not translating into objects or numbers).  Similarly,
<PRE>
[ Anything w;  while (w~=-1) w=NextWordStopped(); return 0; ];
</PRE>

accepts the entire rest of the line (ignoring it).  
<TT>NextWordStopped</TT> is a form of <TT>NextWord</TT> which returns -1 once the
original word stream has run out.
<P>

<P><TABLE Border><TR><TD><TT>topic</TT></TABLE><SAMP>            </SAMP>
This token matches as much text as possible.
It should either be at the end of its grammar line, or
be followed by a preposition.  (The only way it can fail
to match is if it finds no text at all.)  The library's
grammar uses this token for topics of conversation and
topics looked up in books (see \S<A HREF="section15.html">Section 15</A>, 16), hence the
name.  The parser ignores the text for now (your own code
will have to think about it later), and simply sets
the variables <TT>consult_from</TT> to the number of the first word
of the matched text and <TT>consult_words</TT> to the number of words.
<P>
<P>

<TABLE Border><TR><TD><TT>special</TT></TABLE><SAMP>            </SAMP> Obsolete and best avoided.
<P>
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex69"><B>EXERCISE 69:</B><BR>(link to <A HREF="answers2/answer69.html">the answer</A>)<TR><TD><TD> Write a token to detect low numbers in French, "un''
to "cinq''.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dexercise.gif" ALT="??/\"><TD bgcolor="#FBB9AC"><A NAME="ex70"><B>EXERCISE 70:</B><BR>(link to <A HREF="answers2/answer70.html">the answer</A>)<TR><TD><TD> Write a token to detect floating-point numbers
like "21'', "5.4623'', "two point oh eight'' or "0.01'',
rounding off to two
decimal places.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dexercise.gif" ALT="??/\"><TD bgcolor="#FBB9AC"><A NAME="ex71"><B>EXERCISE 71:</B><BR>(link to <A HREF="answers2/answer71.html">the answer</A>)<TR><TD><TD>  Write a token to match a phone number,
of any length from 1 to 30 digits, possibly broken up
with spaces or hyphens (such as "01245 666
737'' or "123-4567'').

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex72"><B>EXERCISE 72:</B><BR>(link to <A HREF="answers2/answer72.html">the answer</A>)<TR><TD><TD> (Adapted from code in Andrew Clover's
'timewait.h' library extension.)
Write a token to match any description of a time of day,
such as "quarter past five'', "12:13 pm'', "14:03'',
"six fifteen'' or "seven o'clock''.

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dexercise.gif" ALT="??/\"><TD bgcolor="#FBB9AC"><A NAME="ex73"><B>EXERCISE 73:</B><BR>(link to <A HREF="answers2/answer73.html">the answer</A>)<TR><TD><TD>  Code a spaceship control panel with five
sliding controls, each set to a numerical value, so that
the game looks like:

<PRE>
&#62;look
Machine Room
There is a control panel here, with five slides, each of which can be
set to a numerical value.
&#62;push slide one to 5
You set slide one to the value 5.
&#62;examine the first slide
Slide one currently stands at 5.
&#62;set four to six
You set slide four to the value 6.
</PRE>
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> General parsing routines sometimes need to get at the raw
text originally typed by the player.  Usually <TT>WordAddress</TT> and
<TT>WordLength</TT> (see <A HREF="section24.html">Section 24</A>) are adequate.  If not, it's helpful to know
that the parser keeps a <TT>string</TT> array called <TT>buffer</TT> holding:
<BLOCKQUOTE>
<TT>buffer-&#62;0</TT> <I>=</I> <I><B>&#60;maximum number of characters which can fit in buffer&#62;</B></I><BR>
<TT>buffer-&#62;1</TT> <I>=</I> <I><B>&#60;the number <I>n</I> of characters typed&#62;</B></I><BR>
<TT>buffer-&#62;2</TT>...<TT>buffer-&#62;</TT>
(n+1)
<I>=</I> <I><B>&#60;the text typed&#62;</B></I><BR>
</BLOCKQUOTE>


and, in parallel with this, another one called <TT>parse</TT> holding:
<BLOCKQUOTE>
<TT>parse-&#62;0</TT> <I>=</I> <I><B>&#60;maximum number of words which can fit in buffer&#62;</B></I><BR>
<TT>parse-&#62;1</TT> <I>=</I> <I><B>&#60;the number <I>m</I> of words typed&#62;</B></I><BR>
<TT>parse-&#62;2</TT>... <I>=</I> <I><B>&#60;a four-byte block for each word, as follows&#62;</B></I><BR>
<SAMP>            </SAMP> <TT>block--&#62;0</TT> <I>=</I> <I><B>&#60;the dictionary entry if word is known, 0 otherwise&#62;</B></I><BR>
<SAMP>            </SAMP> <TT>block-&#62;2</TT> <I>=</I> <I><B>&#60;number of letters in the word&#62;</B></I><BR>
<SAMP>            </SAMP> <TT>block-&#62;3</TT> <I>=</I> <I><B>&#60;index to first character in the <TT>buffer</TT>&#62;</B></I><BR>
</BLOCKQUOTE>

(However, for version 3 games the format is slightly different:
in <TT>buffer</TT> the text begins at byte 1, not at byte 2, and its end
is indicated with a zero terminator byte.)  Note that the raw text
is reduced to lower case automatically, even if within quotation marks.
Using these buffers directly is perfectly safe but not recommended
unless there's no other way, as it tends to make code rather illegible.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex74"><B>EXERCISE 74:</B><BR>(link to <A HREF="answers2/answer74.html">the answer</A>)<TR><TD><TD> Try to implement the parser's routines <TT>NextWord</TT>,
<TT>WordAddress</TT> and <TT>WordLength</TT>.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex75"><B>EXERCISE 75:</B><BR>(link to <A HREF="answers2/answer75.html">the answer</A>)<TR><TD><TD> (Difficult.)  Write a general parsing routine accepting
any amount of text (including spaces, full stops and commas)
between double-quotes as a single token.

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex76"><B>EXERCISE 76:</B><BR>(link to <A HREF="answers2/answer76.html">the answer</A>)<TR><TD><TD> How would you code a general parsing routine which
never matches anything?

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex77"><B>EXERCISE 77:</B><BR>(link to <A HREF="answers2/answer77.html">the answer</A>)<TR><TD><TD> Why would you code a general parsing routine which
never matches anything?
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dexercise.gif" ALT="??/\"><TD bgcolor="#FBB9AC"><A NAME="ex78"><B>EXERCISE 78:</B><BR>(link to <A HREF="answers2/answer78.html">the answer</A>)<TR><TD><TD>  An apparent restriction of the parser is that it only
allows two parameters (<TT>noun</TT> and <TT>second</TT>).  Write a general parsing
routine to accept a <TT>third</TT>.  (This final exercise with general parsing
routines is easier than it looks: see the specification of the <TT>NounDomain</TT>
library routine in <A HREF="sectionA9.html">Appendix A9</A>.)

</TABLE>
<HR><A HREF="contents.html">Contents</A> / <A HREF="section26.html">Back</A> / <A HREF="section28.html">Forward</A> <BR>
<A HREF="chapter1.html">Chapter I</A> / <A HREF="chapter2.html">Chapter II</A> / <A HREF="chapter3.html">Chapter III</A> / <A HREF="chapter4.html">Chapter IV</A> / <A HREF="chapter5.html">Chapter V</A> / <A HREF="chapter6.html">Chapter VI</A> / <A HREF="chapterA.html">Appendix</A><HR><SMALL><I>Mechanically translated to HTML from third edition as revised 16 May 1997. Copyright &#169; Graham Nelson 1993, 1994, 1995, 1996, 1997: all rights reserved.</I></SMALL></BODY></HTML>
