<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>DM4 &#167;A3: Library routines</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="dm4.css">
</head>
<body>
<p class="navbar">
 <a href="index.html">home</a> /
 <a href="contents.html">contents</a> /
 <a href="app.html">appendices</a> /
 <a href="sa2.html" title="&#167;A2: Library properties">prev</a> /
 <a href="sa4.html" title="&#167;A4: Library message numbers">next</a> /
 <a href="dm4index.html">index</a>
</p>
<div class="page">
<a id="p429" name="p429"></a>
<h2>&#167;A3 &nbsp; Library routines</h2>

<p class="normal">The Inform library files contain about three hundred 
routines, almost all of which are &#8220;private&#8221; in the sense 
that they are difficult for designers to use, not useful anyway, and 
subject to change without notice as the library is maintained and 
rewritten. The routines in this appendix are those which are &#8220;open 
to the public&#8221;. Designers are encouraged to make use of them.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>Achieved(tasknum)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s22.html">&#167;22</a></td></tr>
</table>
<p class="normal">Signals to the library that task number <code>tasknum</code> 
has been achieved, so that points may be awarded if it has not been 
achieved before.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>AfterRoutines()</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s6.html">&#167;6</a></td></tr>
</table>
<p class="normal">This should be called in the action routine, such 
as <code>TakeSub</code>, of a group 2 action, such as <code>Take</code>, 
once the action has taken place but before anything is printed. It 
runs through the <code>after</code> rules as laid out in 
<a href="s6.html">&#167;6</a>.<br>
<i>Routine returns</i> &nbsp; <code>true</code> if 
the action has been interrupted by some other rule, <code>false</code> 
if not.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>AllowPushDir()</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s15.html">&#167;15</a></td></tr>
</table>
<p class="normal">Used only inside the <code>before</code> rule for a 
<code>PushDir</code> action, this routine signals to the library that 
the attempt to push an object from one place to another should be allowed.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>Banner()</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s21.html">&#167;21</a></td></tr>
</table>
<p class="normal">Prints the game banner. Normally unnecessary, but 
should be used soon after if your game suppresses the banner at the 
<code>Initialise</code> stage.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>ChangePlayer(obj,flag)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s21.html">&#167;21</a></td></tr>
</table>
<p class="normal">Cause the player at the keyboard to play as the given 
object <code>obj</code>, which must provide a <code>number</code> 
property. If the <code>flag</code> is <code>true</code>, then subsequently print 
messages like &#8220;(as Ford Prefect)&#8221; in room description 
headers. This routine, however, prints nothing itself.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>CommonAncestor(obj1,obj2)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s3.html">&#167;3</a></td></tr>
</table>
<p class="normal">A routine used internally by the library when working 
out visibilities, and which might as well be available for public use. 
Returns the nearest object in the object tree which (directly or 
indirectly) contains both <code>obj1</code> and <code>obj2</code>, or 
else returns <code>nothing</code> if no such object exists. For 
instance if Bedquilt contains bottle and the player is carrying a lamp,
the common ancestor of lamp and bottle is Bedquilt.<br>
<i>Routine returns</i> &nbsp; The common ancestor or 
<code>nothing</code>.</p>

<p class="lynxonly"></p>
<a id="p430" name="p430"></a>
<table class="sa2">
<tr class="r1"><td class="c1"><code>DictionaryLookup(word,length)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s34.html">&#167;34</a></td></tr>
</table>
<p class="normal">Takes the word stored character by character in the 
array <code>word-&gt;0</code>, <code>word-&gt;1</code>, &#8230;,
<code>word-&gt;(length-1)</code> and looks it up in the story file's 
dictionary.<br>
<i>Routine returns</i> &nbsp; The dictionary value 
(e.g., <code>'t'</code>, <code>'a'</code>, <code>'k'</code>, 
<code>'e'</code> will return <code>'take'</code>) or zero if the word 
isn't in the dictionary.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>GetGNAOfObject(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s37.html">&#167;37</a></td></tr>
</table>
<p class="normal">Determines the gender-number-animation of the short 
name of the given object <code>obj</code>.<br>
<i>Routine returns</i> &nbsp; The GNA, which is 
a number between 0 and 11: see table of GNA values in 
<a href="s34.html">&#167;34</a>.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>HasLightSource(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s19.html">&#167;19</a></td></tr>
</table>
<p class="normal">Determines whether or not <code>obj</code> &#8220;has light&#8221;, 
i.e., casts light outward to objects containing <code>obj</code>: see 
<a href="s19.html">&#167;19</a> for a more exact definition.<br>
<i>Routine returns</i> &nbsp; <code>true</code> 
or <code>false</code>.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>IndirectlyContains(obj1,obj2)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s3.html">&#167;3</a></td></tr>
</table>
<p class="normal">The condition <code>obj2 in obj1</code> only tests whether 
<code>obj2</code> is directly contained in <code>obj1</code>, so
that <code>lamp in player</code> would fail if the lamp were in a 
rucksack carried by the player. <code>IndirectlyContains(player,lamp)</code> 
would return <code>true</code>. Formally, the test is whether
<code>obj2</code> is a child of <code>obj1</code>, or is a child of 
a child of <code>obj1</code>, or &#8230; and so on. See also the
library routine <code>CommonAncestor</code> above.<br>
<i>Routine returns</i> &nbsp; <code>true</code> or 
<code>false</code>.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>IsSeeThrough(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s19.html">&#167;19</a></td></tr>
</table>
<p class="normal">Determines whether or not <code>obj</code> &#8220;is 
see-through&#8221;, i.e., allows light to pass through it. An object is 
see-through if it has <code>transparent</code>, or <code>supporter</code>, 
or <code>enterable</code> (unless it is also a closed <code>container</code>).<br>
<i>Routine returns</i> &nbsp; <code>true</code> 
or <code>false</code>.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>Locale(obj,tx1,tx2)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s26.html">&#167;26</a></td></tr>
</table>
<p class="normal">Prints out the paragraphs of room description which 
would appear if <code>obj</code> were the room: i.e., prints out 
descriptions of objects in <code>obj</code> according to the usual rules. 
After describing the objects which have their own paragraphs, a list 
is given of the remaining ones. The string <code>tx1</code> is printed 
if there were no previous paragraphs, and the string <code>tx2</code>
otherwise. (For instance, you might want &#8220;On the ledge you can 
see&#8221; and &#8220;On the ledge you can also see&#8221;.) After 
the list, nothing else is printed, not even a full stop.<br>
<i>Routine returns</i> &nbsp; The number of objects 
printed in the list, possibly zero.</p>

<p class="lynxonly"></p>
<a id="p431" name="p431"></a>
<table class="sa2">
<tr class="r1"><td class="c1"><code>LoopOverScope(R,actor)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s32.html">&#167;32</a></td></tr>
</table>
<p class="normal">Calls routine <code>R(obj)</code> for each object 
<code>obj</code> in scope for the given <code>actor</code>. If no 
<code>actor</code> is given, the actor is assumed to be the player.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>LTI_Insert(position,character)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s36.html">&#167;36</a></td></tr>
</table>
<p class="normal">Inserts the given <code>character</code> at the given 
<code>position</code> in the standard library array <code>buffer</code>
used to hold the text typed by the player, moving subsequent text along 
to make room. (This is protected against overflowing the buffer.)<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>MoveFloatingObjects()</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s8.html">&#167;8</a></td></tr>
</table>
<p class="normal">&#8220;Floating objects&#8221; is Inform library jargon 
for &#8220;objects which use <code>found_in</code> to be present in 
several locations at once&#8221;. This routine adjusts the positions 
of objects across the whole game, ensuring that they are consistent 
with the current states of the property <code>found_in</code> and 
the attribute <code>absent</code>, and should be called after any 
game event which has changed these states.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>NextWord()</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s28.html">&#167;28</a></td></tr>
</table>
<p class="normal">Finds the next dictionary word in the player's input, 
that is, the word at position <code>wn</code> in the input, moving the 
word number <code>wn</code> on by one. (The first word is at position 1.)<br>
<i>Routine returns</i> &nbsp; The dictionary value, 
or 0 if the word is not in the dictionary or if the word stream has 
run out, or the constant <code>THEN1__WD</code> if the &#8220;word&#8221; 
was a full stop, or the constant <code>COMMA_WORD</code> if it was 
a comma.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>NextWordStopped()</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s28.html">&#167;28</a></td></tr>
</table>
<p class="normal">Finds the next dictionary word in the player's input, 
that is, the word at position <code>wn</code> in the input, moving 
the word number <code>wn</code> on by one. (The first word is at position 1.)<br>
<i>Routine returns</i> &nbsp; The dictionary value, 
or 0 if the word is not in the dictionary, or the constant <code>THEN1__WD</code> 
if the &#8220;word&#8221; was a full stop, or the constant <code>COMMA_WORD</code> 
if it was a comma, or &#8722;1 if the word stream has run out.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>NounDomain(o1,o2,type)</code></td>
</tr></table>
<p class="normal">This routine is one of the keystones of the parser, 
but see also <code>ParseToken</code> below: the objects given are the 
domains to search through when parsing, almost always the location 
and the actor, and the <code>type</code> indicates a token. The only 
tokens safely usable are: <code>NOUN_TOKEN</code>, for 
<span class="grammartoken"><code>noun</code></span>, <code>HELD_TOKEN</code>, 
for <span class="grammartoken"><code>held</code></span> and <code>CREATURE_TOKEN</code>, 
for <span class="grammartoken"><code>creature</code></span>. The routine 
parses the best single object name it can from the current position of 
<code>wn</code>.<br>
<i>Routine returns</i> &nbsp; <code>nothing</code> 
for &#8220;no match&#8221;, or the object matched for a success, or
the constant <code>REPARSE_CODE</code> to indicate that it had to ask 
a clarifying question: this 
<a id="p432" name="p432"></a>
reconstructed the input drastically and 
the parser must begin all over again. <code>NounDomain</code> should 
only be used by general parsing routines and these should always return
<code>GPR_REPARSE</code> if <code>NounDomain</code> returned 
<code>REPARSE_CODE</code>, thus passing the buck upwards.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>ObjectIsUntouchable(obj,flag)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s32.html">&#167;32</a></td></tr>
</table>
<p class="normal">Determines whether any solid barrier, that is, any 
<code>container</code> that is not <code>open</code>, lies between 
the player and <code>obj</code>. If <code>flag</code> is <code>true</code>, 
this routine never prints anything; otherwise it prints a message like 
&#8220;You can't, because &#8230; is in the way.&#8221; if any barrier
is found.<br>
<i>Routine returns</i> &nbsp; <code>true</code> if 
a barrier is found, <code>false</code> if not.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>OffersLight(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s19.html">&#167;19</a></td></tr>
</table>
<p class="normal">Determines whether or not <code>obj</code> &#8220;offers 
light&#8221;, i.e., contains light so that its contents are visible 
to each other: see <a href="s19.html">&#167;19</a> for a more exact 
definition.<br>
<i>Routine returns</i> &nbsp; <code>true</code> or <code>false</code>.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>ParseToken(tokentype,tokendata)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s31.html">&#167;31</a></td></tr>
</table>
<p class="normal">This is the library's own &#8220;general parsing routine&#8221;, 
and parses the word stream against the specified token. Because some 
of these tokens require too much setting-up work to parse, and anyway 
are not very useful, only two token types are open to the public. If 
<code>tokentype</code> is <code>ELEMENTARY_TT</code>, then <code>tokendata</code> 
must have one of the following values: <code>NOUN_TOKEN</code>, 
<code>HELD_TOKEN</code>, <code>MULTI_TOKEN</code>, <code>MULTIHELD_TOKEN</code>, 
<code>MULTIEXCEPT_TOKEN</code>, <code>MULTIINSIDE_TOKEN</code>, 
<code>CREATURE_TOKEN</code> and <code>NUMBER_TOKEN</code>. Alternatively, 
<code>tokentype</code> can be <code>SCOPE_TT</code> and <code>tokendata</code> 
must then be a &#8220;scope routine&#8221;.<br>
<i>Routine returns</i> &nbsp; <code>GPR_FAIL</code> if 
parsing fails; <code>GPR_PREPOSITION</code> if a match is made but results 
in no data; <code>GPR_NUMBER</code> if a match is made, resulting in 
a number; <code>GPR_MULTIPLE</code> if a match is made, resulting in 
a multiple object; <code>GPR_REPARSE</code> if the parser has had to
rewrite the text being parsed and would now like parsing to begin again 
from scratch; otherwise, an object which the parser has matched against 
the text.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>PlaceInScope(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s32.html">&#167;32</a></td></tr>
</table>
<p class="normal">Used in &#8220;scope routines&#8221; (only) when 
<code>scope_stage</code> is set to 2 (only). Places <code>obj</code> in 
scope for the token currently being parsed. No other objects are placed 
in scope as a result of this, unlike the case of <code>ScopeWithin</code>.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>PlayerTo(obj,flag)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s21.html">&#167;21</a></td></tr>
</table>
<p class="normal">Moves the player to <code>obj</code>, which can either 
be a location or something <code>enterable</code>. If <code>flag</code> 
is <code>false</code>, then run a <code>Look</code> action to print 
out a room description: but if <code>flag</code> is <code>true</code>, 
print nothing, and if <code>flag</code> is 2, print a room description 
but abbreviate it if the room has been visited before.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<a id="p433" name="p433"></a>
<table class="sa2">
<tr class="r1"><td class="c1"><code>PronounNotice(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s33.html">&#167;33</a></td></tr>
</table>
<p class="normal">Resets the pronouns to the object <code>obj</code>. 
This means that all pronouns which can match against the object are 
set equal to it: for instance, &#8220;Aunt Jemima&#8221; would match 
<code>'her'</code> but not <code>'it'</code>, &#8220;the grapes&#8221; 
would match <code>'them'</code> and so on.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>PronounValue(pronoun)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s33.html">&#167;33</a></td></tr>
</table>
<p class="normal">Finds the current setting of <code>pronoun</code>, which 
has to be the dictionary value of a legal pronoun in the current language: 
in the case of English, that means <code>'it'</code>, <code>'him'</code>, 
<code>'her'</code> or <code>'them'</code>.<br>
<i>Routine returns</i> &nbsp; The setting, or 
<code>nothing</code> if it is unset.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>ScopeWithin(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s32.html">&#167;32</a></td></tr>
</table>
<p class="normal">Used in &#8220;scope routines&#8221; (only) when 
<code>scope_stage</code> is set to 2 (only). Places the contents 
of <code>obj</code> in scope for the token currently being parsed, 
and applies the rules of scope recursively so that contents of see-through 
objects are also in scope, as is anything added to scope.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>SetPronoun(pronoun,obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s33.html">&#167;33</a></td></tr>
</table>
<p class="normal">Changes the current setting of <code>pronoun</code>, 
which has to be the dictionary value of a legal pronoun in the current 
language: in the case of English, that means <code>'it'</code>, 
<code>'him'</code>, <code>'her'</code> or <code>'them'</code>.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>SetTime(time,rate)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s20.html">&#167;20</a></td></tr>
</table>
<p class="normal">Set the game clock (a 24-hour clock) to the given 
<code>time</code> (in seconds since the start of the day), to run 
at the given rate <i>r</i>: <i>r</i> = 0 means it does not run, if 
<i>r</i> &gt; 0 then <i>r</i> seconds pass every turn, if <i>r</i> &lt; 
0 then &#8722;<i>r</i> turns pass every second.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>StartDaemon(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s20.html">&#167;20</a></td></tr>
</table>
<p class="normal">Makes the daemon of the object <code>obj</code> active, 
so that its <code>daemon</code> routine will be called at the end 
of every turn.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>StartTimer(obj,period)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s20.html">&#167;20</a></td></tr>
</table>
<p class="normal">Makes the timer of the object <code>obj</code> active. 
Its <code>time_left</code> property is set initially to <code>period</code>, 
then decreased by 1 at the end of every turn in which it was positive. 
At the end of the turn when it was zero, the timer is stopped and 
the object's <code>time_out</code> property is called.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<a id="p434" name="p434"></a>
<table class="sa2">
<tr class="r1"><td class="c1"><code>StopDaemon(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s20.html">&#167;20</a></td></tr>
</table>
<p class="normal">Makes the daemon of the object <code>obj</code> no 
longer active, so that its <code>daemon</code> routine will no
longer be called at the end of every turn.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>StopTimer(obj)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s20.html">&#167;20</a></td></tr>
</table>
<p class="normal">Makes the timer of the object <code>obj</code> no 
longer active, so that its <code>time_left</code> routine will no 
longer be decreased and <code>time_out</code> will not be called 
as originally scheduled.<br>
<i>No return value</i></p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>TestScope(obj,actor)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s32.html">&#167;32</a></td></tr>
</table>
<p class="normal">Tests whether the object <code>obj</code> is in scope 
to the given <code>actor</code>. If no <code>actor</code> is given, 
the actor is assumed to be the player.<br>
<i>Routine returns</i> &nbsp; <code>true</code> or 
<code>false</code>.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>TryNumber(wordnum)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s28.html">&#167;28</a></td></tr>
</table>
<p class="normal">Tries to parse the word at <code>wordnum</code> as 
a non-negative number, recognising decimal numbers and English ones 
from &#8220;one&#8221; to &#8220;twenty&#8221;.<br>
<i>Routine returns</i> &nbsp; &#8722;1000 if it fails 
altogether, or the number, except that values exceeding 10000 are rounded 
down to 10000.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>UnsignedCompare(a,b)</code></td>
</tr></table>
<p class="normal">The usual <code>&gt;</code> condition performs 
a signed comparison, and occasionally, usually when comparing addresses 
in memory of routines or strings, you need an unsigned comparison.<br>
<i>Routine returns</i> &nbsp; Returns 1 if <i>a</i> 
&gt; <i>b</i>, 0 if <i>a</i> = <i>b</i> and &#8722;1 if <i>a</i> &lt; 
<i>b</i>, regarding <i>a</i> and <i>b</i> as unsigned numbers between 
0 and 65535. (That is, regarding <code>-1</code> as 65535, <code>-2</code> 
as 65534, &#8230;, <code>-32768</code> as 32768.)</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>WordAddress(wordnum)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s28.html">&#167;28</a></td></tr>
</table>
<p class="normal">Find where word number <code>wordnum</code> from what 
the player typed is stored.<br>
<i>Routine returns</i> &nbsp; The <code>-&gt;</code> 
array holding the text of the word.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>WordInProperty(word,obj,prop)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s34.html">&#167;34</a></td></tr>
</table>
<p class="normal">Tests whether <code>word</code> is one of the dictionary 
values listed in the array given as the property <code>prop</code> of object 
<code>obj</code>. (Most often used to see if a given dictionary word is 
one of the <code>name</code> values.)<br>
<i>Routine returns</i> &nbsp; <code>true</code> or <code>false</code>.</p>

<p class="lynxonly"></p>
<a id="p435" name="p435"></a>
<table class="sa2">
<tr class="r1"><td class="c1"><code>WordLength(wordnum)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s28.html">&#167;28</a></td></tr>
</table>
<p class="normal">Find the length (number of letters) of the word 
numbered <code>wordnum</code> from what the player typed.<br>
<i>Routine returns</i> &nbsp; The length.</p>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>WriteListFrom(obj,st)</code> &nbsp;</td>
<td class="c2"><i>see</i> <a href="s27.html">&#167;27</a></td></tr>
</table>
<p class="normal">Write a list of <code>obj</code> and its siblings, 
with the style being <code>st</code>. To list all the objects inside
<code>X</code>, list from <code>child(X)</code>. The style is made 
up by adding together some of the following constants:</p>
<p class="lynxonly"></p>
<div class="inset"><table>
<tr><td><code>NEWLINE_BIT</code></td><td>New-line after each entry</td></tr>
<tr><td><code>INDENT_BIT</code></td><td>Indent each entry according to depth</td></tr>
<tr><td><code>FULLINV_BIT</code></td><td>Full inventory information after entry</td></tr>
<tr><td><code>ENGLISH_BIT</code></td><td>English sentence style, with commas and &#8216;and&#8217;</td></tr>
<tr><td><code>RECURSE_BIT</code></td><td>Recurse downwards with usual rules</td></tr>
<tr><td><code>ALWAYS_BIT</code></td><td>Always recurse downwards</td></tr>
<tr><td><code>TERSE_BIT</code></td><td>More terse English style</td></tr>
<tr><td><code>PARTINV_BIT</code></td><td>Only brief inventory information after entry</td></tr>
<tr><td><code>DEFART_BIT</code></td><td>Use the definite article in list</td></tr>
<tr><td><code>WORKFLAG_BIT</code></td><td>At top level (only), only list objects which have the <code>workflag</code> attribute</td></tr>
<tr><td><code>ISARE_BIT</code></td><td>Prints &#8220; is &quot; or &#8220; are &quot; before list</td></tr>
<tr><td><code>CONCEAL_BIT</code></td><td>Misses out <code>concealed</code> or <code>scenery</code> objects</td></tr>
</table></div>

<p class="lynxonly"></p>
<table class="sa2">
<tr class="r1"><td class="c1"><code>YesOrNo()</code></td>
</tr></table>
<p class="normal" style="margin-bottom:1em">Assuming that a question has already been printed, 
wait for the player to type &#8220;yes&#8221;, &#8220;y&#8221;, &#8220;no&#8221; 
or &#8220;n&#8221;.<br>
<i>Routine returns</i> &nbsp; <code>true</code> 
for &#8220;yes&#8221; or &#8220;y&#8221;, <code>false</code> for 
&#8220;no&#8221; or &#8220;n&#8221;.</p>

</div>
<p class="navbar">
 <a href="index.html">home</a> /
 <a href="contents.html">contents</a> /
 <a href="app.html">appendices</a> /
 <a href="sa2.html" title="&#167;A2: Library properties">prev</a> /
 <a href="sa4.html" title="&#167;A4: Library message numbers">next</a> /
 <a href="dm4index.html">index</a>
</p>
</body>
</html>

