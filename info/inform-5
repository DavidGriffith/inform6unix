This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Actions and Reactions,  Prev: Messages and Classes,  Up: Fundamentals

Actions and reactions
=====================

     Only the actions of the just
     Smell sweet and blossom in their dust.
     
     -- James Shirley (1594-1666), The Contention of Ajax and Ulysses

     ...a language obsessed with action, and with the joy of seeing
     action multiply from action, action marching relentlessly ahead
     and with yet more actions filing in from either side to fall into
     neat step at the rear, in a long straight rank of cause and
     effect, to what will be inevitable, the only possible end.

     -- Donna Tartt, The Secret History

Inform is a language obsessed with actions.  An `action' is an attempt
to perform one simple task: for instance,

     Inv         Take sword        Insert gold_coin cloth_bag

are all examples.  Here the actual actions are Inv, Take and Insert.
An action has 0, 1 or 2 objects supplied with it (or, in a few special
cases, some numerical information rather than objects).  Most actions
are triggered off by the game's parser: in fact, the parser's job can
be summed up as reducing the player's keyboard commands to actions.
Sometimes one action causes another; a really complicated keyboard
command ("empty the sack into the umbrella stand") may fire off quite a
sequence of actions.

   An action is only an attempt to do something: it may not succeed.
Firstly, a before rule might interfere, as we have seen already.
Secondly, the action might not even be very sensible.  The parser will
happily generate the action Eat iron_girder if the player asked to do
so in good English.  In this case, even if no before rule interferes,
the normal game rules will ensure that the girder is not consumed.

   Actions can also be generated by your own code, and this perfectly
simulates the effect of a player typing something.  For example,
generating a Look action makes the game produce a room description as
if the player had typed "look".  More subtly, suppose the air in the
Pepper Room causes the player to sneeze each turn and drop something at
random.  This could be programmed directly, with objects being moved
onto the floor by explicit move statements.  But then suppose the game
also contains a toffee apple, which sticks to the player's hands.
Suddenly the toffee apple problem has an unintended solution.  So
rather than moving the objects directly to the floor, the game should
generate Drop actions.  The result might read:

     You sneeze convulsively, and lose your grip on the toffee apple...
     The toffee apple sticks to your hand!

which is at least consistent.

   As an example of causing actions, an odorous low_mist will soon
settle over `Ruins'.  It will have the description "The mist carries a
rich aroma of broth."  The alert player who reads this will immediately
type "smell mist", and we want to provide a better response than the
game's stock reply "You smell nothing unexpected."  An economical way
of doing this is to somehow deflect the action Smell low_mist into the
action Examine low_mist instead, so that the "aroma of broth" message is
printed in this case too.  Here is a suitable before rule to do that:

         Smell: <Examine self>; rtrue;

The statement <Examine self> causes the action Examine low_mist to be
triggered off immediately, after which whatever was going on at the time
resumes.  In this case, the action Smell low_mist resumes, but since we
immediately return true the action is stopped dead.

   Causing an action and then returning true (i.e., causing a new action
and killing the old one) is so useful that it has an abbreviation,
putting the action in double angle-brackets.  For example,

         <Look>; <<ThrowAt smooth_stone spider>>;

will behave as if the player has asked to look around and to throw the
stone at the spider, and will then return true.

At any given time, just one action is under way (though others may be
waiting to resume when the current one has finished).  This current
action is stored in the three variables

         action      noun      second

noun and second hold the objects involved, or the special value nothing
if they aren't involved at all.  action holds the kind of action.  Its
possible values can be referred to in the program using the ##
notation: for example

         if (action == ##Look) ...

tests to see if the current action is a Look.

!! Why have ## at all, why not just write Look?  Partly because this
way the reader can see at a glance that an action type is being
referred to, but also because the name might be wanted for something
else.  For instance there's a variable called score (holding the
current game score), quite different from the action type ##Score.

!!!! For a few actions, the `noun' (or the `second noun') is actually a
number (for instance, "set timer to 20" would probably end up with noun
being timer and second being 20).  Occasionally one needs to be sure of
the difference, e.g., to tell if second is holding a number or an
object.  It's then useful to know that there are two further variables,
inp1 and inp2, parallel to noun and second and usually equal to them --
but equal to 1 to indicate "some numerical value, not an object".

The library supports about 120 different actions and any game of serious
proportion will add some more of its own.  This list is initially
daunting but many are used only rarely and others are always knocked
down into simpler actions (for example, <Empty rucksack table>, meaning
"empty the contents of the rucksack onto the table", is broken down into
a stream of actions like <Remove fish rucksack> and <PutOn fish table>).
It's useful to know that an object can only enter the player's
possession through a Take or Remove action: block those two and it can
never be acquired whatever the player types.

   The list of actions is traditionally divided into three groups,
called Group 1, Group 2 and Group 3.  Group 1 contains `meta' actions
for controlling the game, like Score and Save, which are treated quite
differently from other actions and are not worth listing.  Of the rest,
actions which normally do something form Group 2, while actions which
normally only print a polite refusal form Group 3.  Group 2 contains:

Inv, Take, Drop, Remove, PutOn, Insert, Enter, Exit, Go, Look, Examine,
Unlock, Lock, SwitchOn, SwitchOff, Open, Close, Disrobe, Wear, Eat, Search.

It should be apparent why these do something.  However, an action like
Listen falls into Group 3: the library would normally respond to it by
printing "You hear nothing unexpected."  Only if your program
interferes (using a before rule) can anything happen.  Group 3 contains,
in rough order of usefulness:

Pull, Push, PushDir [push object in direction], Turn,
Consult, LookUnder [look underneath something], Search,
Listen, Taste, Drink, Touch, Smell,
Wait, Sing, Jump [jump on the spot], JumpOver, Attack,
Swing [something], Blow, Rub, Set, SetTo, Wave [something],
Burn, Dig, Cut, Tie, Fill, Swim, Climb, Buy, Squeeze,
Pray, Think, Sleep, Wake, WaveHands [i.e., just "wave"],
WakeOther [person], Kiss, Answer, Ask, ThrowAt,
Yes, No, Sorry, Strong [swear word], Mild [swear word]

!! Actions involving other people, like Kiss, are often best dealt with
by a life rule, which will be discussed in *Note Living Creatures::.

!! A few actions (e.g., Transfer, Empty, GetOff) are omitted from the
list above because they're always translated into more familiar ones.
For instance, InvWide (asking for a "wide--format" inventory listing)
always ends up in an Inv.

!!!! The Search action (generated by "look inside <container>" or
"search <something>") only ever prints text, but is in Group 2 rather
than Group 3 because it does something substantial.  It decides whether
something is a container, and if there's enough light to see by, it
prints out the contents.  Thus, a before rule applied to Search traps
the searching of random scenery, while an after can be used to alter
the contents-listing rules of containers.

!!!! Most of the group 2 actions -- specifically,

Take, Drop, Insert, PutOn, Remove, Enter, Exit, Go, Unlock, Lock,
SwitchOn, SwitchOff, Open, Close, Wear, Disrobe, Eat

can happen "silently".  If the variable keep_silent is set to 1, then
these actions print nothing in the event of success.  (E.g., if the
door was unlocked as requested.)  They print up objections as usual if
anything goes wrong (e.g., if the suggested key doesn't fit).  This is
useful to implement implicit actions: for instance, to code a door
which will be automatically unlocked by a player asking to go through
it, who is holding the right key.

The standard stock of actions is easily added to.  Two things are
necessary to create a new action: first one must provide a routine to
make it happen.  For instance:

[ BlorpleSub;
  "You speak the magic word ~Blorple~. Nothing happens.";
];

Every action has to have a "subroutine" like this, the name of which is
always the name of the action with Sub appended.  Secondly, one must
add grammar so that Blorple can actually be called for.  Far more about
grammar in Chapter V: for now we add the simplest of all grammar lines,
a directive

Verb "blorple" *                            -> Blorple;

placed after the inclusion of the Grammar file.  (The spacing around
the * is just a matter of convention.)  The word "blorple" can now be
used as a verb.  It can't take any nouns, so the parser will complain
if the player types "blorple daisy".

   Blorple is now a typical Group 3 action.  before rules can be
written for it, and it can be triggered off by a statement like

       <Blorple>;

!!!! To make it a Group 1 action, define the verb as meta (*note
Parsing Verbs::.).

!!!! To make it a Group 2 action, rewrite the subroutine in the
following form:

[ WhateverSub;
  ... do whatever the action is supposed to do,
      printing a suitable message and returning
      if it turns out not to be a sensible thing to do...
  if (AfterRoutines()==1) rtrue;
  ... print a suitable message saying that it has been done ...
];

(AfterRoutines is a library routine which sends suitable after messages
to see if the objects want to prevent the usual message being printed.)

!! A few of the library's actions fall into none of Groups 1, 2 or 3,
though these aren't proper actions at all, but are used only to signal
goings-on.  For instance, when the player types "throw rock at dalek",
the parser generates the action ThrowAt rock dalek.  As usual the rock
is sent a before message asking if it objects to being thrown at a
Dalek.  Since the Dalek may also have an opinion on the matter, another
before message is sent to the Dalek, but this time as if the action
were something called ThrownAt.  For example, here is a dartboard's
response to a dart:

before
[;  ThrownAt: if (noun==dart)
              {   move dart to self; "Triple 20!"; }
              move noun to location;
              print_ret (The) noun, " bounces back off the board.";
],

Such an imaginary action -- usually, as in this case, a perfectly
sensible action seen from the point of view of the second object
involved, rather than the first -- is called a "fake action".  The
important ones are ThrownAt, Receive and LetGo (the latter two being
used for containers: *note Containers::.).

!!!! If you really need to, you can declare a new fake action with the
directive Fake_action <Action-name>;.

!!!! Exercise 3
---------------

   ThrownAt would be unnecessary if Inform had an idea of before and
after routines which an object could provide if it were the second noun
of an action.  How might this be implemented?

   *Note Answer 3::

Actions are processed in a simple way, but one which involves many
little stages.  There are three main stages:

  a. `Before'.  An opportunity for your code to interfere with or block
     altogether what might soon happen.

  b. `During'.  The library takes control and decides if the action
     makes sense according to its normal world model: for example, only
     an edible object may be eaten; only an object in the player's
     possession can be thrown at somebody, and so on.  If the action is
     impossible, a complaint is printed and that's all.  Otherwise the
     action is now carried out.

  c. `After'.  An opportunity for your code to react to what has
     happened, after it has happened but before any text announcing it
     has been printed.  If it chooses, your code can print and cause an
     entirely different outcome.  If your code doesn't interfere, the
     library reports back to the player (with such choice phrases as
     "Dropped.").

!! Group 1 actions (like Score) have no `Before' or `After' stages: you
can't (easily) stop them from taking place.  They aren't happening in
the game's world, but in the player's.

!! The `Before' stage consults your code in five ways, and occasionally
it's useful to know in what order:

  1. The GamePreRoutine is called, if you have written one.  If it
     returns `true', nothing else happens and the action is stopped.

  2. The orders property of the player is called on the same terms.
     For more details, see *Note Living Creatures::.

  3. And the react_before of every object in scope (which roughly means
     `in the vicinity').

  4. And the before of the current room.

  5. If the action has a first noun, its before is called on the same
     terms.

!! The library processes the `During' stage by calling the action's
subroutine.  (Subroutines like TakeSub make up a large part of the
library.)

!! The `After' stage only applies to Group 2 actions, as all Group 3
actions have been packed up at the `During' stage if not `Before'.
During `After' the sequence is as follows: react_after rules for every
object in scope (including the player object); the room's after; the
first noun's after and finally GamePostRoutine.

!!!! Two things are fake about "fake actions" (see above): they don't
have subroutines, and they never occur in the grammar of any verb (so
they're never directly generated by the parser).

!!  As mentioned above, the parser can generate very peculiar actions,
and this sometimes needs to be remembered when writing before rules.
Suppose a before rule intercepts the action of putting the mushroom in
the crate, and makes something exciting happen as a result.  Now even
if the mushroom is, say, sealed up inside a glass jar, the parser might
still generate this action: the impossibility won't be realised until
`During' time.  So the exciting happening should be written as an after
rule, when the attempt to put the mushroom in the crate has already
succeeded.

!! Exercise 4
-------------

   This kind of snag could be avoided altogether if Inform had a
`validation stage' in action processing, to check whether an action is
sensible before allowing it to get as far as before rules.  How could
this be added to Inform?

   *Note Answer 4::

!!!! To some extent you can even meddle with the `During' stage (and
with the final messages produced), and thus even interfere with Group 1
actions if you are unscrupulous enough, by cunning use of the
LibraryMessages system.  See *Note Extending the Library::.

References
----------

   * In a game compiled with the -D switch set, typing in the "actions"
     verb will result in trace information being printed each time any
     action is generated.  Try putting many things into a rucksack and
     asking to "empty" it for an extravagant list.

   * Diverted actions (using << and >>) are commonplace.  They're used
     in about 20 places in `Advent': a good example is the way "take
     water" is translated into a Fill bottle action.

   * Sometimes you want "fake fake actions" which are fully--fledged
     actions (with action routines and so on) but are still never
     generated by the parser (*note Living Creatures::.).


File: inform,  Node: The Model World,  Next: Describing and Parsing,  Prev: Fundamentals,  Up: Top

The Model World
***************

     A Model must be built which will get everything in without a
     clash; and it can do this only by becoming intricate, by mediating
     its unity through a great, and finely ordered, multiplicity.

     -- C. S. Lewis (1898-1963), The Discarded Image

* Menu:

* Places::                      Places, scenery, directions and the map
* Containers::                  Containers, supporters and sub-objects
* Doors::                       Doors, bridges, and ladders
* Switchable Objects::          Things you can turn on and off
* Things to Enter::             Things to enter, travel in and push around
* Reading Matter::              Reading matter and consultation
* Living Creatures::            Living creatures and conversation
* Light and Dark::              The light and the dark
* Daemons::                     Daemons and the passing of time
* Player::                      Starting, moving, changing & killing the player
* Constants and Scoring::       Miscellaneous constants and scoring
* Extending the Library::       Extending and redefining the Library


File: inform,  Node: Places,  Next: Containers,  Prev: The Model World,  Up: The Model World

Places, scenery, directions and the map
=======================================

     It was a long cylinder of parchment, which he unrolled and spread
     out on the floor, putting a stone on one end and holding the other.
     I saw a drawing on it, but it made no sense.

     -- John Christopher (1922-), The White Mountains

Back to `Ruins': what lies at the foot of the stone steps?  We'll now
add four rooms, connected together:

                        Square Chamber --- Web
                              |
                           Corridor
                              |
                            Shrine

with the Square Chamber lying underneath the original Forest location.
For instance, here's the Square Chamber's definition:

Object Square_Chamber "Square Chamber"
  with name "lintelled" "lintel" "lintels" "east" "south" "doorways",
       description
          "A sunken, gloomy stone chamber, ten yards across.  A shaft
           of sunlight cuts in from the steps above, giving the chamber
           a diffuse light, but in the shadows low lintelled doorways to
           east and south lead into the deeper darkness of the Temple.",
       u_to Forest, e_to Web, s_to Corridor,
  has  light;

Like the Forest, this place has light, however dim.  (If it didn't, the
player would never see it, since it would be dark, and the player
hasn't yet been given a lamp or torch of some kind.)  Now although this
is a room, and can't be referred to by the player in the way that a
manipulable object can, it still can have a name property.  These name
words are those which Inform knows "you don't need to refer to", and
it's a convention of the genre that the designer should signpost off
the game in this way.  (Note that they'll only be looked at if what the
player types is unrecognised, so the word "east" is understood quite
normally; but a reference to "east lintel" will get the "don't need to
refer to" treatment.) This room is unfurnished, so:

Object -> "carved inscriptions"
  with name "carved" "inscriptions" "carvings" "marks" "markings" "symbols"
            "moving" "scuttling" "crowd" "of",
       initial
          "Carved inscriptions crowd the walls, floor and ceiling.",
       description "Each time you look at the carvings closely, they seem
           to be still.  But you have the uneasy feeling when you look
           away that they're scuttling, moving about.  Their meaning
           is lost on you.",
  has  static;

This is part of the fittings, hence the static attribute, which means it
can't be taken or moved.  As we went out of our way to describe a shaft
of sunlight, we'll include that as well:

Object -> sunlight "shaft of sunlight"
  with name "shaft" "of" "sunlight" "sun" "light" "beam" "sunbeam" "ray"
            "rays" "sun^s",
       description "The shaft of sunlight glimmers motes of dust in the
           air, making it seem almost solid."
  has  scenery;

(The ^ symbol in "sun^s" means an apostrophe, so the word is "sun's".)
Being scenery makes the object not only static but also not described
by the game unless actually examined by the player.  A true
perfectionist might add a before rule:

       before
       [;  Examine, Search: ;
           default: "It's only an insubstantial shaft of sunlight.";
       ],

so that the player can look at or through the sunlight, but any other
request involving them will be turned down.  Note that a default rule,
if given, means "any action except those already mentioned".

   We can't actually get into the Square Chamber yet, though.  Just
because there is a map connection up from here to the Forest, it
doesn't follow that there's a corresponding connection down.  So we
must add a d_to to the Forest, and while we're at it:

       d_to Square_Chamber,
       u_to "The trees are spiny and you'd cut your hands to ribbons
             trying to climb them.",
       cant_go "The rainforest-jungle is dense, and you haven't hacked
           through it for days to abandon your discovery now.  Really,
           you need a good few artifacts to take back to civilization
           before you can justify giving up the expedition.",

The property cant_go contains what is printed when the player tries to
go in a nonexistent direction, and replaces "You can't go that way".
As is often the case with properties, instead of giving an actual
message you can instead give a routine to print one out, to vary what's
printed with the circumstances.  The Forest needs a cant_go because in
real life one could go in every direction from there: what we're doing
is explaining the game rules to the player: go underground, find some
ancient treasure, then get out to win.  The Forest's u_to property is a
string, not a room; this means that attempts to go up result only in
that string being printed.

Rooms also have rules of their own.  We might add the following before
rule to the Square Chamber:

       before
       [;  Insert:
               if (noun==mushroom && second==sunlight)
               {   remove mushroom;
                  "You drop the mushroom on the floor, in the glare of
                   the shaft of sunlight.  It bubbles obscenely,
                   distends and then bursts into a hundred tiny insects
                   which run for the darkness in every direction.  Only
                   tiny crumbs of fungus remain.";
               }
       ],

The variables noun and second hold the first and second nouns supplied
with an action.  Rooms have before and after routines just as objects
do, and they apply to anything which happens in the given room.  This
particular rule could easily enough have been part of the definition of
the mushroom or the sunlight, and in general a room's rules are best
used only for geographical fixtures.

!!!! Sometimes the room may be a different one after the action has
taken place.  The Go action, for instance, is offered to the before
routine of the room which is being left, and the after routine of the
room being arrived in.  For example:

       after
       [; Go: if (noun==d_obj)
              print "You feel on the verge of a great discovery...^";
       ],

will print the message when its room is entered via the "down"
direction.  Note that since the message is printed with the print
command, there is no "return true" from this routine, so it returns
false: and so the usual game rules resume after the printing of the
message.

Some objects are present in many rooms at once.  The `Ruins', for
instance, are misty:

Object low_mist "low mist"
  with name "low" "swirling" "mist",
       initial "A low mist swirls about your feet.",
       description "The mist carries a rich aroma of broth.",
       found_in  Square_Chamber  Forest,
       before
       [; Examine, Search: ;
          Smell:   <<Examine self>>;
          default: "The mist is too insubstantial.";
       ],
  has  static;

The found_in property gives a list of places in which the mist is found
(so far just the Square Room and the Forest).

!! If the rainforest contained many misty rooms, it would be tedious to
give the full list and even worse to have to alter it as the mist
drifted about in the course of the game.  Fortunately found_in can
contain a routine instead of a list.  This can look at the current
location and say whether or not the object should be put in it when the
room is entered, e.g.,

Object Sun "Sun",
  with ...
       found_in
       [; if (location has light) rtrue;
       ],
  has  scenery;

!!!! found_in is only consulted when the player's location changes, so
if the mist has to dramatically lift or move then it needs to be moved
or removed `by hand'.  A good way to lift the mist forever is to remove
it, and then give it the absent attribute, which prevents it from
manifesting itself whatever found_in says.

Some pieces of scenery afflict the other four senses.  The mist smells
of broth, which means that if the player types "smell" in a place where
the mist is, then she should be told about the broth.  For this, a
react_before rule attached to the mist is ideal:

       react_before
       [;  Smell: if (noun==0) <<Smell low_mist>>;
       ],

This is called a "react" rule because the mist is reacting to the fact
that a Smell action is taking place nearby.  noun is compared with zero
to see if the player has indeed just typed "smell" (not, say, "smell
crocus").  Thus, when the action Smell takes place near the mist, it is
converted into Smell low_mist; whereas the action Smell crocus would be
left alone.

   The five senses all have actions in Inform: Look, Listen, Smell,
Taste and Touch.  Of these, Look never has a noun attached (because
Examine is provided for close-ups), Smell and Listen may or may not
have while Taste and Touch always have.

Exercise 5
----------

   (Cf. `Spellbreaker'.)  Make an orange cloud descend on the player,
which can't be seen through or walked out of.

   *Note Answer 5::

Directions (such as "north") are objects called n_obj, s_obj and so on:
in this case, in_obj.  (They are not to be confused with the property
names n_to and so on.)  Moreover, you can change these directions: as
far as Inform is concerned, a direction is any object in the special
object compass.

!! Exercise 6
-------------

   In the first millenium A.D., the Mayan peoples of the Yucatan
Peninsula had `world colours' white (`sac'), red (`chac'), yellow
(`kan') and black (`chikin') for what we call the compass bearings
north, east, south, west (for instance west is associated with
`sunset', hence black, the colour of night). Implement this.

   *Note Answer 6::

!! Exercise 7
-------------

   (Cf. `Trinity'.)  How can the entire game map be suddenly east-west
reflected?

   *Note Answer 7::

!!!! Exercise 8
---------------

   Even when the map is reflected, there may be many room descriptions
referring to "east" and "west" by name.  Reflect these too.

   *Note Answer 8::

!! The ordinary Inform directions all have the number property defined
(initially set to zero): this is to provide a set of scratch variables
useful, for instance, when coding mazes.

!!!! If the constant WITHOUT_DIRECTIONS is defined before inclusion of
the library files, then 10 of the default direction objects are not
defined by the library.  The designer is expected to define alternative
ones (and put them in the compass object); otherwise the game will be
rather static.  (The "in" and "out" directions are still created,
because they're needed for getting into and out of enterable objects.)

References
----------

   * `Advent' has a very tangled-up map in places (see the mazes) and a
     well-constructed exterior of forest and valley giving an
     impression of space with remarkably few rooms.  The mist object
     uses found_in to the full, and see also the stream (a single
     object representing every watercourse in the game).  Bedquilt and
     the Swiss Cheese room offer classic confused-exit puzzles.

   * For a simple movement rule using e_to, see the Office in `Toyshop'.

   * The library extension "smartcantgo.h" by David Wagner provides a
     system for automatically printing out "You can only go east and
     north."-style messages.

   * `A Scenic View', by Richard Barnett, demonstrates a system for
     providing examinable scenery much more concisely (without defining
     so many objects).


File: inform,  Node: Containers,  Next: Doors,  Prev: Places,  Up: The Model World

Containers, supporters and sub-objects
======================================

     The concept of a surface is implemented as a special kind of
     containment.  Objects which have surfaces on which other objects
     may sit are actually containers with an additional property of
     "surfaceness".

     -- P. David Lebling, Zork and the Future

     The year has been a good one for the Society (hear, hear).  This
     year our members have put more things on top of other things than
     ever before.  But, I should warn you, this is no time for
     complacency.  No, there are still many things, and I cannot
     emphasize this too strongly, not on top of other things.

     -- `The Royal Society For Putting Things On Top Of Other Things'
     Monty Python's Flying Circus, programme 18 (1970)

Objects can be inside or on top of one another.  An object which has the
container attribute can contain things, like a box: one which has
supporter can hold them up, like a table.  (An object can't have both at
once.)  It can hold up to 100 items, by default: this is set by the
capacity property.  However, one can only put things inside a container
when it has open.  If it has openable, the player can open and close it
at will, unless it also has locked.  A locked object (whether it be a
door or a container) cannot be opened.  But if it has lockable then it
can be locked or unlocked with the key object given in the with_key
property.  If with_key is undeclared, then no key will fit, but this
will not be told to the player, who can try as many as he likes.

   Containers (and supporters) are able to react to things being put
inside them, or removed from them, by acting on the signal to Receive or
LetGo.  For example, deep under the `Ruins' is a chasm which, perhaps
surprisingly, is implemented as a container:

Object -> chasm "horrifying chasm"
  with name "blackness" "chasm" "pit" "depths" "horrifying" "bottomless",
       react_before
       [;  Jump: <<Enter self>>;
           Go: if (noun==d_obj) <<Enter self>>;
       ],
       before
       [;  Enter: deadflag=1;
              "You plummet through the silent void of darkness!";
       ],
       after
       [;  Receive: remove noun;
               print_ret (The) noun, " tumbles silently into the
                   darkness of the chasm.";
           Search: "The chasm is deep and murky.";
       ],
  has  scenery open container;

(Actually the definition is a little longer, so that the chasm reacts
to a huge pumice-stone ball being rolled into it; see `Ruins'.)  Note
the use of an after rule for the Search action: this is because an
attempt to "examine" or "look inside" the chasm will cause this action.
Search means, in effect, "tell me what is inside the container" and the
after rule prevents a message like "There is nothing inside the chasm."
from misleading the player.  Note also that the chasm `steals' any stray
Jump action and converts it into an early death.

Exercise 9
----------

   Make the following, rather acquisitive bag:

>put fish in bag
The bag wriggles hideously as it swallows the fish.
>get fish
The bag defiantly bites itself shut on your hand until you desist.

   *Note Answer 9::

!! LetGo and Receive are examples of actions which aren't explicitly
requested by the player, but are generated by the game in the course of
play (so-called "fake actions").

!! Receive is sent to an object O both when a player tries to put
something in O, and put something on O.  In the rare event that O needs
to react differently to these, it may consult the variable
receive_action to find out whether ##PutOn or ##Insert is the cause.

The `Ruins' packing case is a typical container:

Object -> packing_case "packing case"
  with name "packing" "case" "box" "strongbox",
       initial
          "Your packing case rests here, ready to hold any important
           cultural finds you might make, for shipping back to civilisation.",
       before
       [;  Take, Remove, PushDir:
              "The case is too heavy to bother moving, as long as your
               expedition is still incomplete.";
       ],
  has  static container open;

Now suppose we want a portable television set with four different
buttons on it.  Obviously, when the television moves, its buttons
should move with it, and the sensible way to arrange this is to make the
four buttons possessions of the television object.  But members of an
object which isn't a container are normally assumed by the game to be
hidden invisibly inside (they are said to be "not in scope").  We have
to override this in order to make the four buttons visible from
outside, by giving the television the transparent attribute.

Exercise 10
-----------

   Implement a television set with attached power button and screen.

   *Note Answer 10::

Exercise 11
-----------

   Make a glass box and a steel box, which would behave differently
when a lamp is shut up inside them.

   *Note Answer 11::

!! It sometimes happens that an object should have sub-objects, like
lamps and buttons, as well as possessions, in which case the above
solution is unsatisfactory.  Fuller details will be given in the "scope
addition" rules in *Note Scope::, but briefly: an object's add_to_scope
property may contain a list of sub-objects to be kept attached to it
(and these sub-objects don't count as possessions).

Exercise 12
-----------

   Implement a macrame bag hanging from the ceiling, inside which
objects are visible (and audible, etc.) but cannot be touched or
manipulated in any way.

   *Note Answer 12::

References
----------

   * Containers and supporters abound in the example games (except
     `Advent', which is too simple, though see the water-and-oil
     carrying bottle).  Interesting containers include the
     lottery-board and the podium sockets from `Balances' and the
     `Adventureland' bottle.

   * For supporters, the hearth-rug, chessboard, armchair and
     mantelpiece of `Alice Through The Looking-Glass' are typical
     examples; the mantelpiece and spirit level of `Toyshop' make a
     simple puzzle, and the pile of building blocks a complicated one;
     see also the scales in `Balances'.


File: inform,  Node: Doors,  Next: Switchable Objects,  Prev: Containers,  Up: The Model World

Doors
=====

     Standing in front of you to the north, however, is a door
     surpassing anything you could have imagined. For starters, its
     massive lock is wrapped in a dozen six-inch thick iron chains. In
     addition, a certain five-headed monster...

     -- Marc Blank and P. David Lebling, `Enchanter'

     O for doors to be open and an invite with gilded edges
     To dine with Lord Lobcock and Count Asthma.
     
     -- W. H. Auden (1907-1973), Song

A useful kind of object is a door.  This need not literally be a door:
it might be a rope-bridge or a ladder, for instance.  To set up a door:

  a. give the object the door attribute;

  b. set its door_to property to the destination;

  c. set its door_dir property to the direction which that would be,
     such as n_to;

  d. make the room's map connection in that direction point to the door
     itself.

For example, here is a closed and locked door, blocking the way into
the `Ruins' shrine:

Object Corridor "Stooped Corridor"
  with description "A low, square-cut corridor, running north to south,
           stooping you over.",
       n_to Square_Chamber,
       s_to StoneDoor;
Object -> StoneDoor "stone door"
  with description "It's just a big stone door.",
       name "door" "massive" "big" "stone" "yellow",
       when_closed
           "Passage south is barred by a massive door of yellow stone.",
       when_open
           "The great yellow stone door to the south is open.",
       door_to Shrine,
       door_dir s_to,
       with_key stone_key
  has  static door openable lockable locked;

Note that the door is static -- otherwise the player could pick it up
and walk away with it!  The properties when_closed and when_open give
descriptions appropriate for the door in these two states.

   Doors are rather one-way: they are only really present on one side.
If a door needs to be accessible (openable and lockable from either
side), a neat trick is to make it present in both locations and to fix
the door_to and door_dir to the right way round for whichever side the
player is on.  Here, then, is a two-way door:

Object -> StoneDoor "stone door"
  with description "It's just a big stone door.",
       name "door" "massive" "big" "stone" "yellow",
       when_closed
           "The passage is barred by a massive door of yellow stone.",
       when_open
           "The great yellow stone door is open.",
       door_to
       [;  if (location==Corridor) return Shrine; return Corridor; ],
       door_dir
       [;  if (location==Shrine) return n_to; return s_to; ],
       with_key stone_key,
       found_in  Corridor  Shrine,
  has  static door openable lockable locked;

where Corridor has s_to set to StoneDoor, and Shrine has n_to set to
StoneDoor.  The door can now be opened, closed, entered, locked or
unlocked from either side.  We could also make when_open and
when_closed into routines to print different descriptions of the door
on each side.

   At first sight, it isn't obvious why doors have the door_dir
property.  Why does a door need to know which way it faces?  The point
is that two different actions cause the player to go through the door.
Suppose the door is in the south wall.  The player may type "go south",
which directly causes the action Go s_obj.  Or the player may "enter
door" or "go through door", causing Enter the_door.  Provided the door
is actually open, the Enter action then looks at the door's door_dir
property, finds that the door faces south and generates the action Go
s_obj.  Thus, however the player tries to go through the door, it is
the Go action that finally results.

   This has an important consequence: if you put before and after
routines on the Enter action for the StoneDoor, they only apply to a
player typing "enter door" and not to one just typing "south".  So one
safe way is to trap the Go action.  A neater method is to put some code
into a door_to routine.  If a door_to routine returns 0 instead of a
room, then the player is told that the door "leads nowhere" (like the
famous broken bridge of Avignon).  If door_to returns 1, or `true',
then the library stops the action on the assumption that something has
happened and the player has been told already.

Exercise 13
-----------

   Create a plank bridge across a chasm, which collapses if the player
walks across it while carrying anything.

   *Note Answer 13::

References
----------

   * `Advent' is especially rich in two-way doors: the steel grate in
     the streambed, two bridges (one of crystal, the other of rickety
     wood) and a door with rusty hinges.  See also the iron gate in
     `Balances'.


File: inform,  Node: Switchable Objects,  Next: Things to Enter,  Prev: Doors,  Up: The Model World

Switchable objects
==================

     Steven: `Well, what does this do?'
     Doctor: `That is the dematerialising control.  And that over
     yonder is the horizontal hold.  Up there is the scanner, these are
     the doors, that is a chair with a panda on it.  Sheer poetry, dear
     boy.  Now please stop bothering me.'

     -- Dennis Spooner, The Time Meddler
     Dr Who, serial  17 (1965)

Objects can also be switchable.  This means they can be turned off or
on, as if they had some kind of switch on them.  The object has the
attribute on if it's on.  For example:

Object searchlight "Gotham City searchlight" skyscraper
  with name "search" "light" "template", article "the",
       description "It has some kind of template on it.",
       when_on "The old city searchlight shines out a bat against
                the feather-clouds of the darkening sky.",
       when_off "The old city searchlight, neglected but still
                 functional, sits here."
  has  switchable static;

Something more portable would come in handy for the explorer of
`Ruins', who would hardly have embarked on his expedition without a
decent light source...

Object sodium_lamp "sodium lamp"
  with name "sodium" "lamp" "heavy",
       describe
       [;  if (self hasnt on)
               "^The sodium lamp squats heavily on the ground.";
          "^The sodium lamp squats on the ground, burning away.";
       ],
       battery_power 40,
       before
       [;  Examine: print "It is a heavy-duty archaeologist's lamp, ";
               if (self hasnt on) "currently off.";
               if (self.battery_power < 10) "glowing a dim yellow.";
               "blazing with brilliant yellow light.";
           Burn: <<SwitchOn self>>;
           SwitchOn:
               if (self.battery_power <= 0)
                  "Unfortunately, the battery seems to be dead.";
               if (parent(self) hasnt supporter && self notin location)
                  "The lamp must be securely placed before being lit.";
           Take, Remove:
               if (self has on)
                  "The bulb's too delicate and the metal frame's too
                   hot to lift the lamp while it's switched on.";
       ],
       after
       [;  SwitchOn: give self light;
           SwitchOff: give self ~light;
       ],
  has  switchable;

The `Ruins' lamp will eventually be a little more complicated, with a
daemon to make the battery power run down and to extinguish the lamp
when it runs out; and it will be pushable from place to place, making it
not quite as useless as the player will hopefully think at first.

!! A point to note is that this time the when_on and when_off
properties haven't been used to describe the lamp when it's on the
ground: this is because once an object has been held by the player,
it's normally given only a perfunctory mention in room descriptions
("You can also see a sodium lamp and a grape here.").  But the describe
property has priority over the whole business of how objects are
described in room descriptions.  When it returns true, as above, the
usual description process does nothing further.  For much more on room
descriptions, see *Note Describing Objects::.

References
----------

   * The original switchable object was the brass lamp from `Advent'
     (which also provides verbs "on" and "off" to switch it).  (The
     other example games are generally pre-electric in setting.)


File: inform,  Node: Things to Enter,  Next: Reading Matter,  Prev: Switchable Objects,  Up: The Model World

Things to enter, travel in and push around
==========================================

     ...the need to navigate a newly added river prompted the invention
     of vehicles (specifically, a boat).

     -- P. David Lebling, Marc Blank and Timothy Anderson

Some objects in a game are enterable, which means that a player can get
inside or onto them.  Usually, "inside" means that the player is only
half-in, as with a car or a psychiatrist's couch.  (If it's more like a
prison cell, then it should be a separate place.)  In practice one often
wants to make an enterable thing also a container, or, as in the altar
from `Ruins', a supporter:

Object -> stone_table "slab altar"
 with name "stone" "table" "slab" "altar" "great",
      initial "A great stone slab of a table, or altar, dominates the Shrine.",
 has  enterable supporter;

A chair to sit on, or a bed to lie down on, should also be a supporter.

   If the player gets into a container and then closes it, the effect
is like being in a different location.  (Unless the container has the
transparent attribute and is therefore see-through.) The interior may
be dark, but if there's light to see by, the player will want to see
some kind of room description.  In any case, many enterable objects
ought to look different from inside or on top.  Inside a vehicle, a
player might be able to see a steering wheel and a dashboard, for
instance.  On top of a cupboard, it might be possible to see through a
skylight window.

   For this purpose, any enterable object can provide an
inside_description, which can be a string or a routine to print one, as
usual.  If the exterior location is still visible, then the "inside
description" is added to the normal room description, and otherwise it
becomes that description.  As an extreme example, suppose that the
player gets into a huge cupboard, closes the door behind her and then
gets into a plastic cabinet inside that.  The resulting room
description might read like so:

     *The huge cupboard* (in the plastic cabinet)
     It's a snug little cupboard in here, almost a room in itself.
     
     In the huge cupboard you can see a pile of clothes.
     
     The plastic walls of the cabinet distort the view.

The second line is the inside_description for the huge cupboard, and
the fourth is that for the plastic cabinet.

Exercise 14
-----------

   (Also from `Ruins'.)  Implement a cage which can be opened, closed
and entered.

   *Note Answer 14::

All the classic games have vehicles (like boats, or fork lift trucks, or
hot air balloons) which the player can journey in, so Inform makes this
easy.  Here is a simple case:

Object car "little red car" cave
  with name "little" "red" "car",
       description "Large enough to sit inside.  Among the controls is a
           prominent on/off switch.  The numberplate is KAR 1.",
       when_on  "The red car sits here, its engine still running.",
       when_off "A little red car is parked here.",
       before
       [; Go: if (car has on) "Brmm!  Brmm!";
              print "(The ignition is off at the moment.)^";
       ],
  has  switchable enterable static container open;

Actually, this demonstrates a special rule.  If a player is inside an
enterable object and tries to move, say "north", the before routine for
the object is called with the action Go, and n_obj as the noun.  It may
then return:

     0    to disallow the movement, printing a refusal;
     1    to allow the movement, moving vehicle and player;
     2    to disallow but print and do nothing; or
     3    to allow but print and do nothing.

If you want to move the vehicle in your own code, return 3, not 2:
otherwise the old location may be restored by subsequent workings.

Because you might want to drive the car "out" of a garage, the "out"
verb does not make the player get out of the car.  Usually the player
has to type something like "get out" to make this happen, though of
course the rules can be changed.

Exercise 15
-----------

   Alter the car so that it won't go east.

   *Note Answer 15::

!!  Objects like the car or, say, an antiquated wireless on casters,
are obviously too heavy to pick up but the player should at least be
able to push them from place to place.  When the player tries to do
this, the PushDir action is generated.  Now, if the before routine
returns false, the game will just say that the player can't; and if it
returns true, the game will do nothing at all, guessing that the before
routine has already printed something more interesting.  So how does
one actually tell Inform that the push should be allowed?  The answer
is that one has to do two things: call the AllowPushDir routine (a
library routine), and then return true.  For example (`Ruins' again):

Object -> huge_ball "huge pumice-stone ball"
  with name "huge" "pumice" "pumice-stone" "stone" "ball",
       description "A good eight feet across, though fairly lightweight.",
       initial
           "A huge pumice-stone ball rests here, eight feet wide.",
       before
       [;  PushDir:
               if (location==Junction && second==w_obj)
                   "The corridor entrance is but seven feet across.";
               AllowPushDir(); rtrue;
           Pull, Push, Turn: "It wouldn't be so very hard to get rolling.";
           Take, Remove: "There's a lot of stone in an eight-foot sphere.";
       ],
       after
       [;  PushDir:
              if (second==s_obj) "The ball is hard to stop once underway.";
              if (second==n_obj) "You strain to push the ball uphill.";
       ],
  has  static;

!! Exercise 16
--------------

The library does not normally allow pushing objects up or down.  How
can the pumice ball allow this?

   *Note Answer 16::

References
----------

   * For an enterable supporter puzzle, see the magic carpet in
     `Balances' (and several items in `Alice Through The
     Looking-Glass').


File: inform,  Node: Reading Matter,  Next: Living Creatures,  Prev: Things to Enter,  Up: The Model World

Reading matter and consultation
===============================

     Even at present... we still know very little about how access to
     printed materials affects human behaviour.

     -- Elizabeth Eisenstein, The Printing Revolution in Early Modern
     Europe

     look up figure 18 in the engineering textbook

is a difficult line for Inform to understand, because almost anything
could appear in the first part: even its format depends on what the
second part is.  This kind of request, and more generally

     look up <any words here> in <the object>
     read about <any words here> in <the object>
     consult <the object> about <any words here>

cause the Consult object action.  Note that second is just zero:
formally, there is no second noun attached to a Consult action.  The
object has to parse the <any words here> part itself, in a before rule
for Consult.  The following variables are set up to make this possible:

  consult_from   the number of the first word in the <any...> clause;
  consult_words  the number of words in the <any...> clause (at least 1).

The words given are parsed using library routines like NextWord(),
TryNumber(word-number) and so on: see *Note Parsing Nouns:: for full
details.  As usual, the before routine should return true if it has
managed to deal with the action; returning false will make the library
print "You discover nothing of interest in...".

   Little hints are placed here and there in the `Ruins', written in
the glyphs of an ancient dialect of Mayan.  Our explorer has, of
course, come equipped with the latest and finest scholarship on the
subject:

Object dictionary "Waldeck's Mayan dictionary"
  with name "dictionary" "local" "guide" "book" "mayan"
            "waldeck" "waldeck^s",
       description "Compiled from the unreliable lithographs of the
           legendary raconteur and explorer ~Count~ Jean Frederic
           Maximilien Waldeck (1766??-1875), this guide contains
           what little is known of the glyphs used in the local
           ancient dialect.",
       before
       [ w1 w2 glyph other;  Consult:
               if (consult_words>2) jump GlyphHelp;
               wn=consult_from;
               w1 = NextWord(); ! First word of subject
               w2 = NextWord(); ! Second word (if any) of subject
               if (consult_words==1 && w1=='glyph' or 'glyphs')
                   jump GlyphHelp;
               !  We want to recognise both "glyph q1" and "q1 glyph":
               glyph=w1; other=w2;
               if (w1=='glyph') { glyph=w2; other=w1; }
               !  So now glyph holds the name, and other the other word
               if (consult_words==2 && other~='glyph') jump GlyphHelp;
               switch(glyph)
               {   'q1': "(This is one glyph you have memorised!)^^
                          Q1: ~sacred site~.";
                   'circle': "Circle: ~the Sun; also life, lifetime~.";
                   ...
                   default: "That glyph is so far unrecorded.";
               }
               !  All three of the ways the text can go wrong lead to
               !  this message being produced:
              .GlyphHelp; "Try ~look up <name of glyph> in book~.";
       ],
  has  proper;

Note that this understands any of the forms "q1", "glyph q1" or "q1
glyph" but is careful to reject, for instance, "glyph q1 glyph".
(These aren't genuine Mayan glyphs, but some of the real ones have
similar names, dating from when their syllabic equivalents weren't
known: G8, the Lord of the Night, for instance.)

Exercise 17
-----------

   To mark the 500th anniversary of William Tyndale (the first English
translator of the New Testament), prepare an edition of the four
Gospels.

   *Note Answer 17::

!!!!  Ordinarily, a request by the player to "read" something is
translated into an Examine action.  But the "read" verb is defined
independently of the "examine" verb in order to make it easy to
separate the two requests.  For instance:

Attribute legible;
...
Object textbook "textbook"
  with name "engineering" "textbook" "text" "book",
       description "What beautiful covers and spine!",
       before
       [; Consult, Read:
           "The pages are full of senseless equations.";
       ],
       has  legible;
...
[ ReadSub; <<Examine noun>>; ];
Extend "read" first * legible                        -> Read;

Note that "read" causes a Read action only for legible objects, and
otherwise causes Examine in the usual way.  ReadSub is coded as a
translation to Examine as well, so that if a legible object doesn't
provide a Read rule then an Examine happens after all.

References
----------

   * If you really need more elaborate topic-parsing (for, e.g., "look
     up <something> in the catalogue", where any object name might
     appear) then extending the grammar for look may be less trouble.
     For a good implementation see `Encyclopaedia Frobozzica', by
     Gareth Rees.
