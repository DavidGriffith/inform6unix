<HTML><HEAD><TITLE>Section 25: Plural names for duplicated objects</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE></SMALL>
<TR><TD><TD><P>
<TR><TD Valign="top"><A HREF="contents.html">Contents</A><BR><A HREF="section24.html">Back</A><BR><A HREF="section26.html">Forward</A><TD bgcolor="#F5DEB3"><BLOCKQUOTE><H3>25. Plural names for duplicated objects</H3></BLOCKQUOTE><TR><TD><TD>
<P>

<BLOCKQUOTE>
<BR>Abiit ad plures.
<BR><P>...Petronius (?--c. <B>66</B>), <I>Cena Trimalchionis</I></BLOCKQUOTE>
<P>


A notorious problem for adventure game parsers is to handle a collection of,
say, ten gold coins, allowing the player to use them independently of each
other, while gathering them together into groups in descriptions and
inventories.  This is relatively easy in Inform, and only in really hard
cases do you have to provide code.
Two problems must be overcome: firstly, the game has to be able
to talk to the player in plurals, and secondly vice versa.  First, then,
game to player:
<PRE>
Class  GoldCoin
  with name "gold" "coin",
       short_name "gold coin",
       plural "gold coins";
</PRE>

 (and similar silver and bronze coin classes here)
<PRE>
Object bag "bag"
  with name "bag"
  has  container open openable;
GoldCoin -&#62;;
GoldCoin -&#62;;
GoldCoin -&#62;;
SilverCoin -&#62;;
SilverCoin -&#62;;
BronzeCoin -&#62;;
</PRE>

 Now we have a bag of six coins.  The player looking inside
the bag will get
<PRE>
&#62;look inside bag
In the bag are three gold coins, two silver coins and a bronze coin.
</PRE>

How does the library know that the three gold coins are the same as each
other, but the others different?  It doesn't look at the classes but the
names.  It will only group together things which:

<P>(a) --   have a <TT>plural</TT> set,
<P>(b) --   are 'indistinguishable' from each other.
<P>


Indistinguishable means they have the same <TT>name</TT> words as each other,
possibly in a different order, so that nothing the player can type
will separate the two.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> Actually, the library is cleverer than this.  What it groups
together depends slightly on the context of the list it's writing out.  When
it's writing a list which prints out details of which objects are providing
light, for instance (like an inventory), it won't group together two objects
if one is lit but the other isn't.  Similarly for objects with visible
possessions or which can be worn.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> This all gets even more complicated when the objects have a
<TT>parse_name</TT> routine supplied, because then the library can't use the <TT>name</TT>
fields to tell them apart.  If they have different <TT>parse_name</TT> routines, it
decides that they're different.  But if they have the same <TT>parse_name</TT>
routine, there is no alternative but to ask them.  What happens is that
<BLOCKQUOTE>
1.<SAMP>      </SAMP> A variable called <TT>parser_action</TT> is set to <TT>##TheSame</TT>;<BR>
2.<SAMP>      </SAMP> Two variables, called <TT>parser_one</TT> and <TT>parser_two</TT> are set to<BR>
 <SAMP>      </SAMP> the two objects in question;<BR>
3.<SAMP>      </SAMP> Their <TT>parse_name</TT> routine is called.  If it returns:<BR>
<SAMP>            </SAMP> -1 <SAMP>      </SAMP> the objects are declared "indistinguishable",<BR>
<SAMP>            </SAMP> -2 <SAMP>      </SAMP> they are declared different.<BR>
4.<SAMP>      </SAMP> Otherwise, the usual rules apply and the library looks at<BR>
<SAMP>            </SAMP> the ordinary <TT>name</TT> fields of the objects.<BR>
</BLOCKQUOTE>

<TT>##TheSame</TT> is a fake action.

  The implementation of the
'Spellbreaker cubes' in the 'Balances' game
is an example of such a routine, so that if
the player writes the same name on several of the cubes, they become
grouped together.  Note that this whole set-up is such that if the
author of a <TT>parse_name</TT> routine has never read this paragraph, it doesn't
matter and the usual rules take their course.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> You may even want to provide a <TT>parse_name</TT> routine just to speed
up the process of telling two objects apart -- if there were 30 gold coins
the parser would be doing a lot of work comparing all their names, but you
can make the decision much faster.
<P>
</SMALL>
<TR><TD><TD><P>


Secondly, the player talking to the computer.  This goes a little further
than just copies of the same object: many games involve collecting a number
of similar items, say a set of nine crowns in different colours. Then you'd
want the parser to recognise things like:
<PRE>
&#62; drop all of the crowns except green
&#62; drop the three other crowns
</PRE>

Putting the word <TT>"crowns"</TT> in their <TT>name</TT> lists is not quite
right, because the parser will still think that "crowns'' might
refer to a specific item.  Instead, put in the word <TT>"crowns//p"</TT>.
The <TT>//p</TT> marks out the dictionary word "crowns'' as one that
can refer to more than one game object at once.  (So that
you shouldn't set this for the word "grapes'' if a bunch of
grapes was a single game object; you should give that object
the <TT>pluralname</TT> attribute instead.)  For example the <TT>GoldCoin</TT>
class would read:
<PRE>        
Class  GoldCoin
  with name "gold" "coin" "coins//p",
       short_name "gold coin",
       plural "gold coins";
</PRE>

and now when the player types "take coins'', the parser
interprets this as "take all the coins within reach''.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> The only snag is that now the word <TT>"coins"</TT> is marked as
<TT>//p</TT> everywhere in the game, in all circumstances.  Here is
a more complicated way to achieve the same result, but
strictly in context of these objects alone.  We need to make
the <TT>parse_name</TT> routine tell the parser that yes, there was a match, but
that it was a plural.  The way to do this is to set <TT>parser_action</TT> to
<TT>##PluralFound</TT>, another fake action.  So, for example:
<PRE>
Class  Crown
  with parse_name
       [ i j;
         for (::)
         {   j=NextWord();
             if (j=='crown' or self.name) i++;
             else
             {   if (j=='crowns')
                 {   parser_action=##PluralFound; i++; }
                 else return i;
             }
         }
       ];
</PRE>

This code assumes that the crown objects have just one <TT>name</TT> each,
their colours.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex64"><B>EXERCISE 64:</B><BR>(link to <A HREF="answers2/answer64.html">the answer</A>)<TR><TD><TD>  Write a 'cherub' class so that if the player tries to call them
"cherubs", a message like "I'll let this go by for now, but the plural of
cherub is cherubim" appears.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/refs.gif" ALT="*"><TD bgcolor="#EEEEEE"><B>REFERENCES:</B><BR><SMALL>  See the coinage of 'Balances'.
</TABLE>
<HR><A HREF="contents.html">Contents</A> / <A HREF="section24.html">Back</A> / <A HREF="section26.html">Forward</A> <BR>
<A HREF="chapter1.html">Chapter I</A> / <A HREF="chapter2.html">Chapter II</A> / <A HREF="chapter3.html">Chapter III</A> / <A HREF="chapter4.html">Chapter IV</A> / <A HREF="chapter5.html">Chapter V</A> / <A HREF="chapter6.html">Chapter VI</A> / <A HREF="chapterA.html">Appendix</A><HR><SMALL><I>Mechanically translated to HTML from third edition as revised 16 May 1997. Copyright &#169; Graham Nelson 1993, 1994, 1995, 1996, 1997: all rights reserved.</I></SMALL></BODY></HTML>
