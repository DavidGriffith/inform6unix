<HTML><HEAD><TITLE>Section 28: Scope and what you can see</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE><P>
<TR><TD Valign="top"><A HREF="contents.html">Contents</A><BR><A HREF="section27.html">Back</A><BR><A HREF="section29.html">Forward</A><TD bgcolor="#F5DEB3"><BLOCKQUOTE><H3>28. Scope and what you can see</H3></BLOCKQUOTE><TR><TD><TD>
<P>

<BLOCKQUOTE>
He cannot see beyond his own nose.  Even the fingers he outstretches
from it to the world are (as I shall suggest) often invisible to him.
<P>...Max Beerbohm (<B>1872</B>--<B>1956</B>), of George Bernard Shaw</BLOCKQUOTE>
<BLOCKQUOTE>
<BR>Wherefore are these things hid?
<BR><P>...William Shakespeare (<B>1564</B>--<B>1616</B>), <I>Twelfth Night</I></BLOCKQUOTE>
<P>


Time to say what "in scope" means.  This definition is one of the most
important rules of play, because it decides what the player is allowed
to refer to.  You can investigate this in practice by compiling any game
with the debugging suite of verbs included and typing "scope'' in
different places: but here are the rules in full.  The following are in
scope:
<BLOCKQUOTE>
the player's immediate possessions;<BR>
the 12 compass directions;<BR>
if there is light (see <A HREF="section17.html">Section 17</A>), the objects in the same 'enclosure'
as the player;<BR>
if not, any objects in the <TT>thedark</TT> object;
if the player is inside a dark <TT>container</TT>, then that container.<BR>
</BLOCKQUOTE>

The 'enclosure' of the player is usually the current location.  Formally,
it's the outermost object containing the player which remains visible --
for instance, if the player is in a transparent cabinet in a closed,
huge cupboard in the Stores Room, then the enclosure is the huge cupboard.
(Thus items in the huge cupboard are in scope, subject to the remaining
rules, but other items in the Stores Room are not.)
<P>

In addition, if an object is in scope then its immediate
possessions are in scope, <B> if</B> it is 'see-through', which means that:
<BLOCKQUOTE>
the object has <TT>supporter</TT>, <B> or</B><BR>
the object has <TT>transparent</TT>, <B> or</B><BR>
the object is an <TT>open</TT> <TT>container</TT>.<BR>
</BLOCKQUOTE>

In addition, if an object is in scope then anything which
it "adds to scope'' is also in scope.
<P>
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> The player's possessions are in scope in a dark room -- so the
player can still turn his lamp on.  On the other hand, a player who
puts the lamp on the ground and turns it off then loses the ability to
turn it back on again, because it is out of scope.  This can be changed;
see below.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> Compass directions make sense as things.  The player can
always type something like "attack the south wall'' and the <TT>before</TT> rule
for the room could trap the action <TT>Attack s_obj</TT> to make something unusual
happen, if this is desired.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> The parser applies scope rules to all actors, not just the
player.  Thus "dwarf, drop sword'' will be accepted if the dwarf can
see it, even if the player can't.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> The <TT>concealed</TT> attribute only hides objects from room
descriptions, and doesn't remove them from scope.  If you want things to
be both concealed and unreferrable-to, put them somewhere else!  Or
give them an uncooperative <TT>parse_name</TT> routine.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Actually, the above definition is not quite right, because
the compass directions are not in scope when the player asks for a plural
number of things, like "take all the knives"; this makes some of the
parser's plural algorithms run faster.  Also, for a <TABLE Border><TR><TD><TT>multiexcept</TT></TABLE>
token, the other object is not in scope; and for a <TABLE Border><TR><TD><TT>multiinside</TT></TABLE> token,
only objects in the other object are in scope.  This makes "take everything
from the cupboard'' work in the natural way.
<P>
</SMALL>
<TR><TD><TD><P>


Two library routines are provided to enable you to see what's in
scope and what isn't.  The first, <TT>TestScope(obj, actor)</TT>, simply returns
true or false according to whether or not <TT>obj</TT> is in scope.  The
second is <TT>LoopOverScope(routine, actor)</TT> and calls the given routine
for each object in scope.  In each case the <TT>actor</TT> given is optional;
if it's omitted, scope is worked out for the player as
usual.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex79"><B>EXERCISE 79:</B><BR>(link to <A HREF="answers2/answer79.html">the answer</A>)<TR><TD><TD>  Implement the debugging suite's "scope'' verb,
which lists all the objects currently in
scope.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex80"><B>EXERCISE 80:</B><BR>(link to <A HREF="answers2/answer80.html">the answer</A>)<TR><TD><TD>  Write a "megalook'' verb, which looks around and
examines everything nearby.
<P>

Formally, scope determines what you can talk about, which usually
means what you can see.  But what can you touch?  Suppose a locked
chest is inside a sealed glass cabinet.  The Inform parser will
allow the command "unlock chest with key'' and generate the
appropriate action, <TT>Unlock chest key</TT>, because the chest is in
scope, so the command at least makes sense.
<P>

But it's impossible to carry out, because the player can't reach
through the solid glass.  So the library's routine for handling the
<TT>Unlock</TT> action needs to enforce this.  The library does this
using a stricter rule called "touchability''.  The rule is that
you can touch anything in scope unless there's a closed container
between you and it.  This applies either if you're in the container,
or if it is.
<P>

Some purely visual actions don't require touchability -- <TT>Examine</TT>
or <TT>LookUnder</TT>, for instance.  But most actions are tactile, and
so will many actions created by designers.  If you want to make
your own action routines enforce touchability, you can call the
library routine <TT>ObjectIsUntouchable(obj)</TT>.  This either returns
<TT>false</TT> if there's no problem in touching <TT>obj</TT>, or returns <TT>true</TT>
and prints a suitable message (such as "The solid glass cabinet
is in the way.'').  Thus, the first line of many of the library's
action routines is:
<PRE>
    if (ObjectIsUntouchable(noun)) return;
</PRE>

You can also call <TT>ObjectIsUntouchable(obj, true)</TT> to simply return
true or false, and print nothing, if you'd rather provide your
own failure message.
<P>


The rest of this section is about how to change the scope rules.  As usual
with Inform, you can change them globally, but it's more efficient and
safer to work locally.  To take a typical example: how do we allow the
player to ask questions like the traditional
"what is a grue''
?
The "grue'' part ought to be parsed as if it were a noun, so that
we could distinguish between, say, a "garden grue'' and a "wild grue''.
So it isn't good enough to look only at a single word.  Here is one
solution:
<PRE>
Object questions "qs";
[ QuerySub; print_ret (string) noun.description;
];
[ Topic i;
  switch(scope_stage)
  {   1: rfalse;
      2: objectloop (i in questions) PlaceInScope(i); rtrue;
      3: "At the moment, even the simplest questions confuse you.";
  }
];
</PRE>

where the actual questions at any time are the current children of
the <TT>questions</TT> object, like so:
<PRE>
Object q1 "long count" questions
  with name "long" "count",
       description "The Long Count is the great Mayan cycle of time,
           which began in 3114 BC and will finish with the world's end
           in 2012 AD.";
</PRE>

and we also have a grammar line:
<PRE>
Verb "what"
                * "is"  scope=Topic              -&#62; Query
                * "was" scope=Topic              -&#62; Query;
</PRE>

Note that the <TT>questions</TT> and <TT>q1</TT> objects are out of the game for every
other purpose.  The name "qs'' doesn't matter, as it will never appear;
the individual questions are named so that the parser might be able to say
"Which do you mean, the long count or the short count?'' if the player
asked "what is the count''.
<P>

When the parser reaches <TABLE Border><TR><TD><TT>scope=Topic</TT></TABLE>, it calls
the <TT>Topic</TT> routine with the variable <TT>scope_stage</TT> set to 1.  The routine
should return 1 (true) if it is prepared to allow multiple objects to be
accepted here, and 0 (false) otherwise: as we don't want "what is
everything'' to list all the questions and answers in the game, we return
false.
<P>

A little later on in its machinations, the parser again calls <TT>Topic</TT>
with <TT>scope_stage</TT> now set to 2.  <TT>Topic</TT> is now obliged to
tell the parser which objects are to be in scope.  It can call two
parser routines to do this.
<PRE>
ScopeWithin(object)
</PRE>

puts everything inside the object into scope, though not the object itself;
<PRE>
PlaceInScope(object)
</PRE>

puts just a single object into scope.  It is perfectly legal to declare
something in scope that "would have been in scope anyway": or even something
which is in a different room altogether from the actor concerned, say at the
other end of a telephone line.  Our scope routine <TT>Topic</TT> should then return

<P>0 --  (false) to carry on with the usual scope rules, so that everything
that would usually be in scope still is, or
<P>1 --  (true) to tell the parser not to put any more objects into scope.
<P>

<P>
So at <TT>scope_stage</TT> 2 it is quite permissible to do nothing but return false,
whereupon the usual rules apply.  <TT>Topic</TT> returns true because it wants
only question topics to be in scope, not question topics together with
the usual miscellany near the player.
<P>

This is enough to deal with "what is the long count''.  If on the other
hand the player typed "what is the lgon cnout'', the error message
which the parser would usually produce ("You can't see any such thing'')
would be unsatisfactory.  So if parsing failed at this token, then
<TT>Topic</TT> is called at <TT>scope_stage</TT> 3 to print out a suitable error
message.  It must provide one.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> Note that <TT>ScopeWithin(object)</TT> extends the scope down through
its possessions according to the usual rules, i.e., depending on their
transparency, whether they're containers and so on.  The definition of
<TT>Topic</TT> above shows how to put just the direct possessions into scope.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex81"><B>EXERCISE 81:</B><BR>(link to <A HREF="answers2/answer81.html">the answer</A>)<TR><TD><TD> Write a token which puts everything in scope, so that you could
have a debugging "purloin'' verb which could take anything, regardless
of where it was and the rules applying to
it.
<P>

<P>
Changing the global definition of scope should be done cautiously
(there may be unanticipated side effects); bear in mind that scope decisions
need to be taken often -- every time an object token is parsed, so perhaps
five to ten times in every game turn -- and hence moderately
quickly.
The global definition can be tampered with by providing the entry point
<PRE>
InScope(actor)
</PRE>

where the <TT>actor</TT> is usually the player, but not always.  If the routine
decides that a particular object should be in scope for the actor,
it should execute <TT>PlaceInScope</TT> and <TT>ScopeWithin</TT> just as above, and return
true or false, as if it were at <TT>scope_stage</TT> 2.  Thus, it is vital to
return false in circumstances when you don't want to intervene.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> The token <TABLE Border><TR><TD><TT>scope=</TT><I><B>&#60;Routine&#62;</B></I></TABLE> takes precedence over
<TT>InScope</TT>, which will only be reached if the routine returns
false to signify 'carry on'.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> There are seven reasons why <TT>InScope</TT> might be being
called; the <TT>scope_reason</TT> variable is set to the current
one:
<TR><TD><TD bgcolor="#EEEEEE"><SMALL>

<DL>
<DT><B><TT>PARSING_REASON</TT></B><DD>

The usual one.  Note that <TT>action_to_be</TT> holds
<TT>NULL</TT> in the early stages (before the verb has been decided)
and later on the action which would result from a successful match.
<DT><B><TT>TALKING_REASON</TT></B><DD>

Working out which objects are in scope for being spoken to (see
the end of <A HREF="section16.html">Section 16</A> for exercises using this).
<DT><B><TT>EACHTURN_REASON</TT></B><DD>

When running <TT>each_turn</TT> routines for anything nearby, at the end of
each turn.
<DT><B><TT>REACT_BEFORE_REASON</TT></B><DD>

When running <TT>react_before</TT>.
<DT><B><TT>REACT_AFTER_REASON</TT></B><DD>

When running <TT>react_after</TT>.
<DT><B><TT>TESTSCOPE_REASON</TT></B><DD>

When performing a <TT>TestScope</TT>.
<DT><B><TT>LOOPOVERSCOPE_REASON</TT></B><DD>

When performing a <TT>LoopOverScope</TT>.
</DL>

</SMALL>
<TR><TD><TD><P>

<P>
Here are some examples.  Firstly, as promised, how to change the
rule that "things you've just dropped disappear in the dark":
<PRE>
[ InScope person i;
  if (person==player &#38;&#38; location==thedark)
      objectloop (i near player)
          if (i has moved)
              PlaceInScope(i);
  rfalse;
];
</PRE>

With this routine added, the objects in the dark room the player
is in are in scope only if they have <TT>moved</TT> (that is, have been held by
the player in the past); and even then, are in scope only to the player.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex82"><B>EXERCISE 82:</B><BR>(link to <A HREF="answers2/answer82.html">the answer</A>)<TR><TD><TD> Construct a long room divided by a glass window.
Room descriptions on either side should describe what's in view on
the other; the window should be lookable-through; objects on the far
side should be in scope, but not manipulable; and everything should
cope well if one side is in
darkness.

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex83"><B>EXERCISE 83:</B><BR>(link to <A HREF="answers2/answer83.html">the answer</A>)<TR><TD><TD> Code the following puzzle.
In an initially dark room there is a light switch.
Provided you've seen the switch at some time in the past, you can turn
it on and off -- but before you've ever seen it, you can't.  Inside the
room is nothing you can see, but you can hear a dwarf breathing.  If you
tell the dwarf to turn the light on, he
will.

<P>

<P><TR><TD Valign="top"><IMG SRC="icons/dbend.gif" ALT="/\"><TD bgcolor="#EEEEEE"><SMALL> Alternatively, it may contain a routine.  This routine can then
call <TT>AddToScope(x)</TT> to put any object <TT>x</TT> into scope.  It may not,
however, call <TT>ScopeWithin</TT> or any other scoping routines.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddbend.gif" ALT="/\/\"><TD bgcolor="#EEEEEE"><SMALL> Scope addition does <I> not</I> occur for an object moved
into scope by an explicit call to <TT>PlaceInScope</TT>, since this must allow
complete freedom in scope selections.  But it does happen when objects
are moved in scope by calls to <TT>ScopeWithin(domain)</TT>.
</SMALL>
<TR><TD><TD><P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex84"><B>EXERCISE 84:</B><BR>(link to <A HREF="answers2/answer84.html">the answer</A>)<TR><TD><TD> (From the tiny example game 'A Nasal Twinge'.)  Give the
player a nose, which is always in scope and can be held, reducing
the player's carrying capacity.
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/exercise.gif" ALT="??"><TD bgcolor="#FBB9AC"><A NAME="ex85"><B>EXERCISE 85:</B><BR>(link to <A HREF="answers2/answer85.html">the answer</A>)<TR><TD><TD> (Likewise.)  Create a portable sterilising machine, with a
"go'' button, a top which things can be put on and an inside to hold
objects for sterilisation.  (Thus it is a container, a supporter
and a possessor of sub-objects all at
once.)
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/ddexercise.gif" ALT="??/\/\"><TD bgcolor="#FBB9AC"><A NAME="ex86"><B>EXERCISE 86:</B><BR>(link to <A HREF="answers2/answer86.html">the answer</A>)<TR><TD><TD> Create a red sticky label which the player can affix
to any object in the game.  (Hint: use <TT>InScope</TT>, not
<TT>add_to_scope</TT>.)
<P>

<P><TR><TD Valign="top"><IMG SRC="icons/refs.gif" ALT="*"><TD bgcolor="#EEEEEE"><B>REFERENCES:</B><BR><SMALL>  'Balances' uses <TABLE Border><TR><TD><TT>scope = </TT><I><B>&#60;routine&#62;</B></I></TABLE> tokens
for legible spells and memorised spells.
<BR>  See also the exercises at the end of <A HREF="section16.html">Section 16</A> for further
scope trickery.
</SMALL>
<TR><TD><TD><P>


</TABLE>
<HR><A HREF="contents.html">Contents</A> / <A HREF="section27.html">Back</A> / <A HREF="section29.html">Forward</A> <BR>
<A HREF="chapter1.html">Chapter I</A> / <A HREF="chapter2.html">Chapter II</A> / <A HREF="chapter3.html">Chapter III</A> / <A HREF="chapter4.html">Chapter IV</A> / <A HREF="chapter5.html">Chapter V</A> / <A HREF="chapter6.html">Chapter VI</A> / <A HREF="chapterA.html">Appendix</A><HR><SMALL><I>Mechanically translated to HTML from third edition as revised 16 May 1997. Copyright &#169; Graham Nelson 1993, 1994, 1995, 1996, 1997: all rights reserved.</I></SMALL></BODY></HTML>
