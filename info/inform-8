This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Scope,  Next: Helping the Parser,  Prev: Grammar Tokens,  Up: Describing and Parsing

Scope and what you can see
==========================

     He cannot see beyond his own nose.  Even the fingers he
     outstretches from it to the world are (as I shall suggest) often
     invisible to him.

     -- Max Beerbohm (1872-1956), of George Bernard Shaw

     Wherefore are these things hid?
     
     -- William Shakespeare (1564-1616), Twelfth Night

Time to say what "in scope" means.  This definition is one of the most
important rules of play, because it decides what the player is allowed
to refer to.  You can investigate this in practice by compiling any game
with the debugging suite of verbs included and typing "scope" in
different places: but here are the rules in full.  The following are in
scope:

     the player's immediate possessions;
     the 12 compass directions;
     if there is light (*note Light and Dark::.), the objects in the same
     `enclosure' as the player;
     if not, any objects in the thedark object;
     if the player is inside a dark container, then that container.

The `enclosure' of the player is usually the current location.
Formally, it's the outermost object containing the player which remains
visible -- for instance, if the player is in a transparent cabinet in a
closed, huge cupboard in the Stores Room, then the enclosure is the
huge cupboard.  (Thus items in the huge cupboard are in scope, subject
to the remaining rules, but other items in the Stores Room are not.)

   In addition, if an object is in scope then its immediate possessions
are in scope, *if* it is `see-through', which means that:

     the object has supporter, *or*
     the object has transparent, *or*
     the object is an open container.

In addition, if an object is in scope then anything which it "adds to
scope" is also in scope.

!! The player's possessions are in scope in a dark room -- so the
player can still turn his lamp on.  On the other hand, a player who
puts the lamp on the ground and turns it off then loses the ability to
turn it back on again, because it is out of scope.  This can be changed;
see below.

!! Compass directions make sense as things.  The player can always type
something like "attack the south wall" and the before rule for the room
could trap the action Attack s_obj to make something unusual happen, if
this is desired.

!! The parser applies scope rules to all actors, not just the player.
Thus "dwarf, drop sword" will be accepted if the dwarf can see it, even
if the player can't.

!! The concealed attribute only hides objects from room descriptions,
and doesn't remove them from scope.  If you want things to be both
concealed and unreferrable-to, put them somewhere else!  Or give them
an uncooperative parse_name routine.

!!!! Actually, the above definition is not quite right, because the
compass directions are not in scope when the player asks for a plural
number of things, like "take all the knives"; this makes some of the
parser's plural algorithms run faster.  Also, for a `multiexcept'
token, the other object is not in scope; and for a `multiinside' token,
only objects in the other object are in scope.  This makes "take
everything from the cupboard" work in the natural way.

Two library routines are provided to enable you to see what's in scope
and what isn't.  The first, TestScope(obj, actor), simply returns true
or false according to whether or not obj is in scope.  The second is
LoopOverScope(routine, actor) and calls the given routine for each
object in scope.  In each case the actor given is optional; if it's
omitted, scope is worked out for the player as usual.

Exercise 79
-----------

   Implement the debugging suite's "scope" verb, which lists all the
objects currently in scope.

   *Note Answer 79::

Exercise 80
-----------

   Write a "megalook" verb, which looks around and examines everything
nearby.

   *Note Answer 80::

   Formally, scope determines what you can talk about, which usually
means what you can see.  But what can you touch?  Suppose a locked
chest is inside a sealed glass cabinet.  The Inform parser will allow
the command "unlock chest with key" and generate the appropriate
action, Unlock chest key, because the chest is in scope, so the command
at least makes sense.

   But it's impossible to carry out, because the player can't reach
through the solid glass.  So the library's routine for handling the
Unlock action needs to enforce this.  The library does this using a
stricter rule called "touchability".  The rule is that you can touch
anything in scope unless there's a closed container between you and it.
This applies either if you're in the container, or if it is.

   Some purely visual actions don't require touchability -- Examine or
LookUnder, for instance.  But most actions are tactile, and so will
many actions created by designers.  If you want to make your own action
routines enforce touchability, you can call the library routine
ObjectIsUntouchable(obj).  This either returns false if there's no
problem in touching obj, or returns true and prints a suitable message
(such as "The solid glass cabinet is in the way.").  Thus, the first
line of many of the library's action routines is:

    if (ObjectIsUntouchable(noun)) return;

You can also call ObjectIsUntouchable(obj, true) to simply return true
or false, and print nothing, if you'd rather provide your own failure
message.

The rest of this section is about how to change the scope rules.  As
usual with Inform, you can change them globally, but it's more
efficient and safer to work locally.  To take a typical example: how do
we allow the player to ask questions like the traditional "what is a
grue"?  The "grue" part ought to be parsed as if it were a noun, so that
we could distinguish between, say, a "garden grue" and a "wild grue".
So it isn't good enough to look only at a single word.  Here is one
solution:

Object questions "qs";
[ QuerySub; print_ret (string) noun.description;
];
[ Topic i;
  switch(scope_stage)
  {   1: rfalse;
      2: objectloop (i in questions) PlaceInScope(i); rtrue;
      3: "At the moment, even the simplest questions confuse you.";
  }
];

where the actual questions at any time are the current children of the
questions object, like so:

Object q1 "long count" questions
  with name "long" "count",
       description "The Long Count is the great Mayan cycle of time,
           which began in 3114 BC and will finish with the world's end
           in 2012 AD.";

and we also have a grammar line:

Verb "what"
                * "is"  scope=Topic              -> Query
                * "was" scope=Topic              -> Query;

Note that the questions and q1 objects are out of the game for every
other purpose.  The name "qs" doesn't matter, as it will never appear;
the individual questions are named so that the parser might be able to
say "Which do you mean, the long count or the short count?" if the
player asked "what is the count".

   When the parser reaches `scope=Topic', it calls the Topic routine
with the variable scope_stage set to 1.  The routine should return 1
(true) if it is prepared to allow multiple objects to be accepted here,
and 0 (false) otherwise: as we don't want "what is everything" to list
all the questions and answers in the game, we return false.

   A little later on in its machinations, the parser again calls Topic
with scope_stage now set to 2.  Topic is now obliged to tell the parser
which objects are to be in scope.  It can call two parser routines to
do this.

ScopeWithin(object)

puts everything inside the object into scope, though not the object
itself;

PlaceInScope(object)

puts just a single object into scope.  It is perfectly legal to declare
something in scope that "would have been in scope anyway": or even
something which is in a different room altogether from the actor
concerned, say at the other end of a telephone line.  Our scope routine
Topic should then return

  0. (false) to carry on with the usual scope rules, so that everything
     that would usually be in scope still is, or

  1. (true) to tell the parser not to put any more objects into scope.

So at scope_stage 2 it is quite permissible to do nothing but return
false, whereupon the usual rules apply.  Topic returns true because it
wants only question topics to be in scope, not question topics together
with the usual miscellany near the player.

   This is enough to deal with "what is the long count".  If on the
other hand the player typed "what is the lgon cnout", the error message
which the parser would usually produce ("You can't see any such thing")
would be unsatisfactory.  So if parsing failed at this token, then
Topic is called at scope_stage 3 to print out a suitable error message.
It must provide one.

!! Note that ScopeWithin(object) extends the scope down through its
possessions according to the usual rules, i.e., depending on their
transparency, whether they're containers and so on.  The definition of
Topic above shows how to put just the direct possessions into scope.

Exercise 81
-----------

   Write a token which puts everything in scope, so that you could have
a debugging "purloin" verb which could take anything, regardless of
where it was and the rules applying to it.

   *Note Answer 81::

Changing the global definition of scope should be done cautiously
(there may be unanticipated side effects); bear in mind that scope
decisions need to be taken often -- every time an object token is
parsed, so perhaps five to ten times in every game turn -- and hence
moderately quickly.  The global definition can be tampered with by
providing the entry point

InScope(actor)

where the actor is usually the player, but not always.  If the routine
decides that a particular object should be in scope for the actor, it
should execute PlaceInScope and ScopeWithin just as above, and return
true or false, as if it were at scope_stage 2.  Thus, it is vital to
return false in circumstances when you don't want to intervene.

!! The token `scope=<Routine>' takes precedence over InScope, which
will only be reached if the routine returns false to signify `carry on'.

!!!! There are seven reasons why InScope might be being called; the
scope_reason variable is set to the current one:

PARSING_REASON
     The usual one.  Note that action_to_be holds NULL in the early
     stages (before the verb has been decided) and later on the action
     which would result from a successful match.

TALKING_REASON
     Working out which objects are in scope for being spoken to (see
     the end of *Note Living Creatures:: for exercises using this).

EACHTURN_REASON
     When running each_turn routines for anything nearby, at the end of
     each turn.

REACT_BEFORE_REASON
     When running react_before.

REACT_AFTER_REASON
     When running react_after.

TESTSCOPE_REASON
     When performing a TestScope.

LOOPOVERSCOPE_REASON
     When performing a LoopOverScope.

Here are some examples.  Firstly, as promised, how to change the rule
that "things you've just dropped disappear in the dark":

[ InScope person i;
  if (person==player && location==thedark)
      objectloop (i near player)
          if (i has moved)
              PlaceInScope(i);
  rfalse;
];

With this routine added, the objects in the dark room the player is in
are in scope only if they have moved (that is, have been held by the
player in the past); and even then, are in scope only to the player.

!!!! Exercise 82
----------------

   Construct a long room divided by a glass window.  Room descriptions
on either side should describe what's in view on the other; the window
should be lookable-through; objects on the far side should be in scope,
but not manipulable; and everything should cope well if one side is in
darkness.

   *Note Answer 82::

!!!! Exercise 83
----------------

   Code the following puzzle.  In an initially dark room there is a
light switch.  Provided you've seen the switch at some time in the
past, you can turn it on and off -- but before you've ever seen it, you
can't.  Inside the room is nothing you can see, but you can hear a
dwarf breathing.  If you tell the dwarf to turn the light on, he will.

   *Note Answer 83::

As mentioned in the definition above, each object has the ability to
drag other objects into scope whenever it is in scope.  This is
especially useful for giving objects component parts: e.g., giving a
washing-machine a temperature dial.  (The dial can't be a child object
because that would throw it in with the clothes: and it ought to be
attached to the machine in case the machine is moved from place to
place.) For this purpose, the property add_to_scope may contain a list
of objects to add.

!! Alternatively, it may contain a routine.  This routine can then call
AddToScope(x) to put any object x into scope.  It may not, however,
call ScopeWithin or any other scoping routines.

!!!! Scope addition does `not' occur for an object moved into scope by
an explicit call to PlaceInScope, since this must allow complete
freedom in scope selections.  But it does happen when objects are moved
in scope by calls to ScopeWithin(domain).

Exercise 84
-----------

   (From the tiny example game `A Nasal Twinge'.)  Give the player a
nose, which is always in scope and can be held, reducing the player's
carrying capacity.

   *Note Answer 84::

Exercise 85
-----------

   (Likewise.)  Create a portable sterilising machine, with a "go"
button, a top which things can be put on and an inside to hold objects
for sterilisation.  (Thus it is a container, a supporter and a
possessor of sub-objects all at once.)

   *Note Answer 85::

!!!! Exercise 86
----------------

   Create a red sticky label which the player can affix to any object
in the game.  (Hint: use InScope, not add_to_scope.)

   *Note Answer 86::

References
----------

   * `Balances' uses `scope = <routine>' tokens for legible spells and
     memorised spells.

   * See also the exercises at the end of *Note Living Creatures:: for
     further scope trickery.


File: inform,  Node: Helping the Parser,  Prev: Scope,  Up: Describing and Parsing

Helping the parser out of trouble
=================================

!!  Once you begin programming the parser on a large scale, you soon
reach the point where the parser's ordinary error messages no longer
appear sensible.  The ParserError entry point can change the rules even
at this last hurdle: it takes one argument, the error type, and should
return true to tell the parser to shut up, because a better error
message has already been printed, or false, to tell the parser to print
its usual message.  The error types are all defined as constants:

     STUCK_PE         I didn't understand that sentence.
     UPTO_PE          I only understood you as far as...
     NUMBER_PE        I didn't understand that number.
     CANTSEE_PE       You can't see any such thing.
     TOOLIT_PE        You seem to have said too little!
     NOTHELD_PE       You aren't holding that!
     MULTI_PE         You can't use multiple objects with that verb.
     MMULTI_PE        You can only use multiple objects once on a line.
     VAGUE_PE         I'm not sure what `it' refers to.
     EXCEPT_PE        You excepted something not included anyway!
     ANIMA_PE         You can only do that to something animate.
     VERB_PE          That's not a verb I recognise.
     SCENERY_PE       That's not something you need to refer to...
     ITGONE_PE        You can't see `it' (the whatever) at the moment.
     JUNKAFTER_PE     I didn't understand the way that finished.
     TOOFEW_PE        Only five of those are available.
     NOTHING_PE       Nothing to do!
     ASKSCOPE_PE      whatever the scope routine prints

   Each unsuccessful grammar line ends in one of these conditions.  A
verb may have many lines of grammar; so by the time the parser wants to
print an error, all of them must have failed.  The error message it
prints is the most `interesting' one: meaning, lowest down this list.

!! The VAGUE_PE and ITGONE_PE apply to all pronouns (in English, "it",
"him", "her" and "them").  The variable vague_word contains the
dictionary address of which is involved ('it', 'him', etc.).

   You can find out the current setting of a pronoun using the
library's PronounValue routine: for instance, PronounValue('it') would
give the object which "it" currently refers to (possibly nothing).
Similarly SetPronoun('it', magic_ruby) would set "it" to mean the magic
ruby object.  (When something like a magic ruby suddenly appears in the
middle of a turn, players will habitually call it "it".)  A better way
to adjust the pronouns is to call PronounNotice(magic_ruby), which sets
whatever pronouns are appropriate.  That is, it works out if the object
is a thing or a person, of what number and gender, which pronouns apply
to it in the parser's current language, and so on.  In code predating
Inform 6.1 you may see variables called itobj, himobj and herobj
holding the English pronoun values: these still work properly, but
please use the modern system in new games.

!! The Inform parser resolves ambiguous inputs with a complicated
algorithm based on practical experience.  However, it can't have any
expertise with newly-created verbs: here is how to provide it.  If you
define a routine

ChooseObjects(object, code)

then it's called in two circumstances.  If code is 0 or 1, the parser
is considering including the given object in an "all": 0 means the
parser has decided against, 1 means it has decided in favour.  The
routine should reply

     0        (or false) to say ``carry on'';
     1        to force the object to be included; or
     2        to force the object to be excluded.

It may want to decide using verb_word (the variable storing the current
verb word, e.g., 'take') and action_to_be, which is the action which
would happen if the current line of grammar were successfully matched.

   The other circumstance is when code is 2.  This means the parser is
sorting through a list of items (those in scope which best matched the
input), trying to decide which single one is most likely to have been
intended.  If it can't choose a best one, it will give up and ask the
player.  ChooseObjects should then return a number from 0 to 9 (0 being
the default) to give the object a score for how appropriate it is.

   For instance, some designers would prefer "take all" not to attempt
to take scenery objects (which Inform, and the parsers in most of the
Infocom games, will do).  Let us code this, and also teach the parser
that edible things are more likely to be eaten than inedible ones:

[ ChooseObjects obj code;
  if (code<2) { if (obj has scenery) return 2; rfalse; }
  if (action_to_be==##Eat && obj has edible) return 3;
  if (obj hasnt scenery) return 2;
  return 1;
];

Scenery is now excluded from "all" lists; and is further penalised in
that non-scenery objects are always preferred over scenery, all else
being equal.  Most objects score 2 but edible things in the context of
eating score 3, so "eat black" will now always choose a Black Forest
gateau in preference to a black rod with a rusty iron star on the end.

!! Exercise 87
--------------

   Allow "lock" and "unlock" to infer their second objects without
being told, if there's an obvious choice (because the player's only
carrying one key), but to issue a disambiguation question otherwise.
(Use Extend, not ChooseObjects.)

   *Note Answer 87::

References
----------

   * See `Balances' for a usage of ParserError.


File: inform,  Node: Testing and Hacking,  Next: Appendix,  Prev: Describing and Parsing,  Up: Top

Testing and Hacking
*******************

* Menu:

* Debugging::                   Debugging verbs and tracing
* Run-Time Limitations::        Limitations on the run-time format
* Boxes::                       Boxes, menus and drawings
* Assembly Language::           Descending into assembly language


File: inform,  Node: Debugging,  Next: Run-Time Limitations,  Prev: Testing and Hacking,  Up: Testing and Hacking

Debugging verbs and tracing
===========================

     If builders built buildings the way programmers write programs,
     the first woodpecker that came along would destroy civilisation.

     -- old computing adage

Infocom claimed to have fixed nearly 2000 bugs in the course of writing
`Sorcerer', which is a relatively simple game today. Adventure games are
exhausting programs to test and debug because of the huge number of
states they can get into, many of which did not occur to the author.
(For instance, if the player solves the "last" puzzle first, do the
other puzzles still work properly?  Are they still fair?)  The main
source of error is simply the designer not noticing that some states
are possible. The Inform library can't help with this, but it does
contain features to help the tester to quickly reproduce states (by
moving objects around freely, for instance) and to see what the current
state actually is (by displaying the tree of objects, for instance).

   Inform provides a small suite of debugging verbs, which will be
added to any game compiled with the -D switch.  If you prefer, you can
include them manually by writing

Constant DEBUG;

DEBUG somewhere in the program before the library files are included.
(Just in case you forget having done this, the letter D appears in the
game banner to stop you releasing such a version by accident.)

   You then get the following verbs, which can be used at any time in
play:

showobj <anything>
purloin <anything>
abstract <anything> to <anything>
tree               tree <anything>
scope              scope <anything>
showverb <verb>
goto <number>      gonear <anything>
actions    actions on    actions off
routines   routines on   routines off
messages   messages on   messages off
timers     timers on     timers off
trace      trace on      trace off    trace <1 to 5>
recording  recording on  recording off
replay
random

"showobj" is very informative about the current state of an object.
You can "purloin" any item or items in your game at any time, wherever
you are.  This clears concealed for anything it takes, if necessary.
You can likewise "abstract" any item to any other item (meaning: move
it to the other item).  To get a listing of the objects in the game and
how they contain each other, use "tree", and to see the possessions of
one of them alone, use "tree <that>".  The command "scope" prints a
list of all the objects currently in scope, and can optionally be given
the name of someone else you want a list of the scope for (e.g., "scope
pirate").  "showverb" will display the grammar being used when the
given verb is parsed.  Finally, you can go anywhere, but since rooms
don't have names understood by the parser, you have to give either the
object number, which you can find out from the "tree" listing, or the
name of some object in the room you want to go to (this is what
"gonear" does).

   Turning on "actions" gives a trace of all the actions which take
place in the game (the parser's, the library's or yours); turning on
"routines" traces every object routine (such as before or life) that is
ever called, except for short_name (as this would look chaotic,
especially on the status line).  It also describes all messages sent in
the game, which is why it can also be written as "messages".  Turning
on "timers" shows the state of all active timers and daemons each turn.

   The commands you type can be transcribed to a file with the
"recording" verb, and run back through with the "replay" verb.  (This
may not work under some implementations of the ITF interpreter.) If
you're going to use such recordings, you will need to fix the random
number generator, and the "random" verb should render this
deterministic: i.e., after any two uses of "random", the same stream of
random numbers results.  Random number generation is poor on some
machines: you may want to Replace the random-number generator in
software instead.

A source-level debugger for Inform, called Infix, has been planned for
some years, and may possibly be coming to fruition soon.

!! For the benefit of such tools, Inform (if compiling with the -k
option set) produces a file of "debugging information"
(cross-references of the game file with the source code), and anyone
interested in writing an Inform utility program may want to know the
format of this file: see the Technical Manual for details.

On most interpreters, though, run-time crashes can be mysterious, since
the interpreters were written on the assumption that they would only
ever play Infocom game files (which are largely error-free).  A Standard
interpreter is better here and will usually tell you why and where the
problem is; given a game file address you can work back to the problem
point in the source either with Mark Howell's txd (disassembler) or by
running Inform with the assembler trace option on.

   Here are all the ways I know to crash an interpreter at run-time
(with high-level Inform code, that is; if you insist on using assembly
language or the indirect function you're raising the stakes), arranged
in decreasing order of likelihood:

   * Writing to a property which an object hasn't got;

   * Dividing by zero, possibly by calling random(0);

   * Giving a string or numerical value for a property which can only
     legally hold a routine, such as before, after or life;

   * Applying parent, child or children to the nothing object;

   * Using print object on the nothing object, or for some object which
     doesn't exist (use print (name), print (the) etc., instead as
     these are safeguarded);

   * Using print (string) or print (address) to print from an address
     outside the memory map of the game file, or an address at which no
     string is present (this will result in random text appearing,
     possibly including unprintable characters, which might crash the
     terminal);

   * Running out of stack space in a recursive loop.

!!  There are times when it's hard to work out what the parser is up to
and why (actually, most times are like this).  The parser is written in
levels, the lower levels of which are murky indeed.  Most of the
interesting things happen in the middle levels, and these are the ones
for which tracing is available.  The levels which can be traced are:

    Level 1  Grammar lines
    Level 2  Individual tokens
    Level 3  Object list parsing
    Level 4  Resolving ambiguities and making choices of object(s)
    Level 5  Comparing text against an individual object

"trace" or "trace on" give only level 1 tracing.  Be warned: "trace
five" can produce reams of text when you try anything at all
complicated: but you do sometimes want to see it, to get a list of
exactly everything that is in scope and when.  There are two levels
lower than that but they're too busy doing dull spade-work to waste
time on looking at parser_trace.  There's also a level 0, but it
consists mostly of making arrangements for level 1, and isn't very
interesting.

!!!!  Finally, though this is a drastic measure, you can always compile
your game -g (`debugging code') which gives a listing of every routine
ever called and their parameters.  This produces an enormous melee of
output.  More usefully you can declare a routine with an asterisk * as
its first local variable, which produces such tracing only for that one
routine.  For example,

[ ParseNoun * obj n m;

results in the game printing out lines like

[ParseName, obj=26, n=0, m=0]

every time the routine is called.

References
----------

   * A simple debugging verb called "xdeterm" is defined in the DEBUG
     version of `Advent', to make the game deterministic (i.e., not
     dependant on what the random number generator produces).


File: inform,  Node: Run-Time Limitations,  Next: Boxes,  Prev: Debugging,  Up: Testing and Hacking

Limitations on the run-time format
==================================

     How wide the limits stand
     Between a splendid and an happy land.
     
     -- Oliver Goldsmith (1728-1774), The Deserted Village

The Infocom run-time format is well-designed, and has three major
advantages: it is compact, widely portable and can be quickly executed.
Nevertheless, like any rigidly defined format it imposes limitations.
These are not by any means pressing.  Inform itself has a flexible
enough memory-management system not to impose artificial limits on
numbers of objects and the like.

   Games can be compiled to several "versions" of the run-time format.
Unless told otherwise Inform compiled to what used to be called
Advanced games (version 5).  It can still compile Standard games
(version 3) but doing so imposes genuine restrictions, and there is
little point any more.  Stepping up to the new version 8, on the other
hand, allows much larger games to be compiled.  Other versions exist but
are not useful to present-day game designers, so the real decision is
V5 versus V8.

Memory
     This is the only serious restriction.  The maximum size of a game
     (in K) is given by:
                              V3   V4   V5   V6   V7   V8
                              128  256  256  512  320  512
     Because games are encoded in a very compressed form, and because
     the centralised library of Inform is efficient in terms of not
     duplicating code, even 128K allows for a game at least half as
     large again as a typical old-style Infocom game.  The default
     format (V5) will hold a game as large and complex as the final
     edition of `Curses', substantially bigger than any Infocom game,
     with room to spare.  V6, the late Infocom graphical format, should
     be avoided for text games, as it is much more difficult to
     interpret.  The V8 format allows quite gargantuan games (one could
     implement, say, a merging of the `Zork' and `Enchanter' trilogies
     in it) and is recommended as the standard size for games too big
     to fit in V5.

Grammar
     The number of verbs is limited only by memory.  Each can have up
     to 20 grammar lines (one can recompile Inform with
     MAX_LINES_PER_VERB defined to a higher setting to increase this)
     and a line contains at most 6 tokens.  (Using general parsing
     routines will prevent either restriction from biting.)

Vocabulary
     There is no theoretical limit.  Typical games have vocabularies of
     between 1000 and 2000 words, but doubling that would pose no
     problem.

Dictionary resolution
     Dictionary words are truncated to their first 9 letters (except
     that non-alphabetic characters, such as hyphens, count as 2
     "letters" for this purpose).  They must begin with an alphabetic
     character and upper and lower case letters are considered equal.
     (In V3, the truncation is to 6 letters.)

Attributes, properties, names
     48 attributes and 63 common properties are available, and each
     property can hold 64 bytes of data.  Hence, for example, an object
     can have up to 32 names.  These restrictions are harmless in
     practice: except in V3, where the numbers in question are 32, 31, 8
     and 4, which begins to bite.  Note that the number of different
     individual properties is unlimited.

Special effects
     V3 games cannot have special effects such as bold face and
     underlining.  (See the next two sections.)

Objects
     Limited only by memory: except in V3, where the limit is 255.

Memory management
     The Z-machine does not allow dynamic allocation or freeing of
     memory: one must statically define an array to a suitable maximum
     size and live within it.  This restriction greatly increases the
     portability of the format, and the designer's confidence that the
     game's behaviour is genuinely independent of the machine it's
     running on: memory allocation at run-time is a fraught process on
     many machines.

Global variables
     There can only be 240 of these, and the Inform compiler uses 5 as
     scratch space, while the library uses slightly over 100; but since
     a typical game uses only a dozen of its own, code being almost
     always object-oriented, the restriction is never felt.  An
     unlimited number of Array statements is permitted and array
     entries do not, of course, count towards the 240.

"Undo"
     No "undo" verb is available in V3.

Function calls
     A function can be called with at most 7 arguments.  (Or, in V3 and
     V4, at most 3.)

Recursion and stack usage
     The limit on this is rather technical (see the Z-Machine Standards
     Document).  Roughly speaking, recursion is permitted to a depth of
     90 routines in almost all circumstances (and often much deeper).
     Direct usage of the stack via assembly language must be modest.

!! If memory does become short, there is a standard mechanism for
saving about 8-10% of the memory.  Inform does not usually trouble to,
since there's very seldom the need, and it makes the compiler run about
10% slower.  What you need to do is define abbreviations and then run
the compiler in its "economy" mode (using the switch -e).  For
instance, the directive

Abbreviate " the ";

(placed before any text appears) will cause the string " the " to be
internally stored as a single `letter', saving memory every time it
occurs (about 2500 times in `Curses', for instance).  You can have up
to 64 abbreviations.  When choosing abbreviations, avoid proper nouns
and instead pick on short combinations of a space and common two- or
three-letter blocks.  Good choices include " the ", "The", ", ", "and",
"you", " a ", "ing", " to".  You can even get Inform to work out by
itself what a good stock of abbreviations would be: but be warned, this
makes the compiler run about 29000% slower.


File: inform,  Node: Boxes,  Next: Assembly Language,  Prev: Run-Time Limitations,  Up: Testing and Hacking

Boxes, menus and drawings
=========================

     Yes, all right, I won't do the menu... I don't think you realise
     how long it takes to do the menu, but no, it doesn't matter, I'll
     hang the picture now.  If the menus are late for lunch it doesn't
     matter, the guests can all come and look at the picture till they
     are ready, right?

     -- John Cleese and Connie Booth, Fawlty Towers

One harmless effect, though not very special, is to ask the player a
yes/no question.  To do this, print up the question and then call the
library routine YesOrNo, which returns true/false accordingly.

   The status line is perhaps the most distinctive feature of Infocom
games in play.  This is the (usually highlighted) bar across the top of
the screen.  Usually, the game automatically prints the current game
location, and either the time or the score and number of turns taken.
It has the score/turns format unless the directive

     Statusline time;

has been written in the program, in which case the game's 24-hour clock
is displayed.

!! If you want to change this, just Replace the parser's private
DrawStatusLine routine.  This requires a little assembly language: see
the next section for numerous examples.

About character graphic drawings: on some machines, text will by default
be displayed in a proportional font (i.e., one in which the width of a
letter depends on what it is, so that for example an `i' will be
narrower than an `m').  If you want to display a diagram made up of
letters, such as a map, the spacing may then be wrong.  The statement
font off ensures that any fancy font is switched off and that a
fixed-pitch one is being used: after this, font on restores the usual
state.

   *Warning:* Don't turn the font on and off in the middle of a line;
this doesn't look right on some machines.

!! When trying to produce a character-graphics drawing, you sometimes
want to produce the \ character, one of the four "escape characters"
which can't normally be included in text.  A double @ sign followed by
a number includes the character with that ASCII code; thus:

     @@64 produces the literal character @
     @@92 produces \        @@94 produces ^
             @@126 produces ~

!!!! Some interpreters are capable of much better character graphics
(those equipped to run the Infocom game `Beyond Zork', for instance).
There is a way to find out if this feature is provided and to make use
of it: see the Z-Machine Standards Document.

!!!! A single @ sign is also an escape character.  It must be followed
by a 2-digit decimal number between 0 and 31 (for instance, @05).  What
this prints is the n-th `variable string'.  This feature is not as
useful as it looks, since the only legal values for such a variable
string are strings declared in advance by a LowString directive.  The
String statement then sets the n-th variable string.  For details and
an example, see the answer to the east-west reversal exercise in *Note
Places::.

A distinctive feature of later Infocom games was their use of epigrams.
The assembly language required to produce this effect is easy but a
nuisance, so there is an Inform statement to do it, box.  For example,

box "I might repeat to myself, slowly and soothingly,"
    "a list of quotations beautiful from minds profound;"
    "if I can remember any of the damn things."
    ""
    "-- Dorothy Parker";

Note that a list of one or more lines is given (without intervening
commas) and that a blank line is given by a null string.  Remember that
the text cannot be too wide or it will look awful on a small screen.
Inform will automatically insert the boxed text into the game
transcript, if one is being made.  The author takes the view that this
device is amusing for irrelevant quotations but irritating when it
conveys vital information (such as "Beware of the Dog").  Also, some
people might be running your game on a laptop with a vertically
challenged screen, so it is polite to provide a "quotes off" verb.

   A snag with printing boxes is that if you do it in the middle of a
turn then it will probably scroll half-off the screen by the time the
game finishes printing for the turn.  The right time to do so is just
after the prompt (usually >) is printed, when the screen will definitely
scroll no more.  You could use the Prompt: slot in LibraryMessages to
achieve this, but a more convenient way is to put your box-printing
into the entry point AfterPrompt (called at this time each turn).

Exercise 88
-----------

   Implement a routine Quote(n) which will arrange for the n-th
quotation (where 0 <= n <= 49) to be displayed at the end of this turn,
provided it hasn't been quoted before.

   *Note Answer 88::

Sometimes one would like to provide a menu of text options (for
instance, when producing instructions which have several topics, or
when giving clues).  This can be done with the DoMenu routine, which
imitates the traditional "Invisiclues" style.  By setting pretty_flag=0
you can make a simple text version instead; a good idea for machines
with very small screens.  Here is a typical call to DoMenu:

DoMenu("There is information provided on the following:^
        ^     Instructions for playing
        ^     The history of this game
        ^     Credits^",
        HelpMenu, HelpInfo);

Note the layout, and especially the carriage returns.  The second and
third arguments are themselves routines.  (Actually the first argument
can also be a routine to print a string instead of the string itself,
which might be useful for adaptive hints.)  The HelpMenu routine is
supposed to look at the variable menu_item.  In the case when this is
zero, it should return the number of entries in the menu (3 in the
example).  In any case it should set item_name to the title for the
page of information for that item; and item_width to half its length in
characters (this is used to centre titles on the screen).  In the case
of item 0, the title should be that for the whole menu.

   The second routine, HelpInfo above, should simply look at menu_item
(1 to 3 above) and print the text for that selection.  After this
returns, normally the game prints "Press [Space] to return to menu" but
if the value 2 is returned it doesn't wait, and if the value 3 is
returned it automatically quits the menu as if Q had been pressed.
This is useful for juggling submenus about.

   Menu items can safely launch whole new menus, and it is easy to make
a tree of these (which will be needed when it comes to providing hints
across any size of game).

Exercise 89
-----------

   Code an "Invisiclues"-style sequence of hints for a puzzle, revealed
one at a time, as a menu item.

   *Note Answer 89::

Finally, you can change the text style.  The statement for this is
style and its effects are loosely modelled on the VT100 (design of
terminal). The style can be style roman, style bold, style reverse or
style underline.  Again, poor terminals may not be able to display
these, so you shouldn't hide crucial information in them.

References
----------

   * `Advent' contains a menu much like that above.

   * The "Infoclues" utility program translates UHS format hints (a
     standard, easy to read and write layout) into an Inform file of
     calls to DoMenu which can simply be included into a game; this
     saves a good deal of trouble.


File: inform,  Node: Assembly Language,  Prev: Boxes,  Up: Testing and Hacking

Descending into assembly language
=================================

!!!!!! Some dirty tricks require bypassing all of Inform's higher levels
to program the Z-machine directly with assembly language.  There is an
element of danger in this, in that some combinations of unusual opcodes
might look ugly on some incomplete or wrongly-written interpreters: so
if you're doing anything complicated, test it as widely as possible.

The best-researched and most reliable interpreters available by far are
Mark Howell's Zip and Stefan Jokisch's Frotz: they are also faster than
their only serious rival, the InfoTaskForce, a historically important
work which is fairly thorough (and should give little trouble in
practice) but which was written when the format was a little less well
understood.  In some ports, ITF gets rarer screen effects wrong, and it
lacks an "undo" feature, so the Inform "undo" verb won't work under ITF.
(The other two publically-available interpreters are pinfocom and zterp,
but these are unable to run Advanced games.  In the last resort,
sometimes it's possible to use one of Infocom's own supplied
interpreters with a different game from that it came with; but only
sometimes, as they may have inconvenient filenames `wired into them'.)

   Interpreters conforming to the Z-Machine Standard, usually but not
always derived from Frotz or Zip, are reliable and widely available.
But remember that one source of unportability is inevitable.  Your game
may be running on a screen which is anything from a 64 characters by 9
pocket organiser LCD display, up to a 132 by 48 window on a 21-inch
monitor.

   Anyone wanting to really push the outer limits (say, by implementing
Space Invaders or NetHack) will need to refer to The Z-Machine
Standards Document.  This is much more detailed (the definition of
aread alone runs for two pages) and covers the whole range of assembly
language.  However, this section does document all those features which
can't be better obtained with higher-level code.

Lines of assembly language must begin with an @ character and then the
name of the "opcode" (i.e., assembly language statement).  A number of
arguments, or "operands" follow (how many depends on the opcode): these
may be any Inform constants, local or global variables or the stack
pointer sp, but may not be compound expressions.  sp does not behave
like a variable: writing a value to it pushes that value onto the
stack, whereas reading the value of it (for instance, by giving it as
an operand) pulls the top value off the stack.  Don't use sp unless you
have to.  After the operands, some opcodes require a variable (or sp)
to write a result into.  The opcodes documented in this section are as
follows:

@split_window    lines
@set_window      window
@set_cursor      line column
@buffer_mode     flag
@erase_window    window
@set_colour      foreground background
@aread           text parse time function <result>
@read_char       1 time function <result>
@tokenise        text parse dictionary
@encode_text     ascii-text length from coded-text
@output_stream   number table
@input_stream    number
@catch           <result>
@throw           value stack-frame
@save            buffer length filename <result>
@restore         buffer length filename <result>

@split_window    lines

Splits off an upper-level window of the given number of lines in height
from the main screen.  This upper window usually holds the status line
and can be resized at any time: nothing visible happens until the
window is printed to.  Warning: make the upper window tall enough to
include all the lines you want to write to it, as it should not be
allowed to scroll.

@set_window      window

The text part of the screen (the lower window) is "window 0", the
status line (the upper one) is window 1; this opcode selects which one
text is to be printed into.  Each window has a "cursor position" at
which text is being printed, though it can only be set for the upper
window.  Printing on the upper window overlies printing on the lower,
is always done in a fixed-pitch font and does not appear in a printed
transcript of the game.  Note that before printing to the upper window,
it is wise to use @buffer_mode to turn off word-breaking.

@set_cursor      line column

Places the cursor inside the upper window, where (1,1) is the top left
character.

@buffer_mode     flag

This turns on (flag=1) or off (flag=0) word-breaking for the current
window (that is, the practice of printing new-lines only at the ends of
words, so that text is neatly formatted).  It is wise to turn off
word-breaking while printing to the upper window.

@erase_window    window

This opcode is unfortunately incorrectly implemented on some
interpreters and so it can't safely be used to erase individual
windows.  However, it can be used with window=-1, and then clears the
entire screen.  Don't do this in reverse video mode, as a bad
interpreter may (incorrectly) wipe the entire screen in reversed
colours.

@set_colour      foreground background

If coloured text is available, set text to be
foreground-against-background.  The colour numbers are borrowed from
the IBM PC:

2 = black,  3 = red,      4 = green,  5 = yellow,
6 = blue,   7 = magenta,  8 = cyan,   9 = white
0 = the current setting,  1 = the default.

On many machines coloured text is not available: the opcode will then
do nothing.

@aread           text parse time function <result>

The keyboard can be read in remarkably flexible ways.  This opcode
reads a line of text from the keyboard, writing it into the text string
array and `tokenising' it into a word stream, with details stored in
the parse string array (unless this is zero, in which case no
tokenisation happens).  (See the end of *Note Grammar Tokens:: for the
format of text and parse.) While it is doing this, it calls
function(time) every time tenths of a second while the user is thinking:
the process ends if ever this function returns true.  <result> is to be
a variable, but the value written in it is only meaningful if you're
using a "terminating characters table".  Thus (by Replaceing the
Keyboard routine in the library files) you could, say, move around all
the characters every ten seconds of real time.  Warning: not every
interpreter supports this real-time feature, and most of those that do
count in seconds instead of tenths of seconds.

@read_char       1 time function <result>

results in the ASCII value of a single keypress.  Once again, the
function is called every time tenths of a second and may stop this
process early.  Function keys return special values from 129 onwards,
in the order: cursor up, down, left, right, function key f1, ..., f12,
keypad digit 0, ..., 9.  The first operand must be 1 (used by Infocom
as a device number to identify the keyboard).

@tokenise        text parse dictionary

This takes the text in the text buffer (in the format produced by aread)
and tokenises it (i.e. breaks it up into words, finds their addresses
in the dictionary) into the parse buffer in the usual way but using the
given dictionary instead of the game's usual one.  (See the Z-Machine
Standards Document for the dictionary format.)

@encode_text     ascii-text length from coded-text

Translates an ASCII word to the internal (Z-encoded) text format
suitable for use in a @tokenise dictionary.  The text begins at from in
the ascii-text and is length characters long, which should contain the
right length value (though in fact the interpreter translates the word
as far as a 0 terminator).  The result is 6 bytes long and usually
represents between 1 and 9 letters.

@output_stream   number table

Text can be output to a variety of different `streams', possibly
simultaneously.  If number is 0 this does nothing.  +n switches stream
n on, -n switches it off.  The output streams are: 1 (the screen), 2
(the game transcript), 3 (memory) and 4 (script of player's commands).
The table can be omitted except for stream 3, when it's a table array
holding the text printed; printing to this stream is never word-broken,
whatever the state of @buffer_mode.

@input_stream    number

Switches the `input stream' (the source of the player's commands).  0
is the keyboard, and 1 a command file (the idea is that a list of
commands produced by output_stream 4 can be fed back in again).

@catch           <result>

The opposite of throw, catch preserves the "stack frame" of the current
routine: meaning, roughly, the current position of which routine is
being run and which ones have called it so far.

@throw           value stack-frame

This causes the program to execute a return with value, but as if it
were returning from the routine which was running when the stack-frame
was caught (see catch).  Any routines which were called in the mean
time and haven't returned yet (because each one called the next) are
forgotten about.  This is useful to get the program out of large
recursive tangles in a hurry.

@save            buffer length filename <result>

Saves the byte array buffer (of size length) to a file, whose (default)
name is given in the filename (a string array).  Afterwards, result
holds 1 on success, 0 on failure.

@restore          buffer length filename <result>

Loads in the byte array buffer (of size length) from a file, whose
(default) name is given in the filename (a string array).  Afterwards,
result holds the number of bytes successfully read.

   *Warning:* Some of these features may not work well on obsolete
interpreters which do not adhere to the Z-Machine Standard.  Standard
interpreters are widely available, but if seriously worried you can
test whether your game is running on a good interpreter:

    if (standard_interpreter == 0)
    {   print "This game must be played on an interpreter obeying the
               Z-Machine Standard.^";
        @quit;
    }

Exercise 90
-----------

   In a role-playing game campaign, you might want several scenarios,
each implemented as a separate Inform game.  How could the character
from one be saved and loaded into another?

   *Note Answer 90::

!! Exercise 91
--------------

   Design a title page for `Ruins', displaying a more or less apposite
quotation and waiting for a key to be pressed.

   *Note Answer 91::

!! Exercise 92
--------------

   Change the status line so that it has the usual score/moves
appearance except when a variable invisible_status is set, when it's
invisible.

   *Note Answer 92::

!! Exercise 93
--------------

   Alter the `Advent' example game to display the number of treasures
found instead of the score and turns on the status line.

   *Note Answer 93::

!! Exercise 94
--------------

   (From code by Joachim Baumann.)  Put a compass rose on the status
line, displaying the directions in which the room can be left.

   *Note Answer 94::

!!!! Exercise 95
----------------

   (Cf. `Trinity'.) Make the status line consist only of the name of
the current location, centred in the top line of the screen.

   *Note Answer 95::

!!!! Exercise 96
----------------

   Implement an Inform version of the standard `C' routine printf,
taking the form

    printf(format, arg1, ...)

to print out the format string but with escape sequences like %d
replaced by the arguments (printed in various ways).  For example,

    printf("The score is %e out of %e.", score, MAX_SCORE);

should print something like "The score is five out of ten."

   *Note Answer 96::

References
----------

   * The assembly-language connoisseur will appreciate `Freefall' by
     Andrew Plotkin and `Robots' by Torbjorn Andersson, although the
     present lack of on-line hints make these difficult games to win.
