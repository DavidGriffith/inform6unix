This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Living Creatures,  Next: Light and Dark,  Prev: Reading Matter,  Up: The Model World

Living creatures and conversation
=================================

     To know how to live is my trade and my art.
     
     -- Michel de Montaigne (1533-1592), Essays

     Everything that can be said can be said clearly.
     
     -- Ludwig Wittgenstein (1889-1951), Tractatus

This rummage through special kinds of objects finishes up with the most
sophisticated kind: living ones.  Note that the finer points of this
section, on the arts of conversation, require some knowledge of Chapter
V.

   Animate objects, such as sea monsters, mad aunts or nasty little
dwarves, have a property called life.  This behaves somewhat like a
before or after routine, but only applies to the following actions:

Attack
     The player is making hostile advances...

Kiss
     ...or excessively friendly ones...

WakeOther
     ...or simply trying to rouse the creature from sleep.

ThrowAt
     The player asked to throw noun at the creature.

Give
     The player asked to give noun to the creature...

Show
     ...or, tantalisingly, just to show it.

Ask
     The player asked about something.  Just as with a "consult" topic
     (see *Note Reading Matter:: passim), the variables consult_from
     and consult_words are set up to indicate which words the object
     might like to think about.  (In addition, second holds the
     dictionary value for the first word which isn't 'the', but this is
     much cruder.)

Tell
     Likewise, the player is trying to tell the creature about
     something.  The topic is set up just as for Ask (that is,
     consult_from and consult_words are set, and second also holds the
     first interesting word).

Answer
     This can happen in two ways.  One is if the player types "answer
     <some text> to troll" or "say <some text> to troll"; the other is
     if he gives an order which the parser can't sort out, such as
     "troll, og south", and which the orders property hasn't handled
     already.  Once again, variables are set as if it were a "consult"
     topic.  (In addition, noun is set to the first word, and an
     attempt to read the text as a number is stored in the variable
     special_number: for instance, "computer, 143" will cause
     special_number to be set to 143.)

Order
     This catches any `orders' which aren't handled by the orders
     property (see below); action, noun and second are set up as usual.

If the life routine doesn't exist, or returns false, events take their
usual course.  life routines tend to be quite lengthy, even for
relatively static characters such as the priest who stands in the
`Ruins' Shrine:

Object -> priest "mummified priest"
  with name "mummified" "priest",
       description
          "He is desiccated and hangs together only by will-power.  Though
           his first language is presumably local Mayan, you have the curious
           instinct that he will understand your speech.",
       initial "Behind the slab, a mummified priest stands waiting, barely
           alive at best, impossibly venerable.",
       life
       [; Answer: "The priest coughs, and almost falls apart.";
          Ask:     switch(second)
                   {   'dictionary', 'book':
                            if (dictionary has general)
                                "~The ~bird~ glyph... very funny.~";
                           "~A dictionary? Really?~";
                       'glyph', 'glyphs', 'mayan', 'dialect':
                           "~In our culture, the Priests are ever literate.~";
                       'king', 'tomb', 'shrine', 'temple', 'altar', 'slab':
                           "~The King (life! prosperity! happiness!) is buried
                            deep under this Shrine, where you will never go.~";
                   }
                   "~You must find your own answer.~";
          Tell:   "The priest has no interest in your sordid life.";
          Attack, Kiss:  remove self;
                  "The priest desiccates away into dust until nothing
                   remains, not a breeze nor a bone.";
          ThrowAt: move noun to location; <<Attack self>>;
          Show, Give:
                   if (noun==dictionary && dictionary hasnt general)
                   {   give dictionary general;
                      "The priest reads a little of the book, laughing
                       in a hollow, whispering way.  Unable to restrain
                       his mirth, he scratches in a correction somewhere
                       before returning the book.";
                   }
                  "The priest is not very interested in earthly things.";
       ],
  has  animate;

(Some of the Ask topics are omitted for brevity.) Of course an animate
object still has before and after routines like any other, so you can
trap many other kinds of behaviour.  Animate creatures can also
react_before and react_after, and it's here that these properties
really come into their own:

       react_before
       [; Drop: if (noun==satellite_gadget)
             print "~I wouldn't do that, Mr Bond,~ says Blofeld.^^";
          Shoot: remove beretta;
            "As you draw, Blofeld snaps his fingers and a giant
             magnet snatches the gun from your hand.  It hits the
             ceiling with a clang.  Blofeld silkily strokes his cat.";
       ];

If Blofeld moves from place to place, these rules move with him.

Exercise 18
-----------

   Arrange for a bearded psychiatrist to place the player under
observation, occasionally mumbling insights such as "Subject puts green
cone on table.  Interesting."

   *Note Answer 18::

Another example is the coiled snake from `Balances', which shows that
even the tiniest life routine can be adequate for an animal:

Object -> snake "hissing snake"
  with name "hissing" "snake",
       initial "Tightly coiled at the edge of the chasm is a hissing snake.",
       life [; "The snake hisses angrily!"; ],
  has  animate;

!! When writing general code to deal with animate creatures, it's
sometimes convenient to have a system worked out for printing pronouns
such as "her" and "He".  See *Note Describing Objects:: for one way to
do this.

Sometimes creatures should be transparent, sometimes not.  Consider
these two cases of animate characters, for instance:

   * an urchin with something bulging inside his jacket pocket;

   * a hacker who has a bunch of keys hanging off his belt.

The hacker is transparent, the urchin not.  That way the parser prevents
the player from referring to whatever the urchin is hiding, even if the
player has played the game before, and knows what is in there and what
it's called.  But the player can look at and be tantalised by the
hacker's keys.

When the player types in something like "pilot, fly south", the result
is called an `order': this is the corresponding idea to an `action'.
(Indeed, if the player types "me, go south" an ordinary Go s_obj action
is produced.)

   The order is sent to the pilot's orders property, which may if it
wishes obey or react in some other way.  Otherwise, the standard game
rules will simply print something like "The pilot has better things to
do."  The above priest is especially unhelpful:

       orders
       [;  Go: "~I must not leave the Shrine.~";
           NotUnderstood: "~You speak in riddles.~";
           default: "~It is not your orders I serve.~";
       ];

(The NotUnderstood clause is run when the parser couldn't understand
what the player typed: e.g., "priest, go onrth".)

!! Something to bear in mind is that because the library regards the
words "yes" and "no" as being verbs in Inform, it understands "delores,
yes" as being a Yes order.  (This can be a slight nuisance, as "say yes
to delores" is treated differently: it gets routed through the life
routine as an Answer.)

!!!! If the orders property returns false (or if there wasn't an orders
property in the first place), the order is sent either to the Order:
part of the life property (if it's understood) or to the Answer: part
(if it isn't).  (This is how all orders used to be processed, and it's
retained to avoid making reams of old Inform code go wrong.)  If these
also return false, a message like "X has better things to do" or "There
is no reply" is finally printed.

To clarify the various kinds of conversation:

Command                     rule     action    noun      second    consult
"orc, take axe"             order    Take      axe       0
"orc, yes"                  order    Yes       0         0
"ask orc for the shield"    order    Give      shield    player
"orc, troll"                order    NotU...   'troll'   orc       3  1
"say troll to orc"          life     Answer    'troll'   orc       2  1
"answer troll to orc"       life     Answer    'troll'   orc       2  1
"orc, tell me about coins"  life     Ask       orc       'coins'   6  1
"ask orc about the big troll" life   Ask       orc       'big'     4  3
"ask orc about wyvern"      life     Ask       orc       0         4  1
"tell orc about lost troll" life     Tell      orc       'lost'    4  2

where "wyvern" is a word not mentioned anywhere in the program, which
is why its value is 0.

Exercise 19
-----------

   In some ways, Answer and Tell are just too much trouble.  How can
you make attempts to use these produce a message saying "To talk to
someone, try `someone, something'."?

   *Note Answer 19::

Some objects are not alive as such, but can be spoken to: microphones,
tape recorders, voice-activated computers and so on.  It would be a
nuisance to implement these as animate, since they have none of the
other characteristics of life: instead, they can be given just the
attribute talkable and orders and life properties to deal with the
resulting conversation.

Exercise 20
-----------

   (Cf. `Starcross'.)  Construct a computer responding to "computer,
theta is 180".

   *Note Answer 20::

!! The rest of this section starts to overlap much more with Chapter V,
and assumes a little familiarity with the parser.

!! The NotUnderstood clause of orders is run when the parser has got
stuck parsing an order like "pilot, fly somersaults".  The variable
etype holds the parser error that would have been printed out, had it
been a command by the player himself.  See *Note Helping the Parser:::
for instance, CANTSEE_PE would mean "the pilot can't see any such
object".

!!  When the player issues requests to an animate or talkable object,
they're normally parsed exactly as if they were commands by the player
himself (except that the actor is now the person being spoken to).  But
sometimes one would rather they were parsed by an entirely different
grammar.  For instance, consider Zen, the flight computer of an alien
spacecraft.  It's inappropriate to tell Zen to (say) pick up a teleport
bracelet and the crew tend to give commands more like:

     ``Zen, set course for Centauro''
     ``Zen, speed standard by six''
     ``Zen, scan 360 orbital''
     ``Zen, raise the force wall''
     ``Zen, clear the neutron blasters for firing''

This could mostly be implemented by adding verbs like "raise" to the
usual game grammar (see the `Starcross' computer exercise above), or by
carefully trapping the Answer rule.  But this is a nuisance, especially
if about half the commands you want are recognised as orders in the
usual grammar but the other half aren't.

   An animate or talkable object can therefore provide a grammar
routine (if it likes).  This is called at a time when the parser has
worked out the object that is being addressed and has set the variables
verb_num and verb_word (to the number of the `verb' and its dictionary
entry, respectively: for example, in "orac, operate the teleport"
verb_num would be 3 (because the comma counts as a word on its own) and
verb_word would be 'operate').  The grammar routine can reply by
returning:

0.
     The parser carries on as usual.

1.
     The grammar routine is saying it has done all the parsing necessary
     itself, by hand (i.e., using NextWord, TryNumber, NounDomain and
     the like): the variables action, noun and second must be set up to
     contain the resulting order.

'verb'
     The parser ignores the usual grammar and instead works through the
     grammar lines for the given verb (see below).

-'verb'
     Ditto, except that if none of those grammar lines work then the
     parser goes back and tries the usual grammar as well.

In addition, the grammar routine is free to do some partial parsing of
the early words provided it moves on verb_num accordingly to show how
much it's got through.

!! Exercise 21
--------------

   Implement Charlotte, a little girl who's playing Simon Says (a game
in which she only follows your instructions if you remember to say
"Simon says" in front of them: so she'll disobey "charlotte, wave" but
obey "charlotte, simon says wave").

   *Note Answer 21::

!! Exercise 22
--------------

   Another of Charlotte's rules is that if you say a number, she has to
clap that many times.  Can you play?

   *Note Answer 22::

!! Exercise 23
--------------

   Regrettably, Dyslexic Dan has always mixed up the words "take" and
"drop".  Implement him anyway.

   *Note Answer 23::

!! It's useful to know that if the player types a comma or a full stop,
then the parser cuts these out as separate words.  Because of this, a
dictionary word containing up to 7 letters and then a comma or a full
stop can never be matched by what the player types.  Such a word is
called an "untypeable verb", and it's useful to help a grammar routine
to shunt parsing into a piece of game grammar which the player can
never use.  For instance, here's a way to implement the `Starcross'
computer which doesn't involve creating foolish new actions.  We create
grammar:

[ Control;
  switch(NextWord())
  {   'theta': parsed_number=1; return 1;
      'phi':   parsed_number=2; return 1;
      'range': parsed_number=3; return 1;
      default: return -1;
  }
];
Verb "comp," * Control "is" number -> SetTo;

And the computer itself needs properties

       grammar [; return 'comp,'; ],
       orders
       [;  SetTo:
               switch(noun)
               {   1: print "~Theta"; 2: print "~Phi"; 3: print "~Range"; }
               print_ret " set to ", second, ".~";
           default: "~Does not compute!~";
       ];

This may not look easier, but it's much more flexible, as the exercises
below will hopefully demonstrate.

!!!! Another use for untypeable verbs is to create what might be called
`fake fake actions'.  Recall that a fake action is one which is never
generated by the parser, and has no action routine.  Sometimes (very
rarely) you want a proper action but which still can't be generated by
the parser: the following example creates three.

Verb "actions." * -> Prepare * -> Simmer * -> Cook;

The parser never uses "actions." in its ordinary grammar, so this
definition has the sole effect of creating three new actions: Prepare,
Simmer and Cook.

!!!! Exercise 24
----------------

   How can you make a grammar extension to an ordinary verb that will
apply only to Dan?

   *Note Answer 24::

!! Exercise 25
--------------

   Make an alarm clock responding to "alarm, off", "alarm, on" and
"alarm, half past seven" (the latter to set its alarm time).

   *Note Answer 25::

!! Exercise 26
--------------

   Implement a tricorder (from Star Trek) which analyses nearby objects
on a request like "tricorder, the quartz stratum".

   *Note Answer 26::

!! Exercise 27
--------------

   And, for good measure, a replicator responding to commands like
"replicator, tea earl grey" and "replicator, aldebaran brandy".

   *Note Answer 27::

!!!! Exercise 28
----------------

   And a communications badge in contact with the ship's computer,
which answers questions like "computer, where is Admiral Lebling".

   *Note Answer 28::

!!!! Exercise 29
----------------

   Finally, construct the formidable flight computer Zen.

   *Note Answer 29::

The next two exercises really belong to *Note Scope::, but are too
useful (for the "someone on the other end of a phone" situation) to
bury far away.  Note that an alternative to these scope-hacking tricks,
if you just want to implement something like "michael, tell me about
the crystals" (when Michael is at the other end of the line), is to
make the phone a talkable object and make the word 'michael' refer to
the phone (using a parse_name routine).

   For more on scope hacking, see *Note Scope::.  Note that the
variable scope_reason is always set to the constant value
TALKING_REASON when the game is trying to work out who you wish to talk
to: so it's quite easy to make the scope different for conversational
purposes.

!! Exercise 30
--------------

   Via the main screen of the Starship Enterprise, Captain Picard wants
to see and talk to Noslen Maharg, the notorious tyrant, who is down on
the planet Mrofni.  Make it so.

   *Note Answer 30::

!!!! Exercise 31
----------------

   Put the player in telepathic contact with Martha, who is in a sealed
room some distance away, but who has a talent for telekinesis.  Martha
should respond well to "martha, look", "ask martha about...", "say yes
to martha", "ask martha for red ball", "martha, give me the red ball"
and the like.

   *Note Answer 31::

References
----------

   * A much fuller example of a `non-player character' is given in the
     example game `The Thief', by Gareth Rees (though it's really an
     implementation of the gentleman in `Zork', himself an imitation of
     the pirate in `Advent').  The thief is capable of walking around,
     being followed, stealing things, picking locks, opening doors and
     so on.

   * Other good definitions of animate objects to look at are
     Christopher in `Toyshop', who will stack up building blocks on
     request; the kittens in `Alice Through The Looking-Glass'; the
     barker in `Balances', and the cast of `Advent': the little bird,
     the snake, bear and dragon, the pirate and of course the
     threatening little dwarves.

   * Following people means being able to refer to them after they've
     left the room: see `Follow my leader', also by Mr Rees, or the
     library extension "follower.h" by Andrew Clover.

   * See the Inform home page for a way round the Yes awkwardness.

   * For parsing topics of conversation in advanced ways, see the
     example game `Encyclopaedia Frobozzica' by Gareth Rees.

   * To see how much a good set of characters can do for a game, try
     playing the prologue of `Christminster'.


File: inform,  Node: Light and Dark,  Next: Daemons,  Prev: Living Creatures,  Up: The Model World

The light and the dark
======================

The library maintains light by itself, and copes with events like:

     a total eclipse of the sun;
     fusing all the lights in the house;
     your lamp going out;
     a dwarf stealing it and running away;
     dropping a lit match which you were seeing by;
     putting your lamp into an opaque box and shutting the lid;
     black smoke filling up the glass jar that the lamp is in;
     the dwarf with your lamp running back into your now-dark room.

The point of this list is to demonstrate that light versus darkness is
tricky to get right, and best left to the library.  Your code needs
only to do something like

     give lamp light;
     remove match;
     give glass_jar ~transparent;
     move dwarf to Dark_Room;

and can leave the library to sort out the consequences.  As the above
suggests, the light attribute means that an object is giving off light,
or that a room is currently lit, e.g. because it is outdoors in
day-time.  If you simply never want to have darkness, a sneaky way of
doing it is to put the line

     give player light;

in Initialise.  The game works as if the player herself were glowing
enough to provide light to see by.  So there's never darkness near the
player.

   The definition of "when there is light" is complicated, involving
recursion both up and down.  Remember that the parent of the player
object may not be a room; it may be, say, a red car whose parent is a
room.

*Definition.* There is light exactly when the parent of the player
`offers light'.  An object `offers light' if:

     it itself has the light attribute set, *or*
     any of its immediate possessions `have light', *or*
     it is see-through and its parent offers light;

while an object `has light' if:

     it currently has the light attribute set, *or*
     it is see-through and one of its immediate possessions has light, *or*
     any of the things it ``adds to scope'' (see Chapter V) have light.

The process of checking this stops as soon as light is discovered.  The
routines

     OffersLight(object) and HasLightSource(object)

return true or false and might occasionally be useful.

!! So light is cast up and down the tree of objects.  In certain
contrived circumstances this might be troublesome: perhaps an opaque
box, whose outside is fluorescent but whose interior is dark, and which
contains an actor who needs not to have other contents of the box in
scope...  The dilemma could be solved by putting an inner box in the
outer one.

Exercise 32
-----------

   How would you code a troll who is afraid of the dark, and needs to
be bribed but will only accept a light source... so that the troll will
be as happy with a goldfish bowl containing a fluorescent jellyfish as
he would be with a lamp?

   *Note Answer 32::

Each turn, light is reconsidered.  The presence or absence of light
affects the Look, Search, LookUnder and Examine actions, and (since
this is a common puzzle) also the Go action: you can provide a routine
called

     DarkToDark()

and if you do then it will be called when the player goes from one dark
room into another dark one (just before the room description for the new
dark room, probably "Darkness", is printed).  If you want, you can take
the opportunity to kill the player off or extract some other forfeit.
If you provide no such routine, then the player can move about freely
(subject to any rules which apply in the places concerned).

!! When the player is in darkness, the current location becomes
thedark, a special object which acts like a room and has the short name
"Darkness".  You can change the initial, description or short_name
properties for this.  For example, your Initialise routine might set

    thedark.short_name = "Creepy, nasty darkness";

See *Note Daemons:: for how `Ruins' makes darkness menacing.

!! Exercise 33
--------------

   Implement a pet moth which escapes if it's ever taken into darkness.

   *Note Answer 33::

References
----------

   * For a DarkToDark routine which discourages wandering about caves
     in the dark, see `Advent'.


File: inform,  Node: Daemons,  Next: Player,  Prev: Light and Dark,  Up: The Model World

Daemons and the passing of time
===============================

     Some, such as Sleep and Love, were never human.  From this class
     an individual daemon is allotted to each human being as his
     `witness and guardian' through life.

     -- C. S. Lewis (1898-1963), The Discarded Image

     A great Daemon... Through him subsist all divination, and the
     science of sacred things as it relates to sacrifices, and
     expiations, and disenchantments, and prophecy, and magic... he who
     is wise in the science of this intercourse is supremely happy...\

     -- Plato (c.427-347 BC), `The Symposium'
     -- translated by Percy Bysshe Shelley (1792-1822)

In medieval neo-Platonist philosophy, daemons are the intermediaries of
God, hovering invisibly over the world and interfering with it.  They
may be guardian spirits of places or people.  So, here, a daemon is a
meddling spirit, associated with a particular game object, which gets a
chance to interfere once per turn while it is `active'.  The classic
example is of the dwarves of `Advent', who appear in the cave from time
to time: a daemon routine attached to the dwarf object moves it about,
throws knives at the player and so on.  Each object can have a daemon
routine of its own.  This is set going, and stopped again, by calling
the (library) routines

     StartDaemon(object);
     StopDaemon(object);

Once active, the daemon property of the object is called as a routine
each turn.  Daemons are often started by a game's Initialise routine
and sometimes remain active throughout.  For instance, a lamp-battery
daemon might do something every turn, while others may hide for many
turns before pouncing: such as the daemon in `Advent' which waits until
the player has found all the treasures.

!! In particular, a daemon doesn't stop running just because the player
has moved on to somewhere else.  (Indeed, the library never stops a
daemon unless told to.)  Actually this is very useful, as it means
daemons can be used for `tidying-up operations', or for the
consequences of the player's actions to catch up with him.

Exercise 34
-----------

   Many games contain `wandering monsters', characters who walk around
the map.  Use a daemon to implement one who wanders as freely as the
player, like the gentleman thief in `Zork'.

   *Note Answer 34::

!! Exercise 35
--------------

   Use a background daemon to implement a system of weights, so that
the player can only carry a certain weight before her strength gives
out and she is obliged to drop something.  It should allow for feathers
to be lighter than lawn-mowers.

   *Note Answer 35::

A `timer' (these are traditionally called `fuses') can also be attached
to an object.  A timer is started with

     StartTimer(object, time);

in which case it will `go off', alarm clock-style, in the given number
of turns.  This means that its time_out property will be called, once
and once only, when the time comes.  The timer can be deactivated (so
that it will never go off) by calling

     StopTimer(object);

A timer is required to provide a time_left property, to hold the amount
of time left.  (If it doesn't, an error message is printed at
run-time.)  You can alter time_left yourself: a value of 0 means `will
go off at the end of this turn', so setting time_left to 0 triggers
immediate activation.

!! Normally, you can only have 32 timers or daemons active at the same
time as each other (plus any number of inactive ones).  But this limit
is easily raised: just define the constant MAX_TIMERS to some larger
value, putting the definition in your code before the Parser file is
included.

There is yet a third form of timed event.  If a room provides an
each_turn routine, then this will be called at the end of each turn
while the player is there; if an object provides each_turn, this is
called while the object is nearby.  For instance, a radio might blare
out music whenever it is nearby; a sword might glow whenever monsters
are nearby; or a stream running through several forest locations might
occasionally float objects by.

   'Each turn' is especially useful to run creatures which stay in one
room and are only active when the player is nearby.  An ogre with
limited patience can therefore have an each_turn routine which worries
the player ("The ogre stamps his feet angrily!", etc.) while also
having a timer set to go off when his patience runs out.

!! `Nearby' actually means `in scope', a term which will be properly
explained later.  The idea is based on line of sight, which works well
in most cases.

!!!! But it does mean that the radio will be inaudible when shut up
inside most containers -- which is arguably fair enough -- yet audible
when shut up inside transparent, say glass, ones.  You can always
change the scope rules using an InScope routine to get around this.  In
case you want to tell whether scope is being worked out for ordinary
parsing reasons or instead for each_turn processing, look at the
scope_reason variable (*note Scope::.).  Powerful effects are available
this way -- you could put the radio in scope within all nearby rooms so
as to allow sound to travel.  Or you could make a thief audible
throughout the maze he is wandering around in, as in `Zork I'.

Exercise 36
-----------

   (Why the `Ruins' are claustrophobic.)  Make "the sound of scuttling
claws" approach the player in darkness and, after 4 consecutive turns
in darkness, kill him.

   *Note Answer 36::

!! Exercise 37
--------------

   A little harder: implement the scuttling claws in a single object
definition, with no associated code anywhere else in the program (not
even a line in Initialise) and without running its daemon all the time.

   *Note Answer 37::

The library also has the (limited) ability to keep track of time of day
as the game goes on.  The current time is held in the variable the_time
and runs on a 24-hour clock: this variable holds minutes since midnight,
so it has values between 0 and 1439.  The time can be set by

     SetTime( 60 * <hours>+<minutes>, <rate> );

The rate controls how rapidly time is moving: a rate of 0 means it is
standing still (that is, that the library doesn't change it: your
routines still can).  A positive rate means that that many minutes pass
between each turn, while a negative rate means that many turns pass
between each minute.  (It's usual for a timed game to start off the
clock by calling SetTime in its Initialise routine.) The time only
(usually) appears on the game's status line if you set

     Statusline time;

as a directive somewhere in your code.

Exercise 38
-----------

   How could you make your game take notice of the time passing
midnight, so that the day of the week could be nudged on?

   *Note Answer 38::

!! Exercise 39
--------------

   (Cf. Sam Hulick's vampire game, `Knight of Ages'.) Make the lighting
throughout the game change at sunrise and sunset.

   *Note Answer 39::

!! Exactly what happens at the end of each turn is:

  1. The turns counter is incremented.

  2. The 24-clock is moved on.

  3. Daemons and timers are run (in no guaranteed order).

  4. each_turn takes place for the current room, and then for
     everything nearby (that is, in scope).

  5. The game's global TimePasses routine is called.

  6. Light is re-considered (it may have changed as a result of events
     since this time last turn).

The sequence is abandoned if at any stage the player dies or wins.

!! Exercise 40
--------------

   Suppose the player is magically suspended in mid-air, but that
anything let go of will fall out of sight.  The natural way to code
this is to use a daemon which gets rid of anything it finds on the
floor (this is better than just trapping Drop actions because objects
might end up on the floor in many different ways).  Why is using
each_turn better?

   *Note Answer 40::

Exercise 41
-----------

   How would a game work if it involved a month-long archaeological
dig, where anything from days to minutes pass between successive game
turns?

   *Note Answer 41::

References
----------

   * Daemons abound in most games.  `Advent' uses them to run down the
     lamp batteries, make the bear follow you, animate the dwarves and
     the pirate and watch for the treasure all being found.  See also
     the flying tortoise from `Balances' and the chiggers from
     `Adventureland'.  For more ingenious uses of daemon, see the
     helium balloon, the matchbook and (particularly cunning) the pair
     of white gloves in `Toyshop'.

   * Classic timers include the burning match and the hand grenade from
     `Toyshop', the endgame timer from `Advent' and the `Balances'
     cyclops (also employing each_turn).

   * `Adventureland' makes much use of each_turn: see the golden fish,
     the mud, the dragon and the bees.

   * The library extension `timewait.h' by Andrew Clover thoroughly
     implements time of day, allowing the player to "wait until quarter
     past three".


File: inform,  Node: Player,  Next: Constants and Scoring,  Prev: Daemons,  Up: The Model World

Starting, moving, changing and killing the player
=================================================

     There are only three events in a man's life; birth, life and death;
     he is not conscious of being born, he dies in pain and he forgets
     to live.

     -- Jean de la Bruyere (1645-1696)

     Life's but a walking shadow, a poor player
     That struts and frets his hour upon the stage
     And then is heard no more; it is a tale
     Told by an idiot, full of sound and fury,
     Signifying nothing.
     
     -- William Shakespeare (1564-1616), Macbeth V. v

The only compulsory task for a game's Initialise routine is to set the
location variable to the place where the player should begin.  This is
usually a room (and is permitted to be one that's in darkness) but
could instead be an object inside a room, such as a chair or a bed.  If
you would like to give the player some items to begin with, Initialise
should also move them to player.

   Games with a long opening sequence might want to start by offering
the player a chance to restore a saved game at once.  They can do so by
writing the following in their Initialise routines:

    print "Would you like to restore a game?  >";
    if (YesOrNo()) <Restore>;

(If you want to make the status line invisible during an opening
sequence, see *Note Assembly Language::.)  Initialise normally returns
0 or 1 (it doesn't matter which), but if it returns 2 then no game
banner will be printed at once.  (This is for games which, like
`Sorcerer', delay their banners until after the prologue.) `Ruins',
however, opens in classical fashion:

[ Initialise;
  TitlePage();
  location = Forest;
  move food_ration to player;
  move sodium_lamp to player;
  move dictionary to player;
  thedark.description = "The darkness of ages presses in on you, and you
      feel claustrophobic.";
 "^^^^^Days of searching, days of thirsty hacking through the briars of
  the forest, but at last your patience was rewarded. A discovery!^";
];

(The TitlePage routine will be an exercise in *Note Assembly
Language::: `Ruins' is really too small a game to warrant one, but
never mind.) The location variable needs some explanation.  It holds
either the current room, if there's light to see by, or the special
value thedark (the "Darkness" object) if there isn't.  In the latter
case (but only in the latter case) the actual current room is held in
the variable real_location, should you need to know it.  Neither of
these is necessarily the same as the parent of the player object.  For
instance, if the player sits in a jeep parked in a dark garage, then
location is thedark, real_location is Garage and parent(player) is jeep.

   Because of this, one shouldn't simply move the player object by hand.
Instead, to move the player about (for teleportation of some kind), use
the routine PlayerTo(place); (which automatically takes care of
printing the new room's description if there's enough light there to see
by).

!! PlayerTo can also be used to move the player to a place inside a
room (e.g., a cage, or a traction engine).

!! Calling PlayerTo(place, 1); moves the player but prints nothing (in
particular, prints no room description).

!! Calling PlayerTo(place, 2); will Look as if the player had arrived
in the room by walking in as usual, so only a short description appears
if the room is one that has been seen before.

!! In a process called `scoring arrival', a room which the player has
entered for the first time is given the visited attribute.  If it was
listed as scored, points are awarded.  (See *Note Things to Enter::.)

!!!! When a Look action takes place, or a call to PlayerTo(place,1),
the library `notes arrival' as well as `scores arrival'.  `Noting
arrival' consists of checking to see if the room has changed since last
time (darkness counting as a different room for this purpose).  If so,
the following happens:

  1. If the new location has an initial property, this is printed if
     it's a string, or run if it's a routine.

  2. The entry point NewRoom is called (if it exists).

  3. Any `floating objects', such as drifting mist, which are found_in
     many places at once, are moved into the room.

The player's whole persona can easily be changed, because the player
object can itself have an orders routine, just as the object for any
non-player character can.  To replace the orders routine for the
standard player object, set

player.orders = MyNewRule;

where MyNewRule is a new orders rule.  Note that this is applied to
every action or order issued by the player.  The variable actor holds
the person being told to do something, which may well be the player
himself, and the variables action, noun and second are set up as usual.
For instance, if a cannon goes off right next to the player, a period
of partial deafness might ensue:

[ MyNewRule;
  if (actor~=player) rfalse;
  Listen: "Your hearing is still weak from all that cannon-fire.";
];

The if statement needs to be there to prevent commands like "helena,
listen" from being ruled out -- after all, the player can still speak.

!! Exercise 42
--------------

   Why not achieve the same effect by giving the player a react_before
rule instead?

   *Note Answer 42::

Exercise 43
-----------

   (Cf. `Curses'.)  Write an orders routine for the player so that
wearing the gas mask will prevent him from talking.

   *Note Answer 43::

!! In fact a much more powerful trick is available: the player can
actually become a different character in the game, allowing the real
player at the keyboard to act through someone else.  Calling
ChangePlayer(obj) will transform the player to obj.  There's no need
for obj to have names like "me" or "myself"; the parser understands
these words automatically to refer to the currently-inhabited player
object.  However, it must provide a number property (which the library
will use for workspace).  The maximum number of items the player can
carry as that object will be its capacity.  Finally, since ChangePlayer
prints nothing, you may want to conclude with a <<Look>>;

   ChangePlayer has many possible applications.  The player who tampers
with Dr Frankenstein's brain transference machine may suddenly become
the Monster strapped to the table.  A player who drinks too much wine
could become a `drunk player object' to whom many different rules
apply.  The "snavig" spell of `Spellbreaker', which transforms the
player to an animal like the one cast upon, could be implemented thus.
More ambitiously, a game could have a stock of half a dozen main
characters, and the focus of play can switch between them.  A player
might have a team of four adventurers to explore a dungeon, and be able
to switch the one being controlled by typing the name.  In this case,
an AfterLife routine -- see below -- may be needed to switch the focus
back to a still-living member of the team after one has met a sticky
end.

!! Calling ChangePlayer(object,1); will do the same but make the game
print "(as Whoever)" during room descriptions.

!!!! When the person to be changed into has an orders routine, things
start to get complicated.  It may be useful to arrange such a routine
as follows:

      orders
      [;  if (player==self)
          {   ! I am the player object...
              if (actor==self)
              {   ! ...giving myself an order, i.e., trying an action.
              }
              else
              {   ! ...giving someone else, the "actor", an order.
              }
          }
          else
          {   ! The player is the "actor" and is giving me an order.
          }
      ],

!! Exercise 44
--------------

In Central American legend, a sorceror can transform himself into a
`nagual', a familiar such as a spider-monkey; indeed, each individual
has an animal self or `wayhel', living in a volcanic land over which
the king, as a jaguar, rules.  Turn the player into his `wayhel'.

   *Note Answer 44::

!!!! Exercise 45
----------------

   Write an orders routine for a Giant with a conscience, who will
refuse to attack a mouse, but so that a player who becomes the Giant
can be as cruel as he likes.

   *Note Answer 45::

The player is still alive for as long as the variable deadflag is zero.
When set to 1, the player dies; when set to 2, the player wins; and all
higher values are taken as more exotic forms of death.  Now Inform does
not know what to call these exotica: so if they should arise, it calls
the DeathMessage routine, which is expected to look at deadflag and can
then print something like "You have changed".

   Many games allow reincarnation (or, as David M. Baggett points out,
in fact resurrection).  You too can allow this, by providing an
AfterLife.  This routine gets the chance to do as it pleases before any
"You are dead" type message appears, including resetting deadflag back
to 0 -- which causes the game to proceed in the normal way, rather than
end.  AfterLife routines can be tricky to write, though, because the
game has to be set to a state which convincingly reflects what has
happened.

References
----------

   * The magic words "xyzzy" and "plugh" in `Advent' make use of
     PlayerTo.

   * `Advent' has an amusing AfterLife routine: for instance, try
     collapsing the bridge by leading the bear across, then returning
     to the scene after resurrection.  `Balances' has one which only
     slightly penalises death.


File: inform,  Node: Constants and Scoring,  Next: Extending the Library,  Prev: Player,  Up: The Model World

Miscellaneous constants and scoring
===================================

     For when the One Great Scorer comes
     To write against your name,
     He marks -- not that you won or lost --
     But how you played the game.
     
     -- Grantland Rice (1880-1954), Alumnus Football

Some game rules can be altered by defining `constants' at the start of
the program.  Two constants you `must' provide (and before including
any of the library files) are the strings Story and Headline:

Constant Story "ZORK II";
Constant Headline "^An Interactive Plagiarism^
             Copyright (c) 1995 by Ivan O. Ideas.^";

All the rest are optional, but should be defined before Verblib is
included if they're to take effect.

The library won't allow the player to carry an indefinite number of
objects: the limit allowed is the constant MAX_CARRIED, which you may
define if you wish.  If you don't define it, it's 100, which nearly
removes the rule.  In fact you can change this during play, since it is
actually the capacity of the player which is consulted; the only use of
MAX_CARRIED is to set this up to an initial value.

   If you define SACK_OBJECT to be some container, then the player will
automatically put old, least-used objects away in it as the game
progresses, provided it is being carried.  This is a feature which
endears the designer greatly to players.  For instance, the following
code appears (in between inclusion of Parser and Verblib) in `Toyshop':

Object satchel "satchel"
  with description "Big and with a smile painted on it.",
       name "satchel", article "your",
       when_closed "Your satchel lies on the floor.",
       when_open "Your satchel lies open on the floor.",
  has  container open openable;
Constant SACK_OBJECT satchel;

`Ruins' isn't going to provide this feature, because there are few
portable objects and those there are would be incongruous if described
as being in a rucksack.

Another constant is AMUSING_PROVIDED.  If you define this, the library
knows to put an "amusing" option on the menu after the game is won.  It
will then call Amusing from your code when needed.  You can use this to
roll closing credits, or tell the player various strange things about
the game, now that there's no surprise left to spoil.

   The other constants you are allowed to define help the score routines
along.  There are two scoring systems provided by the library, side by
side: you can use both or neither.  You can always do what you like to
the score variable in any case, though the "fullscore" verb might then
not fully account for what's happened.  One scores points for getting
certain items or reaching certain places; the other for completing
certain actions.  These constants are:

      MAX_SCORE          the maximum game score (by default 0);
      NUMBER_TASKS       number of individual "tasks" to perform (1);
      OBJECT_SCORE       bonus for first picking up a scored object (4);
      ROOM_SCORE         bonus for first entering a scored room (5)

and then the individual tasks have scores, as follows:

     Array task_scores -> t1 t2 ... tn;

As this is a byte array, the task scores must be between 0 and 255.
Within your code, when a player achieves something, call Achieved(task)
to mark that the task has been completed.  It will only award points if
this task has not been completed before.  There do not have to be any
"tasks": there's no need to use the scoring system provided.  Tasks
(and the verb "full" for full score) will only work at all if you define
the constant TASKS_PROVIDED.  The entry point PrintTaskName prints the
name of a game task (but, of course, is only ever called in a game with
TASKS_PROVIDED defined).  For instance, (`Toyshop' again)

[ PrintTaskName ach;
  switch(ach)
  {   0: "eating a sweet";
      1: "driving the car";
      2: "shutting out the draught";
      3: "building a tower of four";
      4: "seeing which way the mantelpiece leans";
  }
];

Another entry point, called PrintRank, gets the chance to print
something additional to the score (traditionally, though not
necessarily, rankings).  For instance, we bid farewell to the `Ruins'
with the following:

[ PrintRank;
  print ", earning you the rank of ";
  switch(score)
  {   0 to 9:   "humble rainforest Tourist.";
      10 to 19: "Investigator.";
      20 to 29: "Acquisitor.";
      30 to 49: "Archaeologist.";
      50:       "Master Archaeologist.";
  }
];

Normally, an Inform game will print messages like

     [Your score has gone up by three points.]

when the score changes (by whatever means).  The player can turn this
on and off with the "notify" verb; by default it is on.  (You can alter
the flag notify_mode yourself to control this.)

The verbs "objects" and "places" are usually provided, so the player
can get a list of all handled objects (and where they now are), and all
places visited.  If you don't want these to be present, define the
constant NO_PLACES before inclusion of the library.

!! Exercise 46
--------------

   Suppose one single room object is used internally for the 64 squares
of a gigantic chessboard, each of which is a different location to the
player.  Then "places" is likely to result in only the last-visited
square being listed.  Fix this.

   *Note Answer 46::

References
----------

   * `Advent' contains ranks and an Amusing reward (but doesn't use
     either of these scoring systems, instead working by hand).

   * `Balances' uses scored objects (for its cubes).

   * `Toyshop' has tasks, as above.

   * `Adventureland' uses its TimePasses entry point to recalculate the
     score every turn (and watch for victory).


File: inform,  Node: Extending the Library,  Prev: Constants and Scoring,  Up: The Model World

Extending and redefining the Library
====================================

     A circulating library in a town is as an ever-green tree of
     diabolical knowledge!  It blossoms through the year!

     -- R. B. Sheridan (1751-1816), The Rivals

Most large games will need to enrich the `model world': for instance,
by creating a new concept such as "magic amulets".  The game might
contain a dozen of these, each with the power to cast a different
spell.  So it will need routines which can tell whether or not a given
object is an amulet, and what to do when the spell is cast.

   To do this, a game should make a class definition for amulets:
called Amulet, say.  Then

    if (noun ofclass Amulet) ...

will test to see if noun is one of the amulets, for instance.

   The amulet's spell will be represented by the property amulet_spell.
Typical values for this might be:

    amulet_spell "The spell fizzles out with a dull phut! sound.",
    amulet_spell
    [;  if (location == thedark)
        {   give real_location light;
            "There is a burst of magical light!";
        }
    ],
    amulet_spell HiddenVault,
    amulet_spell
    [;  return random(LeadRoom, SilverRoom, GoldRoom);
    ],

Then the process of casting the spell for amulet X is a matter of
sending the message

    X.amulet_spell();

which will reply with either: false, meaning nothing has happened;
true, meaning that something did happen; or an object, a room to
teleport the player to.  Here is a routine which deals with it all:

    [ CastSub destination;
      if (noun ofclass Amulet)
      {   if (~~(noun provides amulet_spell))
              "[Ooops. Forgot to program this amulet_spell.]";
          destination = noun.amulet_spell();
          switch(destination)
          {   false:   "Nothing happens.";
              true:    ;
              default: print "You are magically teleported to...^";
                       PlayerTo(destination);
          }
      }
      else "You only know how to cast spells with amulets.";
    ];

An elaborate library extension will end up defining many classes,
grammar, actions and verb definitions.  These may neatly be packaged up
into an Include file and placed with the other library files.

!!!! If this file contains the directive System_file; then it will even
be possible for games to Replace routines from it (see below).

!! The ordinary Library's own properties, such as description or e_to,
are called "common properties".  They are special for the following
reason: if an object O does not give any value for common property P,
then O.P can still be looked up, though it can't be set to something
else.  (If you tried this with a property of your own invention, such
as amulet_spell above, an error would be printed out at run-time.)  The
value of O.P is just the "default value" provided by the Library for
property P: for example, the default value of cant_go is "You can't go
that way."

!! But you can change this default value during play, using the
library's ChangeDefault routine.  For instance, at a late stage in the
game:

ChangeDefault(cant_go, "You're a Master Adventurer now, and still
                        you walk into walls!");

Of course this cannot change defaults for properties of your own
invention, because they haven't got default values.

!!!! Common properties are also slightly faster to perform calculations
with: the down side is that there's a strictly limited supply of them
(63 in all), of which the library uses up half already.  To indicate
that a property needs to be a common property, use the Property
directive.  For example:

    Property door_to;
    Property capacity 100;
    Property cant_go "You can't go that way.";

In the latter cases we are giving default values: in the former case,
the default value will just be 0.

Major library extensions are rarely needed.  More often, one would like
simply to change the stock of standard messages, such as the "Nothing
is on sale." which tends to be printed when the player asks to buy
something, or the "Taken." printed when something is picked up.

   This facility is available as follows.  Provide a special object
called LibraryMessages, which must be defined between the inclusion of
the "Parser" and "VerbLib" library files.  This object should have just
one property, a before rule.  For example:

     Object LibraryMessages
       with before
            [;  Jump: "You jump and float uselessly for a while in
                       the zero gravity here on Space Station Alpha.";
                SwitchOn:
                      if (lm_n==3)
                      {   print "You power up ", (the) lm_o, "."; }
            ];

The object never physically appears in the game, of course.  The idea
is that the before rule is consulted before any message is printed: if
it returns false, the standard message is printed; if true, then
nothing is printed, as it's assumed that this has already happened.

   The Jump action only ever prints one message (usually "You jump on
the spot."), but more elaborate actions such as SwitchOn have several
(the extreme case is Take, with 13).  lm_n holds the message number,
which counts upwards from 1.  The messages and numbers are given in
*Note Library Messages::.  New message numbers may possibly be added in
future, but old ones will not be renumbered.

   An especially useful library message to change is the prompt,
normally set to "^>" (new-line followed by >).  This is printed under
the action Prompt (actually a fake action existing for exactly this
purpose).  In this way, the game's prompt can be made context-sensitive,
or the "skipped line on screen each turn" convention can be removed.

!!  This prompt is only used in ordinary game play, and not at such
keyboard inputs as yes/no questions or the RESTART/RESTORE/QUIT game
over choice.

Exercise 47
-----------

   Infocom's game `The Witness' has the prompt "What should you, the
detective, do next?" on turn one and "What next?" subsequently.
Implement this.

   *Note Answer 47::

!!!! An amusing way to see the system in action is to put

     Object LibraryMessages
       with before
            [;  print "[", sw__var, ", ", lm_n, "] ";
            ];

into your game (arcane note: sw__var, the "switch variable", in this
case holds the action number).  Another amusing effect is to simply
write rtrue; for the before routine, which results in an alarmingly
silent game -- blindfold Adventure, perhaps.

!!!!  Note that LibraryMessages can be used as a sneaky way to add extra
rules onto the back of actions, since there's nothing to stop you doing
real processing in a call to it; or, more happily, to make messages
more sensitive to game context, so that "Nothing is on sale." might
become "That's not one of the goods on sale." inside a shopping mall.

!!!! Exercise 48
----------------

   Write an Inform game in Occitan (a dialect of medieval French spoken
in Provence).

   *Note Answer 48::

The Library is itself written in Inform, and with experience it's not
too hard to alter it if need be.  But this is an inconvenience and an
inelegant way to carry on.  So here is the last resort in library
modification: work out which routine is giving trouble, and Replace it.
For example, if the directive

Replace BurnSub;

is placed in your file `before the library files are included', Inform
ignores the definition of BurnSub in the library files.  You then have
to define a routine called BurnSub yourself.  It would be normal to
copy the definition of BurnSub out of the library files into your own
code, and then modify that copy as needed.

   The most popular routine to replace is DrawStatusLine: see *Note
Assembly Language:: for several examples.

!!!!  Inform even allows you to Replace "hardware" functions like
random, which would normally be translated directly to machine opcodes.
Obviously, replacing something like child with a software routine will
impose an appreciable speed penalty and slightly increase object code
size.  Replacing random may however be useful when fixing the random
number generator for game-testing purposes.

References
----------

   * `Balances' contains a section of code (easily extractable to other
     games) implementing the `Enchanter' trilogy's magic system by
     methods like the above.

   * There are several formal library extension files in existence,
     mostly small: see the Inform home page on the WWW.

   * "pluralobj.h" by Andrew Clover makes large-scale use of
     LibraryMessages to ensure that the library always uses words like
     "those" instead of "that" when talking about objects with names
     like "a heap of magazines".
