<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>DM4 &#167;6: Actions and reactions</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="dm4.css">
</head>
<body>
<p class="navbar">
 <a href="index.html">home</a> /
 <a href="contents.html">contents</a> /
 <a href="ch2.html" title="Chapter II: Introduction to Designing">chapter II</a> /
 <a href="s5.html" title="&#167;5: Introducing messages and classes">prev</a> /
 <a href="s7.html" title="&#167;7: Infix and the debugging verbs">next</a> /
 <a href="dm4index.html">index</a>
</p>
<div class="page">
<a id="p97" name="p97"></a>
<h2>&#167;6 &nbsp; Actions and reactions</h2>

<blockquote>Only the actions of the just<br>
Smell sweet and blossom in their dust.<br>
&#8212; James Shirley (1594&#8211;1666),<br>
<span style="color:white">&#8212;</span> <i>The Contention of Ajax and Ulysses</i>
</blockquote>

<blockquote>[Greek is] a language obsessed with action, and with 
the joy of seeing action multiply from action, action marching 
relentlessly ahead and with yet more actions filing in from either 
side to fall into neat step at the rear, in a long straight rank 
of cause and effect, to what will be inevitable, the only possible end.<br>
&#8212; Donna Tartt, <i>The Secret History</i></blockquote>

<p class="normal"><span class="atleft"><img src="dm4-097_1.jpg" alt=""></span>
Inform is a language obsessed with actions. An
&#8216;action&#8217; is an attempt to perform one simple task: for 
instance,</p>

<p class="lynxonly"></p>
<pre class="code">Inv    Take sword    Insert gold_coin cloth_bag</pre>

<p class="normal">are all examples. Here the actual actions are 
<code>Inv</code> (inventory), <code>Take</code> and <code>Insert</code>.
An action has none, one or two objects supplied with it (or, in a few 
special cases, some numerical information rather than objects). It also 
has an &#8220;actor&#8221;, the person who is to perform the action, usually 
the player. Most actions are triggered off by the game's parser, whose 
job can be summed up as reducing the player's keyboard commands to 
actions: &#8220;take my hat off&#8221;, &#8220;remove bowler&#8221; 
or &#8220;togli il cappello&#8221; (if in an Italian game) might all 
cause the same action. Some keyboard commands, like &#8220;drop 
all&#8221;, cause the parser to fire off whole sequences of actions: 
others, like &#8220;empty the sack into the umbrella stand&#8221;, 
cause only a single action but one which may trigger off an avalanche
of other actions as it takes place.</p>

<p class="indent">An action is only an attempt to do something: it may 
not succeed. Firstly, a <code>before</code> rule might interfere, 
as we have seen already. Secondly, the action might not even be very 
sensible. The parser will happily generate the action <code>Eat 
iron_girder</code> if the player asked to do so in good English. In 
this case, even if no <code>before</code> rule interferes, the normal 
game rules will ensure that the girder is not consumed.</p>

<p class="indent">Actions can also be generated by your own code, and 
this perfectly simulates the effect of a player typing something. For 
example, generating 
<a id="p98" name="p98"></a>
a <code>Look</code> action makes the game produce 
a room description as if the player had typed &#8220;look&#8221;. 
More subtly, suppose the air in the Pepper Room causes the player to 
sneeze each turn and drop something at random. This could be programmed 
directly, with objects being moved onto the floor by explicit move 
statements. But then suppose the game also contains a toffee apple,
which sticks to the player's hands. Suddenly the toffee apple problem 
has an unintended solution. So rather than moving the objects directly 
to the floor, the game should generate <code>Drop</code> actions, 
allowing the game's rules to be applied. The result might read:</p>

<p class="output">You sneeze convulsively, and lose your grip on 
the toffee apple&#8230;<br>The toffee apple sticks to your hand!</p>

<p class="normal">which is at least consistent.</p>

<p class="indent">As an example of causing actions, an odorous <code>low_mist</code> 
will soon settle over &#8216;Ruins&#8217;. It will have the description 
&#8220;The mist carries an aroma reminisicent of tortilla.&#8221; 
The alert player who reads this will immediately type &#8220;smell 
mist&#8221;, and we want to provide a better response than the game's
stock reply &#8220;You smell nothing unexpected.&#8221; An 
economical way of doing this is to somehow deflect the action <code>Smell 
low_mist</code> into the action <code>Examine low_mist</code> 
instead, so that the &#8220;aroma of tortilla&#8221; message is printed 
in this case too. Here is a suitable <code>before</code> rule to 
do that:</p>

<p class="lynxonly"></p>
<pre class="code">Smell: &lt;Examine self&gt;; rtrue;</pre>

<p class="normal">The statement &lt;Examine self&gt; causes the 
action <code>Examine low_mist</code> to be triggered off immediately, 
after which whatever was going on at the time resumes. In this case, 
the action <code>Smell low_mist</code> resumes, but since we
immediately return <code>true</code> the action is stopped dead.</p>

<p class="indent">Causing an action and then returning <code>true</code> is 
so useful that it has an abbreviation, putting the action in double 
angle-brackets. For example, the following could be added to &#8216;Ruins&#8217; 
if the designer wanted to make the stone-cut steps more enticing:</p>

<p class="lynxonly"></p>
<pre class="code">
before [;
    Search: &lt;&lt;Enter self&gt;&gt;;
],
</pre>

<p class="normal">If a player types &#8220;search steps&#8221;, the 
parser will produce the action <code>Search steps</code> and 
this rule will come into play: it will generate the action <code>Enter 
steps</code> instead, and return <code>true</code> to stop the original 
<code>Search</code> action from going any further. The net effect is 
that one action has been diverted into another.</p>

<a id="p99" name="p99"></a>
<p class="dotbreak">· · · · ·</p>

<p class="normal">At any given time, just one action is under way, 
though others may be waiting to resume when the current one has finished. 
The current action is always stored in the four variables</p>

<p class="lynxonly"></p>
<pre class="code">actor    action    noun    second</pre>

<p class="normal"><code>actor</code>, <code>noun</code> and 
<code>second</code> hold the objects involved, or the special value 
<code>nothing</code> if they aren't involved at all. (There's always 
an <code>actor</code>, and for the time being it will always be equal 
to <code>player</code>.) <code>action</code> holds the kind of action. 
Its possible values can be referred to in the program using the 
<code>##</code> notation: for example</p>

<p class="lynxonly"></p>
<pre class="code">if (action == ##Look) ...</pre>

<p class="normal">tests to see if the current <code>action</code> is a 
<code>Look</code>.</p>

<p class="aside"><span class="warning">&#9650;</span>
Why have <code>##</code> at all, why not just write <code>Look</code>? 
Partly because this way the reader of the source code can see at a 
glance that an action type is being referred to, but also because 
the name might be used for something else. For instance there's a 
variable called <code>score</code> (holding the current game score), 
quite different from the action type <code>##Score</code>.</p>

<p class="aside"><span class="warning">&#9650;&#9650;</span>
For a few actions, the &#8216;noun&#8217; (or the &#8216;second 
noun&#8217;) is actually a number (for instance, &#8220;set timer to 
20&#8221; would probably end up with <code>noun</code> being <code>timer</code> and <code>second</code>
being 20). Occasionally one needs to be sure of the difference, e.g., 
to tell if <code>second</code> is holding a number or an object. It's then useful 
to know that there are two more primitive variables, <code>inp1</code> and <code>inp2</code>, 
parallel to <code>noun</code> and <code>second</code> and usually equal to them &#8211; but equal 
to 1 to indicate &#8220;some numerical value, not an object&#8221;.</p>

<p class="dotbreak">· · · · ·</p>

<p class="normal">The library supports about 120 different actions 
and most large games will add some more of their own. The full list, 
given in <a href="tables.html#tbl6a">Table 6</a>, is initially daunting,
but for any given object most of the actions are irrelevant. For 
instance, if you only want to prevent an object from entering the 
player's possession, you need only block the <code>Take</code> action, 
unless the object is initially in something or on something, in which 
case you need to block <code>Remove</code> as well. In the author's 
game &#8216;Curses&#8217;, one exceptional object (Austin, the cat) 
contains rules concerning 15 different actions, but the average is 
more like two or three action-rules per object.</p>

<p class="indent">The list of actions is divided into three groups, 
called Group 1, Group 2 and Group 3:</p>

<a id="p100" name="p100"></a>
<ol>
<li>Group 1 contains &#8216;meta&#8217; actions for controlling 
the game, like <code>Score</code> and <code>Save</code>, which are 
treated quite differently from other actions as they do not
happen in the &#8220;model world&#8221;.</li>
<li>Actions in group 2 normally do something to change the state of 
the model world, or else to print important information about it. 
<code>Take</code> (&#8220;pick up&#8221;) and <code>Inv</code> 
(&#8220;inventory&#8221;) are examples of each. Such actions will 
affect any object which doesn't block them with a <code>before</code> 
rule.</li>
<li>Finally, group 3 actions are the ones which normally do nothing 
but print a polite refusal, like <code>Pull</code> (&#8220;it is 
fixed in place&#8221;), or a bland response, like <code>Listen</code> 
(&#8220;you hear nothing unexpected&#8221;). Such actions will never 
affect any object which doesn't positively react with a <code>before</code> 
rule.</li>
</ol>

<p class="aside"><span class="warning">&#9650;</span>
Some of the group 2 actions can be ignored by the programmer because 
they are really only keyboard shorthands for the player. For example, 
<code>&lt;Empty rucksack table&gt;</code> means &#8220;empty the 
contents of the rucksack onto the table&#8221; and is automatically
broken down into a stream of actions like <code>&lt;Remove fish 
rucksack&gt;</code> and <code>&lt;PutOn fish table&gt;</code>. 
You needn't write rules concerning <code>Empty</code>, only 
<code>Remove</code> and <code>PutOn</code>.</p>

<p class="aside"><span class="warning">&#9650;&#9650;</span>
Most of the library's group 2 actions are able to &#8220;run silently&#8221;. 
This means that if the variable <code>keep_silent</code> is set to 
<code>true</code>, then the actions print nothing in the event of 
success. The group 2 actions which can't run silently are exactly 
those ones whose successful operation does nothing but print: 
<code>Wait</code>, <code>Inv</code>, <code>Look</code>, 
<code>Examine</code>, <code>Search</code>.</p>

<a name="ex3"></a>
<p class="aside"><span class="warning"><b>&#8226;</b>&#9650;
<b><a href="sa6.html#ans3">EXERCISE 3</a></b></span><br>
&#8220;The door-handle of my room&#8230; was different from all other 
door-handles in the world, inasmuch as it seemed to open of its own 
accord and without my having to turn it, so unconscious had its 
manipulation become&#8230;&#8221; (Marcel Proust). Use silent-running
actions to make an unconsciously manipulated door: if the player tries 
to pass through when it's closed, print &#8220;(first opening 
the door)&#8221; and do so. (You need to know some of 
<a href="s13.html">&#167;13</a>, the section on doors, to answer 
this.)</p>

<a name="ex4"></a>
<p class="aside"><span class="warning"><b>&#8226;</b>&#9650;&#9650;
<b><a href="sa6.html#ans4">EXERCISE 4</a></b></span><br>
Now add &#8220;(first unlocking the door with&#8230;)&#8221;, 
automatically trying to unlock it using either a key already known 
to work, or failing that, any key carried by the player which hasn't 
been tried in the lock before.</p>

<p class="dotbreak">· · · · ·</p>

<p class="aside"><span class="warning">&#9650;</span>
Some actions happen even though they don't arise <em>directly</em> 
from anything the player has typed. For instance, an action called 
<code>ThrownAt</code> is listed under group 3 in 
<a href="tables.html#tbl6c">Table 6</a>. It's a side-effect of the ordinary 
<code>ThrowAt</code> action: if the player types &#8220;throw rock 
at dalek&#8221;, the parser generates the action <code>ThrowAt 
rock dalek</code>. As usual the rock is sent a <code>before</code> 
message asking if it objects to being thrown at a Dalek. Since 
the Dalek may also have an opinion on the matter, another <code>before</code> 
message is sent to the Dalek, but 
<a id="p101" name="p101"></a>
this time with the action 
<code>ThrownAt</code>. A dartboard can thus distinguish between being
thrown, and having things thrown at it:</p>

<p class="lynxonly"></p>
<pre class="code">
before [;
    ThrowAt: &quot;Haven't you got that the wrong way round?&quot;;
    ThrownAt:
        if (noun==dart) {
            move dart to self;
            if (random(31)==1)
                print (string) random(&quot;Outer bull&quot;, &quot;Bullseye&quot;);
            else {
                print (string) random(&quot;Single&quot;, &quot;Double&quot;, &quot;Triple&quot;);
                print &quot; &quot;, (number) random(20);
            }
            &quot;!&quot;;
        }
        move noun to location;
        print_ret (The) noun, &quot; bounces back off the board.&quot;;
],
</pre>

<p class="aside">Such an imaginary action &#8211; usually, as in this 
case, a perfectly sensible action seen from the point of view of 
the second object involved, rather than the first &#8211; is sometimes
called a &#8220;fake action&#8221;. Two things about it are fake: 
there's no grammar that produces <code>ThrownAt</code>, and there's 
no routine called <code>ThrownAtSub</code>. The important fake actions 
are <code>ThrownAt</code>, <code>Receive</code> and <code>LetGo</code>, 
the latter two being used for containers: see 
<a href="s12.html">&#167;12</a>.</p>

<p class="aside"><span class="warning">&#9650;</span>
If you really need to, you can declare a new fake action with the 
directive <code>Fake_action</code> &#8249;<span class="token">Action-name</span>&#8250;<code>;</code>. 
You can then cause this action with <code>&lt;</code> and 
<code>&gt;</code> as usual.</p>

<a name="ex5"></a>
<p class="aside"><span class="warning"><b>&#8226;</b>&#9650;&#9650;
<b><a href="sa6.html#ans5">EXERCISE 5</a></b></span><br>
<code>ThrownAt</code> would be unnecessary if Inform had an idea 
of <code>before</code> and <code>after</code> routines which an 
object could provide if it were the second noun of an action. How 
might this be implemented?</p>

<p class="aside"><span class="warning">&#9650;&#9650;</span>
Very occasionally, in the darker recesses of 
<a href="s18.html">&#167;18</a> for instance, you want &#8220;fake 
fake actions&#8221;, actions which are only halfway faked in that 
they still have action routines. Actually, these are perfectly 
genuine actions, but with the parser's grammar jinxed so that they 
can never be produced whatever the player types.</p>

<p class="dotbreak">· · · · ·</p>

<p class="normal">The standard stock of actions is easily added to. 
Two things are necessary to create a new action: first one must provide 
a routine to make it happen. For instance:</p>

<p class="lynxonly"></p>
<pre class="code">
[ BlorpleSub;
  &quot;You speak the magic word ~Blorple~. Nothing happens.&quot;;
];
</pre>

<a id="p102" name="p102"></a>
<p class="normal">Every action has to have a &#8220;subroutine&#8221; 
like this, the name of which is always the name of the action with 
<code>Sub</code> appended. Secondly, one must add grammar so that 
<code>Blorple</code> can actually be called for. Far more about grammar 
in <a href="ch4.html">Chapter IV</a>: for now we add the simplest 
of all grammar lines, a directive</p>

<p class="lynxonly"></p>
<pre class="code">Verb 'blorple' * -&gt; Blorple;</pre>

<p class="normal">placed after the inclusion of the <code>Grammar</code> 
file. The word &#8220;blorple&#8221; can now be used as a verb. It 
can't take any nouns, so the parser will complain if the player
types &#8220;blorple daisy&#8221;.</p>

<p class="indent"><code>Blorple</code> is now a typical Group 3 action. 
<code>before</code> rules can be written for it, and it can be 
triggered off by a statement like</p>

<p class="lynxonly"></p>
<pre class="code">&lt;Blorple&gt;;</pre>

<p class="indent">The unusual action in &#8216;Ruins&#8217;, 
<code>Photograph</code>, needs to be a Group 2 action, since it actually 
does something, and objects need to be able to react with <code>after</code> 
rules. (Indeed, the definition of the <code>Treasure</code> class 
in the previous section contains just such an <code>after</code> rule.) 
A photographer needs a camera:</p>

<p class="lynxonly"></p>
<pre class="code">
Object -&gt; -&gt; camera &quot;wet-plate camera&quot;
  with name 'wet-plate' 'plate' 'wet' 'camera',
       description
          &quot;A cumbersome, sturdy, stubborn wooden-framed wet plate
          model: like all archaeologists, you have a love-hate
          relationship with your camera.&quot;;
</pre>

<p class="normal">(This is going to be inside a packing case which is 
inside the Forest, hence the two arrows <code>-&gt;</code>.) And now the action 
subroutine. The sodium lamp referred to will be constructed in 
<a href="s14.html">&#167;14</a>.</p>

<p class="lynxonly"></p>
<pre class="code">
[ PhotographSub;
  if (camera notin player) &quot;Not without the use of your camera.&quot;;
  if (noun == player) &quot;Best not. You haven't shaved since Mexico.&quot;;
  if (children(player) &gt; 1)
     &quot;Photography is a cumbersome business, needing the use of both
      hands. You'll have to put everything else down.&quot;;
  if (location == Forest) &quot;In this rain-soaked forest, best not.&quot;;
  if (location == thedark) &quot;It is far too dark.&quot;;
  if (AfterRoutines()) return;
 &quot;You set up the elephantine, large-format, wet-plate camera, adjust
  the sodium lamp and make a patient exposure of &quot;, (the) noun, &quot;.&quot;;
];
</pre>

<a id="p103" name="p103"></a>
<p class="normal">What makes this a Group 2 action is that, if the action 
successfully takes place, then the library routine <code>AfterRoutines</code> 
is called. This routine takes care of all the standard rules to do with 
<code>after</code> (see below), and returns <code>true</code> if any 
object involved has dealt with the action and printed something already. 
(Failing that, the message &#8220;You set up&#8230;&#8221; will be 
printed.) Finally, some grammar for the parser:</p>

<p class="lynxonly"></p>
<pre class="code">Verb 'photograph' * noun -&gt; Photograph;</pre>

<p class="normal">This matches input like &#8220;photograph statuette&#8221;, 
because the grammar token <code>noun</code> tells the parser to expect 
the name of a visible object. See <a href="s30.html">&#167;30</a> and 
<a href="s31.html">&#167;31</a> for much more on grammar.</p>

<p class="aside"><span class="warning">&#9650;</span>
To make a Group 1 action, define the verb as <code>meta</code> 
(see <a href="s30.html">&#167;30</a>).</p>

<p class="dotbreak">· · · · ·</p>

<p class="normal">Actions are processed in a simple way, but one which 
involves many little stages. There are three main stages:</p>

<ol>
<li>&#8216;Before&#8217;, for group 2 and 3 actions. An opportunity 
for your code to interfere with or block altogether what might soon 
happen.</li>
<li>&#8216;During&#8217;, for all actions. The library takes control 
and decides if the action makes sense according to its normal world 
model: for example, only an <code>edible</code> object may be eaten; 
only an object in the player's possession can be thrown at somebody, 
and so on. If the action is impossible, a complaint is printed and 
that's all. Otherwise the action is now carried out.</li>
<li>&#8216;After&#8217;, for group 2 actions. An opportunity for 
your code to react to what has happened, after it has happened but 
before any text announcing it has been printed. If it chooses, your 
code can print and cause an entirely different outcome. If your code 
doesn't interfere, the library reports back to the player (with such 
choice phrases as &#8220;Dropped.&#8221;).</li>
</ol>

<p class="aside"><span class="warning">&#9650;</span>
Group 1 actions, like <code>Score</code>, have no &#8216;Before&#8217; 
or &#8216;After&#8217; stages: you can't (easily) stop them from 
taking place. They aren't happening in the game's world, but in the
player's.</p>

<p class="aside"><span class="warning">&#9650;</span>
The &#8216;Before&#8217; stage consults your code in five ways, and 
occasionally it's useful to know in what order:</p>

<ul style="list-style-type:none">
<li>(1a) &nbsp; The <code>GamePreRoutine</code> is called, if you have written 
one. If it returns <code>true</code>, nothing else happens and the 
action is stopped.</li>
<li>(1b) &nbsp; The <code>orders</code> property of the player is called 
on the same terms. For more details, see <a href="s18.html">&#167;18</a>.</li>
<li>(1c) &nbsp; And the <code>react_before</code> of every object in scope, 
which roughly means &#8216;in the vicinity&#8217;. For more details, 
see <a href="s32.html">&#167;32</a>.</li>
<li><a id="p104" name="p104"></a>(1d) &nbsp; And the <code>before</code> of the current room.</li>
<li>(1e) &nbsp; If the action has a first noun, its <code>before</code> 
is called on the same terms.</li>
</ul>

<p class="aside"><span class="warning">&#9650;</span>
The library processes the &#8216;During&#8217; stage by calling the 
action's subroutine: for instance, by calling <code>TakeSub</code>.</p>

<p class="aside"><span class="warning">&#9650;</span>
The &#8216;After&#8217; stage only applies to Group 2 actions, as 
all Group 3 actions have been wound up with a complaint or a bland 
response at the &#8216;During&#8217; stage. During &#8216;After&#8217;
the sequence is as follows: (3a) <code>react_after</code> rules for 
every object in scope (including the player object); (3b) the room's 
<code>after</code>; (3c) the first noun's <code>after</code> and 
(3d) finally <code>GamePostRoutine</code>.</p>

<p class="aside"><span class="warning">&#9650;&#9650;</span>
To some extent you can even meddle with the &#8216;During&#8217; 
stage, and thus even interfere with Group 1 actions, by unscrupulous 
use of the <code>LibraryMessages</code> system. See 
<a href="s25.html">&#167;25</a>.</p>

<p class="dotbreak">· · · · ·</p>

<p class="normal">As mentioned above, the parser can generate decidedly 
odd actions, such as <code>Insert camel eye_of_needle</code>. The 
parser's policy is to allow any action which the player has clearly 
asked for at the keyboard, and it never uses knowledge about the 
current game position except to resolve ambiguities. For instance, 
&#8220;take house&#8221; in the presence of the Sydney Opera House 
and also a souvenir model of the same will be resolved in favour of 
the model. But if there is no model to cloud the issue, the parser 
will cheerfully generate <code>Take Sydney_Opera_House</code>.</p>

<p class="indent">Actions are only checked for sensibleness
<em>after</em> the <code>before</code> stage. In many ways this is 
a good thing, because in adventure games the very unlikely is sometimes 
correct. But sometimes it needs to be remembered when writing 
<code>before</code> rules. Suppose a <code>before</code> rule 
intercepts the action of putting the mushroom in the crate, and 
exciting things happen as a result. Now even if the mushroom is, say, 
sealed up inside a glass jar, the parser will still generate the
action <code>Insert mushroom crate</code>, and the <code>before</code> rule 
will still cut in, because the impossibility of the action hasn't yet 
been realised.</p>

<p class="indent">The upshot of this is that the exciting happening 
should be written not as a <code>before</code> but as an <code>after</code> 
rule, when it's known that the attempt to put the mushroom in the crate 
has already succeeded.</p>

<p class="aside"><span class="warning">&#9650;</span>
That's fine if it's a Group 2 action you're working with. But consider 
the following scenario: a siren has a cord which needs to be pulled to 
sound the alarm. But the siren can be behind glass, and is on the 
other side of a barred cage in which the player is imprisoned. 
You need to write a rule for <code>Pull cord</code>, but you can't 
place this among the cord's <code>after</code> rules because <code>Pull</code> 
is a group 3 action and there isn't any &#8220;after&#8221;: so it has 
to be a <code>before</code> rule. Probably it's best to write your 
own code by hand to check 
<a id="p105" name="p105"></a>
that the cord is reachable. But an alternative 
is to call the library's routine:</p>

<p class="lynxonly"></p>
<pre class="code">ObjectIsUntouchable(item, silent_flag, take_flag)</pre>

<p class="aside">This determines whether or not the player can touch 
<code>item</code>, returning <code>true</code> if there is some 
obstruction. If <code>silent_flag</code> is <code>true</code>, or 
if there's no obstruction anyway, nothing will be printed. Otherwise 
a suitable message will be printed up, such as &#8220;The barred cage 
isn't open.&#8221; So a safe way to write the cord's <code>before</code> 
rule would be:</p>

<p class="lynxonly"></p>
<pre class="code">
before [;
    Pull: if (ObjectIsUntouchable(self)) rtrue;
          &quot;~Vwoorp! Vwoorp!~&quot;;
],
</pre>

<p class="aside"><code>ObjectIsUntouchable</code> can also be a convenience 
when writing action subroutines for new actions of your own.</p>

<p class="aside"><span class="warning">&#9650;&#9650;</span>
If you set <code>take_flag</code>, then a further restriction will be 
imposed: the <code>item</code> must not belong to something or someone 
already: specifically, it must not be in the possession of an <code>animate</code> 
or a <code>transparent</code> object that isn't a <code>container</code> 
or <code>supporter</code>. For instance, the off button on a television 
set can certainly be touched, but if <code>take_flag</code> is <code>true</code>, 
then <code>ObjectIsUntouchable</code> will print up &#8220;That seems 
to be a part of the television set.&#8221; and return <code>true</code> 
to report an obstacle.</p>

<p class="aside"><span class="warning"><b>&#8226;</b> <b>REFERENCES</b></span><br>
In a game compiled with the <code>-D</code> for &#8220;Debugging&#8221; 
switch set, the &#8220;actions&#8221; verb will result in trace information 
being printed each time any action is generated. Try putting many things 
into a rucksack and asking to &#8220;empty&#8221; it for an extravagant 
list. &nbsp;
<span class="warning"><b>&#8226;</b></span>Diverted actions (using <code>&lt;&lt;</code> 
and <code>&gt;&gt;</code>) are commonplace. They're used in about 20 
places in &#8216;Advent&#8217;: a good example is the way &#8220;take 
water&#8221; is translated into a <code>Fill bottle</code> action. &nbsp;
<span class="warning"><b>&#8226;</b></span>L. Ross Raszewski's library 
extension <tt>&quot;yesno.h&quot;</tt> makes an interesting use of 
<code>react_before</code> to handle semi-rhetorical questions. For 
instance, suppose the player types &#8220;eat whale&#8221;, an absurd 
command to which the game replies &#8220;You can fit a blue whale in 
your mouth?&#8221; Should the player take this as a literal question 
and type &#8220;yes&#8221;, the designer might want to be able to reply 
&#8220;Oh. I should never have let you go through all those doors.&#8221; 
How might this be done? The trick is that, when the game's first reply
is made, an invisible object is moved into play which does nothing except 
to react to a <code>Yes</code> action by making the second reply.</p>

</div>
<p class="navbar">
 <a href="index.html">home</a> /
 <a href="contents.html">contents</a> /
 <a href="ch2.html" title="Chapter II: Introduction to Designing">chapter II</a> /
 <a href="s5.html" title="&#167;5: Introducing messages and classes">prev</a> /
 <a href="s7.html" title="&#167;7: Infix and the debugging verbs">next</a> /
 <a href="dm4index.html">index</a>
</p>
</body>
</html>

