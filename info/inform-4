This is Info file inform.info, produced by Makeinfo-1.64 from the input
file inform.texi.

This is the Inform Designer's Manual, third edition, 4 September 1996,
as updated 16 May 1997.  It was converted to Info by Christopher J.
Madsen <ac608@yfn.ysu.edu>.

Copyright 1996,1997 Graham Nelson and Christopher J. Madsen

Permission is granted to make and distribute copies of this manual
provided that:
 (a) distributed copies are not substantially different from those
     archived by the author,
 (b) this and other copyright messages are always retained in full, and
 (c) no profit is involved.


File: inform,  Node: Compiler Options,  Next: Error Messages,  Prev: The Language of Inform,  Up: Using the Compiler

Compiler options and memory settings
====================================

   It is time to give a full list of the "switches", which are the main
way to make choices about how Inform will operate.  (This list can
always be printed out with the -h2 switch.)

  a   trace assembly-language (without hex dumps; see -t)
  c   more concise error messages
  d   contract double spaces after full stops in text
  d2  contract double spaces after exclamation and question marks, too
  e   economy mode (slower): make use of declared abbreviations
  f   frequencies mode: show how useful abbreviations are
  g   traces calls to functions (except in the library)
  g2  traces calls to all functions
  h   print this information
  i   ignore default switches set within the file
  j   list objects as constructed
  k   output Infix debugging information to "gamedebug"
  l   list every statement run through Inform
  m   say how much memory has been allocated
  n   print numbers of properties, attributes and actions
  o   print offset addresses
  p   give percentage breakdown of story file
  q   keep quiet about obsolete usages
  r   record all the text to "gametext"
  s   give statistics
  t   trace assembly-language (with full hex dumps; see -a)
  u   work out most useful abbreviations (very very slowly)
  v3  compile to version-3 (Standard) story file
  v4  compile to version-4 (Plus) story file
  v5  compile to version-5 (Advanced) story file
  v6  compile to version-6 (graphical) story file
  v7  compile to version-7 (*) story file
  v8  compile to version-8 (*) story file
      (*) formats for very large games, requiring
          slightly modified game interpreters to play
  w   disable warning messages
  x   print # for every 100 lines compiled
  y   trace linking system
  z   print memory map of the Z-machine
  D   insert "Constant DEBUG;" automatically
  E0  Archimedes-style error messages (current setting)
  E1  Microsoft-style error messages
  E2  Macintosh MPW-style error messages
  F1  use temporary files to reduce memory consumption
  M   compile as a Module for future linking
  R0  use filetype 060 + version number for games (default)
  R1  use official Acorn filetype 11A for all games
  T   enable throwback of errors in the DDE
  U   insert "Constant USE_MODULES;" automatically

Note that the list may vary slightly from machine to machine: R0, R1
and T above are for Acorn RISC OS machines only, for example.

!!  Note that these switches can also be selected by putting a Switches
directive, such as Switches xdv8s; right at the start of the source
code.

   Only two switches have a really drastic effect:

M        Makes Inform compile a "module", not a "game".  See *Note
Linking::.

v        Chooses the format of the game to be compiled.  v5 is the
default, but if a game begins to overflow this, try v8.  (The other
settings are intended mainly for maintainers of Infocom interpreters to
test their wares.)

i        Overrides any switches set by switches directives in the
source code; so that the game can be compiled with different options
without having to alter that source code.

   Many of the remaining switches make Inform produce text as it runs,
without affecting the actual compilation:

a l m n t y        Tracing options to help with maintaining Inform, or
for debugging assembly language programs.

o p s z        To print out information about the final game file: the
s (statistics) option is particularly useful to keep track of how large
the game is growing.

c w q E T        In c mode, Inform does not quote whole source lines
together with error messages; in w mode it suppresses warnings; in T
mode, which is only present on RISC OS machines, error throwback will
occur in the `Desktop Development Environment'.  q causes "this usage
is obsolete" warnings to be suppressed, which may be useful when
compiling very long, very old programs.  Finally, E is provided since
different error formats fit in better with debugging tools on different
machines.

f        Indicates roughly how many bytes the abbreviations saved.

h        Prints out the help information.

j x        Makes Inform print out steady text to prove that it's still
awake: on very slow machines this may be a convenience.

k        Writes a "debugging information" file for the use of the Infix
debugger (the filename will be something suitable for your machine).

r        Intended to help with proof-reading the text of a game:
transcribes all of the text in double-quotes to the given file (whose
filename will be something suitable for your machine).

u        Tries to work out a good set of abbreviations to declare for
your game, but `extremely slowly' (a matter of hours) and `consuming
very much memory' (perhaps a megabyte).

D U        When these switches are set, the constants DEBUG (which make
the Library add the debugging suite to a game) and USE_MODULES (which
speeds up compilation by linking in the Library rather than recompiling
it) are automatically defined.  This is just a convenience: it's a
nuisance to keep adding and removing source code lines to do the same
thing.

This leaves three more switches which actually alter the game file which
Inform would compile:

d        Converts text like

"...with a mango.  You applaud..."

into the same with only a single space after the full stop, which will
prevent an interpreter from displaying a spurious space at the beginning
of a line when a line break happens to occur exactly after the full
stop; this is to help typists who habitually double-space.  Stepping up
to -d2 also contracts double spaces after question or exclamation marks.

e        Only in `economy' mode does Inform actually process
abbreviations, because this is seldom needed and slows the compiler by
10% or so; the game file should not play any differently if compiled
this way, but will probably be shorter, if your choice of abbreviations
was sensible.

g        Makes Inform automatically compile trace-printing code on
every function call; in play this will produce reams of text (several
pages between each chance to type commands) but is sometimes useful.
Note that in Inform 5.3 or later, this can be set on an individual
command by writing * as its first local variable, without use of the g
switch.

!! There are two directives for setting switches, to be used if there's
no other convenient way on your system (for example if you have a poor
windowed front end and no command line to type on).  These are:

     Switches <some settings>;
     Version <number>;

These can only be used as first lines in the program and are illegal
once other directives or routines have been given.  Note that

Version 6;

(for instance) is redundant, as it is equivalent to

Switches v6;

!!  Inform's memory management is very flexible, but sometimes needs
attention from the user, rather than being able to tinker with itself
automatically.  This is unfortunate but Inform has to run in some quite
hostile environments and is obliged to be cautious.

   In particular, it is unable to increase the size of any stretch of
memory once allocated, so if it runs out of anything it has to give up.
If it does run out, it will produce an error message saying what it
has run out of and how to provide more.

   There are three main choices: $small, $large and $huge.  (Which one
is the default depends on the computer you use.)  Even $small is large
enough to compile all the example games, including `Advent'.  $large
compiles almost anything and $huge has been used only for `Curses' and
`Jigsaw' in their most advanced states, and even they hardly need it.
A typical game, compiled with $large, will cause Inform to allocate
about 350K of memory: and the same game about 100K less under $small.
(These values will be rather lower if the computer Inform runs on has
16-bit integers.)  In addition, Inform physically occupies about 210K
(on my computer).  Thus, the total memory consumption of the compiler
at work will be about 500K.

   Running

    inform $list

will list the various settings which can be changed, and their current
values.  Thus one can compare small and large with:

    inform $small $list
    inform $large $list

If Inform runs out of allocation for something, it will generally print
an error message like:

   "Game", line 1320: Fatal error: The memory setting MAX_OBJECTS (which
   is 200 at present) has been exceeded.  Try running Inform again with
   $MAX_OBJECTS=<some-larger-number> on the command line.

and indeed

    inform $MAX_OBJECTS=250 game

(say) will tell Inform to try again, reserving more memory for objects
this time.  Note that settings are made from left to right, so that for
instance

    inform $small $MAX_ACTIONS=200 ...

will work, but

    inform $MAX_ACTIONS=200 $small ...

will not because the $small changes MAX_ACTIONS again.  Changing some
settings has hardly any effect on memory usage, whereas others are
expensive to increase.  To find out about, say, MAX_VERBS, run

    inform $?MAX_VERBS

(note the question mark) which will print some very brief comments.
Users of Unix, where $ and ? are special shell characters, will need to
type

    inform '$?list'         inform '$?MAX_VERBS'

and so on.


File: inform,  Node: Error Messages,  Prev: Compiler Options,  Up: Using the Compiler

All the Inform error messages
=============================

   Three kinds of error are reported by Inform: a fatal error is a
breakdown severe enough to make Inform stop working at once; an error
allows Inform to continue for the time being, but will cause Inform not
to finally output the story file (this is to prevent damaged story
files being created); and a warning means that Inform suspects you may
have made a mistake, but will not take any action itself.

* Menu:

* Fatal Errors::                Fatal errors
* Errors::
* Warnings::


File: inform,  Node: Fatal Errors,  Next: Errors,  Prev: Error Messages,  Up: Error Messages

Fatal errors
------------

1. Too many errors

Too many errors: giving up

After 100 errors, Inform stops (in case it has been given the wrong
source file altogether, such as a program for a different language
altogether).

2. Input/output problems

Most commonly, Inform has the wrong filename:

Couldn't open input file <filename>
Couldn't open output file <filename>

(and so on).  More seriously the whole process of file input/output (or
"I/O") may go wrong for some reason to do with the host computer: for
instance, if it runs out of disc space.  Such errors are rare and look
like this:

I/O failure: couldn't read from temporary file 2

Normally you can only have at most 64 files of source code in a single
compilation.  If this limit is passed, Inform generates the error

Program contains too many source files: increase #define MAX_SOURCE_FILES

(This might happen if the same file accidentally Includes itself.)
Finally, if a non-existent pathname variable is set in ICL, the error

No such path setting as <name>

is generated.

3. Running out of memory

If there is not enough memory even to get started, the following appear:

Run out of memory allocating <number> bytes for <something>
Run out of memory allocating array of <number>x<number> bytes for <something>

(There are four similar hallocate errors unique to the PC `Quick C'
port.) More often memory will run out in the course of compilation,
like so:

The memory setting <setting> (which is <value> at present) has been exceeded.
Try running Inform again with $<setting>=<some-larger-number> on the command line.

(For details of memory settings, see *Note Compiler Options:: above.)
In a really colossal game, it is just conceivable that you might hit

One of the memory blocks has exceeded 640K

which would need Inform to be recompiled to get around (but I do not
expect anyone ever to have this trouble).  Much more likely is the error

The story file/module exceeds version <n> limit (<number>K) by <number> bytes

If you're already using version 8, then the story file is full: you
might be able to squeeze more game in using the Abbreviate directive,
but basically you're near to the maximum game size possible.
Otherwise, the error suggests that you might want to change the version
from 5 to 8, and the game will be able to grow at least twice as large
again.


File: inform,  Node: Errors,  Next: Warnings,  Prev: Fatal Errors,  Up: Error Messages

Errors
------

There are a few conventions.  Anything in double-quotes is a quotation
from your source code; other strings are in single-quotes.  The most
common error by far takes the form

Expected ... but found ...

(of which there are over 100 kinds): most are straightforward to sort
out, but a few take some practice.  One of the trickiest things to
diagnose is a loop statement having been misspelt.  For example, the
lines

    pritn "Hello";
    While (x==y) print "x is still y^";

produce one error each:

line 1: Error: Expected assignment or statement but found pritn
line 2: Error: Expected ';' but found print

The first is fine.  The second is odd: a human immediately sees that
While is meant to be a while loop, but Inform is not able to make
textual guesses like this.  Instead Inform decides that the code
intended was

    While (x==y); print "x is still y^";

with While assumed to be the name of a function which hasn't been
declared yet.  Thus, Inform thinks the mistake is that the ; has been
missed out.

   In that example, Inform repaired the situation and was able to carry
on as normal in subsequent lines.  But it sometimes happens that a
whole cascade of errors is thrown up, in code which the user is fairly
sure must be nearly right.  What has happened is that one syntax
mistake threw Inform off the right track, so that it continued not to
know where it was for many lines in a row.  Look at the first error
message, fix that and then try again.

1. Reading in the source-code

Illegal character found in source: (char) <hexadecimal number>
Unrecognised combination in source: <text>
Alphabetic character expected after <text>
No such accented character as <text>
Name exceeds the maximum length of <number> characters: <name>
The following name is reserved by Inform for its own use as a routine name;
    you can use it as a routine name yourself (to override the standard
    definition) but cannot use it for anything else: <name>
The obsolete '#w$word' construct has been removed
Binary number expected after '$$'
Hexadecimal number expected after '$'
Too much text for one pair of 's to hold
Too much text for one pair of "s to hold

Note that, for instance, a ^ character is illegal in ordinary source
code (producing the first error above), but is allowed within quotation
marks.

2. Variables and arrays

Variable must be defined before use: <name>
'=' applied to undeclared variable
Local variable defined twice: <name>
All 236 global variables already declared
No array size or initial values given
Array sizes must be known now, not externally defined
An array must have a positive number of entries
A 'string' array can have at most 256 entries
Entries in byte arrays and strings must be known constants
Missing ';' to end the initial array values before "[" or "]"

The limit of 236 global variables is absolute: a program even
approaching this limit should probably be making more use of object
properties to store its information.  "Entries... must be known
constants" is a restriction on what byte or string arrays may contain:
basically, numbers or characters; defined constants (such as object
names) may only be used if they have already been defined.  This
restriction does not apply to the more normally used word and table
arrays.

3. Routines and function calls

No 'Main' routine has been defined
It is illegal to nest routines using '#['
A routine can have at most 15 local variables
Argument to system function missing
System function given with too many arguments
Only constants can be used as possible 'random' results
A function may be called with at most 7 arguments
Duplicate definition of label: <name>

Note that the system function random, when it takes more than one
argument, can only take constant arguments (this enables the
possibilities to be stored efficiently within the program).  Thus
random(random(10), location) will produce an error.  To make a random
choice between non-constant values, write a switch statement instead.

4. Expressions and arithmetic

Missing operator: inserting '+'
Evaluating this has no effect: <operator>
'=' applied to <operator>
Brackets mandatory to clarify order of: <operator>
Missing operand for <operator>
Missing operand after <something>
Found '(' without matching ')'
No expression between brackets '(' and ')'
'or' used improperly
Division of constant by zero
Label name used as value: <name>
System function name used as value: <name>
No such constant as <name>

"Operators" include not only addition +, multiplication * and so on,
but also more exotic Inform constructs like --> ("array entry") and .
("property value").  An example of an operator where "Evaluating this
has no effect" is in the statement

    34 * score;

where the multiplication is a waste of time, since nothing is done with
the result.  "= applied to operator" means something like

    (4 / fish) = 7;

which literally means "set 4/fish to 7" and results in the error "=
applied to /".

   "Brackets mandatory to clarify order" means that an ambiguous
expression like

    frogs == ducks == geese

requires clarification: which == is to be worked out first?

5. Miscellaneous errors in statements

'do' without matching 'until'
'default' without matching 'switch'
'else' without matching 'if'
'until' without matching 'do'
'break' can only be used in a loop or 'switch' block
At most 32 values can be given in a single 'switch' case
Multiple 'default' clauses defined in same 'switch'
'default' must be the last 'switch' case
'continue' can only be used in a loop block
A reserved word was used as a print specification: <name>
No lines of text given for 'box' display
In Version 3 no status-line drawing routine can be given
The 'style' statement cannot be used for Version 3 games

For instance, print (fixed) X gives the "reserved word in print
specification" error because fixed is a reserved statement internal
keyword.  Anyway, call such a printing routine something else.

6. Object and class declarations

Two textual short names given for only one object
The syntax '->' is only used as an alternative to 'Nearby'
Use of '->' (or 'Nearby') clashes with giving a parent
'->' (or 'Nearby') fails because there is no previous object
'-> -> ...' fails because no previous object is deep enough
Two commas ',' in a row in object/class definition
Object/class definition finishes with ','
Not an individual property name: <name>
No such property name as <name>
Not a (common) property name: <name>
Property should be declared in 'with', not 'private': <name>
Limit (of 32 values) exceeded for property <name>
Duplicate-number not known at compile time
The number of duplicates must be 1 to 10000

Note that "common properties" (those provided by the library, or those
declared with Property) cannot be made private.  All other properties
are called "individual".  The "number of duplicates" referred to is the
number of duplicate instances to make for a new class, and it needs to
be a number Inform can determine now, not later on in the source code
(or in another module altogether).  The limit 10000 is arbitrary and
imposed to help prevent accidents.

7. Grammar

Two different verb definitions refer to <name>
There is no previous grammar for the verb <name>
There is no action routine called <name>
No such grammar token as <text>
'=' is only legal here as 'noun=Routine'
Not an action routine: <name>
This is a fake action, not a real one: <name>
Too many lines of grammar for verb: increase #define MAX_LINES_PER_VERB

At present verbs are limited to 20 grammar lines each, though this
would be easy to increase.  (A grammar of this kind of length can
probably be written more efficiently using general parsing routines,
however.)

8. Conditional compilation

'Ifnot' without matching 'If...'
Second 'Ifnot' for the same 'If...' condition
End of file reached in code 'If...'d out
This condition can't be determined

"Condition can't be determined" only arises for Iftrue and Iffalse,
which make numerical or logical tests: for instance,

    Iftrue #strings_offset==$4a50;

can't be determined because even though both quantities are constants,
the #strings_offset will not be known until compilation is finished.
On the other hand, for example,

    Iftrue #version_number>5;

can be determined, as the version number was set before compilation.

9. Miscellaneous errors in directives

You can't 'Replace' a system function already used
Must specify 0 to 3 local variables for 'Stub' routine
A 'Switches' directive must come before the first constant definition
All 48 attributes already declared
All 62 properties already declared
'alias' incompatible with 'additive'
The serial number must be a 6-digit date in double-quotes
A definite value must be given as release number
A definite value must be given as version number
The version number must be in the range 3 to 8
All 64 abbreviations already declared
All abbreviations must be declared together
It's not worth abbreviating <text>
'Default' cannot be used in -M (Module) mode
'LowString' cannot be used in -M (Module) mode

10. Linking and importing

File isn't a module: <name>
Link: action name clash with <name>
Link: program and module give differing values of <name>
Link: module (wrongly) declared this a variable: <name>
Link: this attribute is undeclared within module: <name>
Link: this property is undeclared within module: <name>
Link: this was referred to as a constant, but isn't: <name>
Link: <type> <name> in both program and module
Link: <name> has type <type> in program but type <type> in module
Link: failed because too many extra global variables needed
Link: module (wrongly) declared this a variable: <name>
Link: this attribute is undeclared within module: <name>
Link: this property is undeclared within module: <name>
Link: this was referred to as a constant, but isn't: <name>
'Import' cannot import things of this type: <name>
'Import' can only be used in -M (Module) mode

Note that the errors beginning "Link:" are exactly those occurring
during the process of linking a module into the current compilation.
They mostly arise when the same name is used for one purpose in the
current program, and a different one in the module.

11. Assembly language

Label out of range for branch
Opcode specification should have form "VAR:102"
Unknown flag: options are B (branch), S (store),
    T (text), I (indirect addressing), F** (set this Flags 2 bit)
Only one '->' store destination can be given
Only one '?' branch destination can be given
No assembly instruction may have more than 8 operands
This opcode does not use indirect addressing
Indirect addressing can only be used on the first operand
Store destination (the last operand) is not a variable
Opcode unavailable in this Z-machine version: <name>
Assembly mistake: syntax is <syntax>
Routine contains no such label as <name>
For this operand type, opcode number must be in range <range>

12. None of the above

If you should see an incomprehensible error message beginning with ***,
then Inform itself has malfunctioned.  This is not meant to happen, but
it's conceivable that it might occur in the process of linking in a
module which has been damaged in some way.

   Finally, error messages can also be produced from within the program
(deliberately) using Message.  It may be that a mysterious message is
being caused by an included file written by someone other than yourself.


File: inform,  Node: Warnings,  Prev: Errors,  Up: Error Messages

Warnings
--------

1. Questionable practices

This statement can never be reached

There is no way that the statement being compiled can ever be executed
when the game is played.  Here is an obvious example:

    return; print "Goodbye!";

where the print statement can never be reached, because a return must
just have happened.  Beginners often run into this example:

    "You pick up the gauntlet."; score=score+1; return;

Here the score=score+1 statement is never reached because the text,
given on its own, means "print this, then print a new-line, then return
from the current routine".  The intended behaviour needs something like

    print "You pick up the gauntlet.^"; score=score+1; return;

<type> <name> declared but not used

For example, a Global directive was used to create a variable, which
was then never used in the program.

'=' used as condition: '==' intended?

Although a line like

    if (x = 5) print "My name is Alan Partridge.";

is legal, it's probably a mistake: x=5 sets x to 5 and results in 5, so
the condition is always true.  Presumably it was a mistype for x==5
meaning "test x to see if it's equal to 5".

Unlike C, Inform uses ':' to divide parts of a 'for' loop
    specification: replacing ';' with ':'

Programmers used to the C language will now and then habitually type a
for loop in the form

    for (i=0; i<10; i++) ...

but Inform needs colons, not semicolons: however, as it can see what
was intended, it makes the correction automatically and issues only a
warning.

Missing ','? Property data seems to contain the property name <name>

The following, part of an object declaration, is legal but unlikely:

    with found_in MarbleHall
         short_name "conch shell", name "conch" "shell",

As written, the found_in property has a list of three values:
MarbleHall, short_name and "conch shell".  short_name throws up the
warning because Inform suspects that a comma was missed out and the
programmer intended

    with found_in MarbleHall,
         short_name "conch shell", name "conch" "shell",

This is not a declared Attribute: <name>

Similarly, suppose that a game contains a pen.  Then the following give
statement is dubious but legal:

    give MarbleDoorway pen;

The warning is caused because it's far more likely to be a misprint for

    give MarbleDoorway open;

Without bracketing, the minus sign '-' is ambiguous

For example,

    Array Doubtful --> 50 10 -20 56;

because Inform is not sure whether this contains three entries, the
middle one being 10-20=-10, or four.  It guesses four, but suggests
brackets to clarify the situation.

Array entry too large for a byte

Byte -> and string arrays can only hold numbers in the range 0 to 255.
If a larger entry is supplied, only the remainder mod 256 is stored,
and this warning is issued.

Verb disagrees with previous verbs: <verb>

The Extend only directive is used to cleave off a set of synonymous
English verbs and make them into a new Inform verb.  For instance,
ordinarily "take", "get", "carry" and "hold" are one single Inform
verb, but this directive could split off "carry" and "get" from the
other two.  The warning would arise if one tried to split off "take"
and "drop" together, which come from different original Inform verbs.
(It's still conceivably usable, which is why it's a warning, not an
error.)

This does not set the final game's statusline

An attempt to choose, e.g., Statusline time within a module, having no
effect on the program into which the module will one day be linked.
Futile.

This module has a more advanced format than this release of the
    Inform 6 compiler knows about: it may not link in correctly

2. Obsolete usages

more modern to use 'Array', not 'Global'
use '->' instead of 'data'
use '->' instead of 'initial'
use '->' instead of 'initstr'
use 'word' as a constant dictionary address
'#a$Act' is now superceded by '##Act'
'#n$word' is now superceded by ''word''
'#r$Routine' can now be written just 'Routine'
all properties are now automatically 'long'
use the ^ character for the apostrophe in <dictionary word>

These all occur if Inform compiles a syntax which was correct under
Inform 5 (or earlier) but has now been withdrawn in favour of something
better.

!!!! No Inform library file (or any other file marked System_file)
produces warning messages.  It may contain many declared but unused
routines, or may contain obsolete usages for the sake of backward
compatibility.


File: inform,  Node: Fundamentals,  Next: The Model World,  Prev: Using the Compiler,  Up: Top

Fundamentals
************

* Menu:

* Getting Started::             Introducing `Ruins', our example game
* Messages and Classes::        Introducing messages and classes
* Actions and Reactions::       Actions are generated by the user's requests


File: inform,  Node: Getting Started,  Next: Messages and Classes,  Prev: Fundamentals,  Up: Fundamentals

Getting started
===============

     Nothing so difficult as a beginning
     In poesy, unless perhaps the end.
     
     -- Lord Byron (1788-1824), Don Juan, IV iv

The examples in Chapters III and IV of this manual will put together a
small game called `Ruins'.  Its first state is very close to the
minimal `Shell' game supplied with Inform:

Constant Story "RUINS";
Constant Headline "^An Interactive Worked Example^
             Copyright (c) 1995 by Graham Nelson.^";

Include "Parser";
Include "VerbLib";

Object Forest "Dark Forest"
  with description
          "In this tiny clearing, the pine-needle carpet is broken by
           stone-cut steps leading down into darkness.  Dark olive
           trees crowd in on all sides, the air steams with warm recent
           rain, midges hang in the air.",
  has  light;

[ Initialise;
  location = Forest;
 "^^^^^Days of searching, days of thirsty hacking through the briars of
  the forest, but at last your patience was rewarded. A discovery!^";
];

Include "Grammar";

   If you can compile this successfully, Inform is probably set up and
working properly on your computer. Compilation may take a few seconds,
because the game `includes' three library files which contain a great
deal more code.  These files are themselves written in Inform and
contain the core of ordinary rules common to all games:

         Parser       a program for decoding what the player types;
         VerbLib      how verbs, like "take" or "drop", work;
         Grammar      the grammar table, or what the Parser understands.

(If compilation is annoyingly slow, it should be easy enough to "link
the library files", which is much faster: *note Linking::.)  Apart from
the inclusions, `Ruins' contains:

  a. strings (that is, quoted text) giving the game's name and a
     copyright message, to be printed out when appropriate;

  b. a routine, called Initialise, which is run when the game begins,
     and simply sets where the player starts (not that there's much
     choice yet!) and prints a `welcome' message;

  c. an object, so far the only room.

`Ruins' is at this stage an extremely dull game:

Days of searching, days of thirsty hacking through the briars of the forest,
but at last your patience was rewarded. A discovery!

RUINS
An Interactive Worked Example
Copyright (c) 1995 by Graham Nelson.
Release 1 / Serial number 960825 / Inform v6.04 Library 6/1

Dark Forest
In this tiny clearing, the pine-needle carpet is broken by stone-cut steps
leading down into darkness.  Dark olive trees crowd in on all sides, the air
steams with warm recent rain, midges hang in the air.

>i
You are carrying nothing.

>north
You can't go that way.

>wait
Time passes.

>quit
Are you sure you want to quit? yes

(The "Release" number is 1 unless you set it otherwise, putting a
directive like Release 2; into the source code.  The "Serial number" is
set by Inform to the date of compilation.)

In an Inform game, objects are used to simulate everything: rooms and
items to be picked up, scenery, intangible things like mist and even
some abstract ideas (like the direction `north').  The library is also
present in every game, and can be thought of as a referee, or umpire,
rather than part of the game's world.

   Our second object is added by writing the following just after the
Forest ends and just before Initialise begins:

Object -> mushroom "speckled mushroom"
  with name "speckled" "mushroom" "fungus" "toadstool";

(The arrow -> means that the mushroom begins inside the Forest rather
than alongside it.)  If the game is recompiled, the mushroom is now in
play: the player can call it "speckled mushroom", "mushroom",
"toadstool" and so on.  It can be taken, dropped, looked at, looked
under and so on.  However, it only adds the rather plain line "There is
a speckled mushroom here." to the Forest's description.  So here is a
more lavish version:

Object -> mushroom "speckled mushroom"
  with name "speckled" "mushroom" "fungus" "toadstool",
       initial
          "A speckled mushroom grows out of the sodden earth, on a long stalk.";

The initial message is used to tell the player about the mushroom when
the Forest is described.  (Once the mushroom has been picked or moved,
the message is no longer used: hence the name `initial'.)  The mushroom
is, however, still "nothing special" when the player asks to "look at"
or "examine" it.  To provide a more interesting close-up view, we must
give the mushroom its own description:

Object -> mushroom "speckled mushroom"
  with name "speckled" "mushroom" "fungus" "toadstool",
       initial
          "A speckled mushroom grows out of the sodden earth, on a long stalk.",
       description
          "The mushroom is capped with blotches, and you aren't at all sure
           it's not a toadstool.",
  has  edible;

Now if we examine the mushroom, as is always wise before eating, we get
a cautionary hint; still, thanks to the edible notation, we're now able
to eat it.

   These show the two kinds of feature something can have: a "property",
which has some definite value or list of values (such as name), and an
"attribute", which is either present or not but has no particular value
(such as edible).  Values of properties change during play, and
attributes come and go.  For instance,

        mushroom.description = "You're sure it's a toadstool now.";
        give mushroom general;
        if (mushroom has edible) print "It's definitely edible.^";

manipulate the attributes and properties.  (general is the name used
for an attribute with no particular meaning to the game, but which is
left free for your program to use as it likes.  Similarly, number is a
general-purpose property.)

   We can go much further with form-filling like this, but for the sake
of example we'll begin some honest programming by adding the following
property to the mushroom:

       after
       [;  Take: "You pick the mushroom, neatly cleaving its thin stalk.";
           Drop: "The mushroom drops to the ground, battered slightly.";
       ],

The property after doesn't just have a string for a value: it has a
routine of its own.  Now after something happens to the mushroom, the
after routine is called to see if any special rules apply.  In this
case, Take and Drop are the only actions tampered with, and the only
effect is that the usual messages ("Taken." "Dropped.") are replaced.
The game can now manage a brief but plausible dialogue:

Dark Forest
In this tiny clearing, the pine-needle carpet is broken by stone-cut steps
leading down into darkness.  Dark olive trees crowd in on all sides, the air
steams with warm recent rain, midges hang in the air.
A speckled mushroom grows out of the sodden earth, on a long stalk.
>get mushroom
You pick the mushroom, neatly cleaving its thin stalk.
>look at it
The mushroom is capped with blotches, and you aren't at all sure it's not a
toadstool.
>drop it
The mushroom drops to the ground, battered slightly.

The mushroom is a little more convincing now, but still passive.  We
can give it a somewhat sad new rule by adding yet another property,
this time with a more substantial routine:

       before
       [; Eat: if (random(100) <= 30)
               {   deadflag = 1;
                  "The tiniest nibble is enough. It was a toadstool,
                   and a poisoned one at that!";
               }
               "You nibble at one corner, but the curious taste repels you.";
       ],

The before routine is called before the player's intended action takes
place.  So when the player tries typing, say, "eat the mushroom", what
happens is: in 30% of cases, she dies of toadstool poisoning; and in
the other 70%, she simply nibbles a corner of fungus (without consuming
it completely).

!! Like many programming languages, Inform braces together blocks of
code so that several statements can come under the if condition.
deadflag is a global variable, whose value does not belong to any
particular object (or routine).  It is defined somewhere in the depths
of the library: it's usually 0; setting it to 1 causes the game to be
lost, and setting it to 2 causes a win.

   Note that if the first text is printed, the rule ends there, and does
not flow on into the second text.  So one and only one message is
printed.  Here is how this is achieved: although it's not obvious from
the look of the program, the before routine is being asked the question
"Do you want to interfere with the usual rules?".  It must reply, that
is, "return", either "true" or "false" meaning yes or no.  Because this
question is asked and answered many times in a large Inform game, there
are several abbreviations for how to reply.  For example,

    return true;
    rtrue;

both do the same thing.  Moreover,

    print_ret "The tiniest nibble... ...at that!";

performs three useful tasks: prints the message, then prints a carriage
return, and then returns true.  And this is so useful that a bare string

    "The tiniest nibble... ...at that!";

is understood to mean the same thing.  To just print the text, the
statement print has to be written out in full.  Here is an example:

       before
       [; Taste: print "You extend your tongue nervously.^";
                 rfalse;
       ];

In this rule, the text is printed, but the answer to "Do you want to
interfere?" is no, so the game will then go on to print something
anodyne like "You taste nothing unexpected."  (In fact the rfalse was
unnecessary, because if a rule like this never makes any decision, then
the answer is assumed to be "false".)

Exercise 1
----------

   The present after routine for the mushroom is misleading, because it
says the mushroom has been picked every time it's taken (which will be
odd if it's taken, dropped then taken again).  Correct this to complete
the definition of the `Ruins' mushroom.

   *Note Answer 1::

!! More generally, some before or after rules ought to apply only once
in the course of a game. For instance, examining the tapestry reveals a
key, only once.  A sneaky way to do this is to make the appropriate rule
destroy itself, so for example

    tapestry.before = NULL;

removes the entire before rule for the tapestry.  NULL is a special
value, which the properties before, after, life and describe hold to
indicate "none".

Here is another typical object definition:

Object "stone-cut steps" Forest
  with name "steps" "stone" "stairs" "stone-cut",
       description
          "The cracked and worn steps descend into a dim chamber.  Yours
           might be the first feet to tread them for five hundred years.",
       door_to Square_Chamber,
       door_dir d_to
  has  scenery door open;

This is the conventional way to lay out an Object declaration: with the
header first, then with a list of properties and their starting values,
finishing up with the attributes it initially has.  (Though with and
has can be given the other way round.)

Note that the first line, the so-called header, is a little different
in form to those above.  Firstly, it gives no "program name" for the
steps (in the way that mushroom was given as program-name for the
speckled mushroom) -- there is a blank in between the Object directive
and the text of the words "short-cut steps".  This is perfectly legal,
and is sensible because the program never needs to refer to the steps
object directly.  Secondly, the initial position of the steps is
specified not by using arrows -> but by actually quoting the object it
is to be placed inside, the Forest.  This is sometimes convenient and
is only legal if the Forest has already been defined (earlier on in the
program).  Such a restriction is actually useful as it prevents you from
setting up a `loop' -- one object in another in a third in the first,
for instance.


File: inform,  Node: Messages and Classes,  Next: Actions and Reactions,  Prev: Getting Started,  Up: Fundamentals

Introducing messages and classes
================================

     On a round ball
     A workman that hath copies by, can lay
     An Europe, Afrique and an Asia,
     And quickly make that, which was nothing, All.
     
     -- John Donne (1571?-1631), Valediction: Of Weeping

In fact, messages have already appeared in *Note Getting Started::.
Recall from *Note Objects:: that a message called messagename can be
sent to an object called objectname with various supplied details
(called info1 and info2 here, though there can be any number from none
to 6) as follows:

       objectname.messagename(info1, info2);

And the given object sends back a reply value (which is just a single
quantity).  This is what is really happening when the player tries to
eat the mushroom: first the library sends the mushroom a before message
to warn it that something will happen; it might reply true, in which
case the library gives up; otherwise the eating takes place, and the
library sends an after message to inform the mushroom of its demise.

   Properties like before, then, are really rules to deal with incoming
messages.  The same applies to most of the properties in *Note
Objects::.  For example, the message

       mushroom.description();

is sent when the player tries to examine the mushroom: if the reply is
false then the game prints "You see nothing special about the speckled
mushroom."  Now the mushroom was set up with

       description
          "The mushroom is capped with blotches, and you aren't at all sure
           it's not a toadstool.",

which doesn't look like a rule for receiving a message, but it is one
all the same: it means "print this text out, print a new-line and reply
true".  A more complicated rule could have been given instead, as in
the following elaboration of the stone-cut steps in `Ruins':

       description
       [;  print "The cracked and worn steps descend into a dim chamber.
                  Yours might ";
           if (Square_Chamber has visited)
                print "be the first feet to tread";
           else print "have been the first feet to have trodden";
           " them for five hundred years.  On the top step is inscribed
            the glyph Q1.";
       ],

visited is an attribute which is currently held only by rooms which the
player has been to.  (The glyphs will be explained later on, as will
the SquareChamber room, which is where the steps will lead down into.)

   The library, i.e., the standard game rules, can send out about 40
different kinds of message, before and description being two of these.
The more interesting an object is, the more ingeniously it will respond
to these messages: an object which ignores all incoming messages will be
lifeless and inert in play, like a small stone.

!!!! In fact there are subtle differences between how the library uses
properties, and message-sending: the name property, for example, is not
really a message-receiver but is just what it appears to be -- a list
of useful data.  Also, the library is careful not to send (for
instance) a description message to an object which doesn't provide a
rule for what to do with one.  But the idea is right.

   So the library is sending out messages to your objects all the time
during play.  Your objects can also send each other messages, including
"new" ones that the library would never send.  It's sometimes
convenient to use these to trigger off happenings in the game.  For
example, suppose the `Ruins' are home to a parrot which squawks from
time to time, for a variety of reasons:

Object -> parrot "red-tailed parrot"
  with name "red" "tailed" "red-tailed" "parrot" "bird",
       description
          "Beautiful plumage.",
       squawk
       [ utterance;
           if (self in location)
               print "The parrot squawks, ~", (string) utterance,
                   "! ", (string) utterance, "!~^";
       ],
  has  animate;

We might then, for instance, change the after rule for dropping the
mushroom to read:

           Drop: parrot.squawk("Drop the mushroom");
                 "The mushroom drops to the ground, battered slightly.";

so that the wretched creature would squawk "Drop the mushroom! Drop the
mushroom!" each time this was done.  Likewise, squawk messages could be
sent for any number of other reasons connected with other objects.  But
at present it would be an error to send a squawk message to any object
other than the parrot, since only the parrot has been given a rule
telling it what to do if it receives one.

Exercise 2
----------

   Make a medicine bottle, which can be opened in a variety of ways in
the game, so that the opening--code only occurs once in the bottle
definition.

   *Note Answer 2::

In most games there are groups of objects with certain rules in common,
which it would be tiresome to have to write out many times.  For making
such a group, a class definition is the better technique.  These
closely resemble object definitions, but since they define prototypes
rather than actual things, they have no initial location.  (An
individual tree may be somewhere, but the concept of being a tree has no
particular place.)  So the `header' part of the definition is simpler.

   For example, the scoring system in `Ruins' works as follows: the
player, an archaeologist of the old school, gets a certain number of
points for each `treasure' (i.e., cultural artifact) he can filch and
put away into his packing case.  This is implemented with the following
class:

 Class Treasure
  with cultural_value 10,
       after
       [; Insert:
                if (second==packing_case)
                    score = score + self.cultural_value;
                "Safely packed away.";
       ],
       before
       [; Take, Remove:
                if (self in packing_case)
                   "Unpacking such a priceless artifact had best wait
                    until the Metropolitan Museum can do it.";
       ];

Note that self is a variable, which always means "whatever object I
am".  If we used it in the definition of the mushroom it would mean the
mushroom: used here, it means whatever treasure happens to be being
dealt with.  (Explanations about Insert and Remove will come later, but
hopefully the idea is clear enough.)  An object of the class Treasure
inherits the properties and attributes it defines: in this case, an
object of class Treasure picks up the given score and rules
automatically.  So

Treasure statuette "pygmy statuette"
  with description
          "A menacing, almost cartoon-like statuette of a pygmy spirit
           with a snake around its neck.",
       initial "A precious Mayan statuette rests here!",
       name "snake" "mayan" "pygmy" "spirit" "statue" "statuette";

inherits the cultural_value score of 10 and the rules about taking and
dropping.  If the statuette had itself set cultural_value to 15, say,
then the value would be 15, because the object's actual definition
always takes priority over anything the class might have specified.

   A more unusual artifact:

Treasure honeycomb "ancient honeycomb"
  with article "an",
       name "ancient" "old" "honey" "honeycomb",
       description "Perhaps some kind of funerary votive offering.",
       initial "An exquisitely preserved, ancient honeycomb rests here!",
       after
       [;  Eat: "Perhaps the most expensive meal of your life.  The honey
               tastes odd, perhaps because it was used to store the entrails
               of the king buried here, but still like honey.";
       ],
  has  edible;

The honeycomb now has two after rules: a new one of its own, plus the
existing one that all treasures have.  Both apply, but the new one
happens first.

!! So comparing cultural_value and after, there seems to be an
inconsistency.  In the first case, an object's own given value wiped out
the value from the class, but in the second, the two values were joined
up into a list.  Why?  The reason is that some of the library's
properties are special (again) in being what's called "additive", so
that their values accumulate into a list when class inheritance takes
place.  The three useful examples are before, after and name.

!!!! Non-library properties you invent (like squawk or cultural_value)
will never be additive, unless you write a directive like:

Property additive squawk;

(before squawk is otherwise mentioned) to say so.

Finally, note that an object can inherit from several classes at once
(see *Note Objects:: for how to give such a definition).  Moreover, a
class can itself inherit from other classes, so it's easy to make a
class for "like Treasure but with cultural_value normally 8 instead of
10".

References
----------

   * See `Balances' for an extensive use of message-sending.

   * `Advent' has a treasure-class similar to this one, and uses class
     definitions for the many similar maze and dead-end rooms (and the
     sides of the fissure).

   * That class definitions can be worthwhile even when only two
     objects use them, can be seen from the kittens-class in `Alice
     Through The Looking-Glass'.

   * `Balances' defines many complicated classes: see especially the
     white cube, spell and scroll classes.

   * `Toyshop' contains one easy one (the wax candles) and one
     unusually hard one (the building blocks).
